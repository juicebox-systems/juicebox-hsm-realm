/* automatically generated by rust-bindgen 0.64.0 */

#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]

pub const Cmd_CreateSEEWorld_Args_flags_EnableDebug: u32 = 65536;
pub const Cmd_CreateSEEWorld_Args_flags__reserved: u32 = 4294901760;
pub const Cmd_CreateSEEWorld_Args_flags__allflags: u32 = 65536;
pub const Cmd_CreateSEEWorld_Args_flags__presentflags: u32 = 0;
pub const Cmd_LoadBuffer_Args_flags_Final: u32 = 1;
pub const Cmd_LoadBuffer_Args_flags_flashsegment_present: u32 = 2;
pub const Cmd_LoadBuffer_Args_flags__reserved: u32 = 4294901760;
pub const Cmd_LoadBuffer_Args_flags__allflags: u32 = 3;
pub const Cmd_LoadBuffer_Args_flags__presentflags: u32 = 2;
pub const NFastApp_ConnectionFlags_Privileged: u32 = 1;
pub const NFastApp_ConnectionFlags_NoClientID: u32 = 2;
pub const NFastApp_ConnectionFlags_ForceClientID: u32 = 4;
pub type uint32 = ::core::ffi::c_uint;
pub type M_Word = uint32;
pub type M_MustBeZeroWord = ::core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_ByteBlock {
    pub len: M_Word,
    pub ptr: *mut ::core::ffi::c_uchar,
}
#[test]
fn bindgen_test_layout_M_ByteBlock() {
    const UNINIT: ::core::mem::MaybeUninit<M_ByteBlock> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_ByteBlock>(),
        16usize,
        concat!("Size of: ", stringify!(M_ByteBlock))
    );
    assert_eq!(
        ::core::mem::align_of::<M_ByteBlock>(),
        8usize,
        concat!("Alignment of ", stringify!(M_ByteBlock))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ByteBlock),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ByteBlock),
            "::",
            stringify!(ptr)
        )
    );
}
impl Default for M_ByteBlock {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_StringASCII = *mut ::core::ffi::c_char;
pub type M_StringUTF8 = M_StringASCII;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_ASCIIString {
    pub ptr: M_StringASCII,
}
#[test]
fn bindgen_test_layout_M_ASCIIString() {
    const UNINIT: ::core::mem::MaybeUninit<M_ASCIIString> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_ASCIIString>(),
        8usize,
        concat!("Size of: ", stringify!(M_ASCIIString))
    );
    assert_eq!(
        ::core::mem::align_of::<M_ASCIIString>(),
        8usize,
        concat!("Alignment of ", stringify!(M_ASCIIString))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ASCIIString),
            "::",
            stringify!(ptr)
        )
    );
}
impl Default for M_ASCIIString {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_ValInfo {
    pub code: ::core::ffi::c_uint,
    pub string: *const ::core::ffi::c_char,
}
#[test]
fn bindgen_test_layout_M_ValInfo() {
    const UNINIT: ::core::mem::MaybeUninit<M_ValInfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_ValInfo>(),
        16usize,
        concat!("Size of: ", stringify!(M_ValInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<M_ValInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(M_ValInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).code) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ValInfo),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).string) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ValInfo),
            "::",
            stringify!(string)
        )
    );
}
impl Default for M_ValInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Tag = M_Word;
pub type M_KeyID = M_Word;
pub type M_ModuleID = M_Word;
pub type M_SlotID = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NFast_Bignum {
    _unused: [u8; 0],
}
pub type M_Bignum = *mut NFast_Bignum;
pub const Status_OK: M_Status = 0;
pub const Status_UnknownCommand: M_Status = 1;
pub const Status_NotYetImplemented: M_Status = 2;
pub const Status_Malformed: M_Status = 3;
pub const Status_UnknownID: M_Status = 4;
pub const Status_AccessDenied: M_Status = 5;
pub const Status_ObjectInUse: M_Status = 6;
pub const Status_UseLimitExceeded: M_Status = 7;
pub const Status_TimeLimitExceeded: M_Status = 8;
pub const Status_BadCertKeyHash: M_Status = 9;
pub const Status_BadCertSignature: M_Status = 10;
pub const Status_VerifyFailed: M_Status = 11;
pub const Status_TypeMismatch: M_Status = 12;
pub const Status_BadShareState: M_Status = 13;
pub const Status_BadTokenData: M_Status = 14;
pub const Status_NoMemory: M_Status = 15;
pub const Status_Failed: M_Status = 16;
pub const Status_UnknownParameter: M_Status = 17;
pub const Status_UnknownFlag: M_Status = 18;
pub const Status_BlobTypeUnknown: M_Status = 19;
pub const Status_BufferFull: M_Status = 20;
pub const Status_UnitReset: M_Status = 21;
pub const Status_ClientUnknown: M_Status = 22;
pub const Status_CrossModule: M_Status = 23;
pub const Status_InvalidParameter: M_Status = 24;
pub const Status_InvalidState: M_Status = 25;
pub const Status_InvalidModule: M_Status = 26;
pub const Status_TokenAssemblyFailed: M_Status = 27;
pub const Status_UnknownKM: M_Status = 28;
pub const Status_LogTokenNotPresent: M_Status = 29;
pub const Status_InvalidMonitorMultiple: M_Status = 30;
pub const Status_DecryptFailed: M_Status = 31;
pub const Status_WriteProtected: M_Status = 33;
pub const Status_OutOfRange: M_Status = 34;
pub const Status_PrivilegedCommand: M_Status = 35;
pub const Status_UnknownSlot: M_Status = 36;
pub const Status_UnknownKeyHash: M_Status = 37;
pub const Status_TokenAuthFailed: M_Status = 38;
pub const Status_UnknownMechanism: M_Status = 39;
pub const Status_NoSpaceOnToken: M_Status = 40;
pub const Status_TokenNotFormatted: M_Status = 41;
pub const Status_UnknownTokenType: M_Status = 42;
pub const Status_TokenIOError: M_Status = 43;
pub const Status_EncryptFailed: M_Status = 44;
pub const Status_InvalidACL: M_Status = 45;
pub const Status_MetaDataProtection: M_Status = 46;
pub const Status_PhysTokenNotPresent: M_Status = 47;
pub const Status_MechanismNotExpected: M_Status = 48;
pub const Status_UnknownDefault: M_Status = 49;
pub const Status_AttemptedDowngrade: M_Status = 50;
pub const Status_SlotFull: M_Status = 51;
pub const Status_UnknownChallenge: M_Status = 52;
pub const Status_AsynchNotification: M_Status = 53;
pub const Status_InvalidData: M_Status = 54;
pub const Status_HardwareFailed: M_Status = 55;
pub const Status_ServerNotRunning: M_Status = 56;
pub const Status_OSErrorErrno: M_Status = 57;
pub const Status_TransactionNotFound: M_Status = 58;
pub const Status_TransactionNotYetComplete: M_Status = 59;
pub const Status_ServerConnectionLost: M_Status = 60;
pub const Status_ServerFailed: M_Status = 61;
pub const Status_StrictFIPS140: M_Status = 62;
pub const Status_UnknownStatus: M_Status = 63;
pub const Status_Cancelled: M_Status = 64;
pub const Status_UnsupportedChannelType: M_Status = 65;
pub const Status_ArithmeticError: M_Status = 66;
pub const Status_OpStackOverflow: M_Status = 67;
pub const Status_OpStackUnderflow: M_Status = 68;
pub const Status_NegativeResult: M_Status = 69;
pub const Status_HostDataInvalid: M_Status = 70;
pub const Status_HostDataAccessFailed: M_Status = 71;
pub const Status_NoUpcall: M_Status = 72;
pub const Status_NotAvailable: M_Status = 73;
pub const Status_MalformedCertificate: M_Status = 74;
pub const Status_InvalidCertificate: M_Status = 75;
pub const Status_ObjectNotReady: M_Status = 76;
pub const Status_BadMachineImage: M_Status = 77;
pub const Status_BadWorldImage: M_Status = 78;
pub const Status_SEEWorldFailed: M_Status = 79;
pub const Status_SoftwareFailed: M_Status = 80;
pub const Status_NoHostMemory: M_Status = 81;
pub const Status_NoModuleMemory: M_Status = 82;
pub const Status_IncorrectToken: M_Status = 83;
pub const Status_OperationFailed: M_Status = 84;
pub const Status_HostDataAccessDenied: M_Status = 86;
pub const Status_InvalidMergedKey: M_Status = 87;
pub const Status_AlreadyExists: M_Status = 88;
pub const Status_ReadOnly: M_Status = 89;
pub const Status_RemoteServerFailed: M_Status = 90;
pub const Status_SlotUnconnected: M_Status = 91;
pub const Status_NSTBadMessage: M_Status = 92;
pub const Status_nCErrno: M_Status = 93;
pub const Status_ImpathNotReady: M_Status = 94;
pub const Status_ImpathTimeLimitExceeded: M_Status = 95;
pub const Status_ImpathDataLimitExceeded: M_Status = 96;
pub const Status_ImpathReplay: M_Status = 97;
pub const Status_ImpathMsgTypeMismatch: M_Status = 98;
pub const Status_NoKXGroup: M_Status = 99;
pub const Status_ServerAccessDenied: M_Status = 100;
pub const Status_InProgress: M_Status = 101;
pub const Status_InvalidRM: M_Status = 102;
pub const Status_InvalidSlot: M_Status = 103;
pub const Status_UnknownPermID: M_Status = 104;
pub const Status_ForeignTokenLocked: M_Status = 105;
pub const Status_OperationTimeout: M_Status = 106;
pub const Status_SSLUnexpectedMessage: M_Status = 107;
pub const Status_SSLBadRecordMac: M_Status = 108;
pub const Status_SSLDecryptionFailed: M_Status = 109;
pub const Status_SSLRecordOverFlow: M_Status = 110;
pub const Status_SSLDecompressionFailure: M_Status = 111;
pub const Status_SSLHandshakeFailure: M_Status = 112;
pub const Status_SSLNoCertificate: M_Status = 113;
pub const Status_SSLBadCertificate: M_Status = 114;
pub const Status_SSLUnsupportedCertificate: M_Status = 115;
pub const Status_SSLCertificateRevoked: M_Status = 116;
pub const Status_SSLCertificateExpired: M_Status = 117;
pub const Status_SSLCertificateUnknown: M_Status = 118;
pub const Status_SSLIllegalParameter: M_Status = 119;
pub const Status_SSLUnknownCA: M_Status = 120;
pub const Status_SSLAccessDenied: M_Status = 121;
pub const Status_SSLDecodeError: M_Status = 122;
pub const Status_SSLDecryptError: M_Status = 123;
pub const Status_SSLExportRestriction: M_Status = 124;
pub const Status_SSLProtocolVersion: M_Status = 125;
pub const Status_SSLInsufficientSecurity: M_Status = 126;
pub const Status_SSLInternalError: M_Status = 127;
pub const Status_SSLUserCanceled: M_Status = 128;
pub const Status_SSLNoRenogotiation: M_Status = 129;
pub const Status_UnknownKey: M_Status = 130;
pub const Status_UserCancelled: M_Status = 131;
pub const Status_KeyNotLoaded: M_Status = 132;
pub const Status_HostUnknownKeyType: M_Status = 133;
pub const Status_IncorrectRepositoryName: M_Status = 134;
pub const Status_NoUsableModules: M_Status = 135;
pub const Status_InvalidHostDataIdentifier: M_Status = 136;
pub const Status_WorldUnusable: M_Status = 137;
pub const Status_MalformedPassphrase: M_Status = 138;
pub const Status_UnknownFileDevice: M_Status = 139;
pub const Status_TooManyLinks: M_Status = 140;
pub const Status_UseLimitsUnavailable: M_Status = 141;
pub const Status_Busy: M_Status = 142;
pub const Status_SecurityWorldFeatureDisabled: M_Status = 143;
pub const Status_ModuleNotUsable: M_Status = 144;
pub const Status_InappropriateObject: M_Status = 145;
pub const Status_InvalidImage: M_Status = 147;
pub const Status_InvalidModuleType: M_Status = 148;
pub const Status_RQCardUnwantedSlot: M_Status = 149;
pub const Status_RQCardUnwantedModule: M_Status = 150;
pub const Status_RQCardNeedPassphrase: M_Status = 151;
pub const Status_RQCardNeedConfirm: M_Status = 152;
pub const Status_RQCardUserCancelled: M_Status = 153;
pub const Status_RQCardMustContinue: M_Status = 154;
pub const Status_RQCardAlreadyProcessed: M_Status = 155;
pub const Status_UnknownHostVolume: M_Status = 156;
pub const Status_InvalidPathName: M_Status = 157;
pub const Status_InvalidFileName: M_Status = 158;
pub const Status_DeprecatedMechanism: M_Status = 159;
pub const Status_NetworkHSMUILockoutNotConfigured: M_Status = 160;
pub const Status_DboxEarlyExit: M_Status = 161;
pub const Status_CommandLocked: M_Status = 162;
pub const Status_CannotEncode: M_Status = 163;
pub const Status_DataOutstanding: M_Status = 164;
pub const Status_InvalidKeyType: M_Status = 176;
pub const Status_UnexpectedlyShallowNesting: M_Status = 177;
pub const Status_UnexpectedlyDeepNesting: M_Status = 178;
pub const Status_Accepted: M_Status = 179;
pub const Status_IncorrectKPSName: M_Status = 180;
pub const Status_UserAuthFailed: M_Status = 181;
pub const Status_UnknownKeyHashNEI: M_Status = 182;
pub const Status_TDMNotRegistered: M_Status = 183;
pub const Status_TDMNoSiblings: M_Status = 184;
pub const Status_IncorrectBlobFormat: M_Status = 185;
pub const Status_PythonException: M_Status = 186;
pub const Status_StreamOperationFailed: M_Status = 187;
pub const Status_SQLError: M_Status = 188;
pub const Status_SQLInternalError: M_Status = 189;
pub const Status_SQLInvalidHandle: M_Status = 190;
pub const Status_SQLNoSuchRow: M_Status = 191;
pub const Status_FragmentationError: M_Status = 192;
pub const Status_SEEJobRejected: M_Status = 193;
pub const Status_SeeHostcallProviderLock: M_Status = 194;
pub const Status_SeeHostcallProvisionFailed: M_Status = 195;
pub const Status_SeeStreamUnsupportedOperation: M_Status = 196;
pub const Status_SeeStreamInvalidDescriptor: M_Status = 197;
pub const Status_SeeStreamUnsupportedCreation: M_Status = 198;
pub const Status_SeeStreamUnexpectedResetErrorState: M_Status = 199;
pub const Status_RQCardTokenOperationFailed: M_Status = 200;
pub const Status_SeeHostcallProvisionLost: M_Status = 201;
pub const Status_DBINoRecord: M_Status = 202;
pub const Status_DBIOrphan: M_Status = 203;
pub const Status_DBIExists: M_Status = 204;
pub const Status_DBICorrupt: M_Status = 205;
pub const Status_DoesNotExist: M_Status = 206;
pub const Status_KPServerFailed: M_Status = 207;
pub const Status_KPSAuthorisationFailed: M_Status = 208;
pub const Status_SeeHostcallOperationFailed: M_Status = 209;
pub const Status_ConfigFileError: M_Status = 210;
pub const Status_SoftwareTooOld: M_Status = 211;
pub const Status_SEEWorldNotPresent: M_Status = 212;
pub const Status_UnknownESN: M_Status = 213;
pub const Status_InvalidKPReply: M_Status = 214;
pub const Status_KeyAlreadyExists: M_Status = 215;
pub const Status_IncorrectKeyStored: M_Status = 216;
pub const Status_NotManagementConnection: M_Status = 217;
pub const Status_GuardianNotStarted: M_Status = 218;
pub const Status_GuardianStarted: M_Status = 219;
pub const Status_GuardianNotSuspended: M_Status = 220;
pub const Status_GuardianSuspended: M_Status = 221;
pub const Status_GuardianDisabled: M_Status = 222;
pub const Status_GuardianNotMaster: M_Status = 223;
pub const Status_GuardianIsMaster: M_Status = 224;
pub const Status_GuardianStateTooOld: M_Status = 225;
pub const Status_InvalidCreateRegionParams: M_Status = 226;
pub const Status_UnknownRegion: M_Status = 227;
pub const Status_RegionAlreadyExists: M_Status = 228;
pub const Status_TrieInvalidPath: M_Status = 229;
pub const Status_TrieKeyPathInconsistent: M_Status = 230;
pub const Status_TrieInconsistentParameters: M_Status = 231;
pub const Status_TrieKeyMismatch: M_Status = 232;
pub const Status_DBITransactionLost: M_Status = 233;
pub const Status_UnrecoverableRegion: M_Status = 234;
pub const Status_UnknownEntityType: M_Status = 235;
pub const Status_InvalidEntityType: M_Status = 236;
pub const Status_InvalidObjspec: M_Status = 237;
pub const Status_CommandReplyMismatch: M_Status = 238;
pub const Status_ConflictingParameters: M_Status = 239;
pub const Status_DataMismatch: M_Status = 240;
pub const Status_UnknownGuardian: M_Status = 241;
pub const Status_NoActiveKey: M_Status = 242;
pub const Status_DataChangedDuringOperation: M_Status = 243;
pub const Status_NoGroupPermission: M_Status = 244;
pub const Status_DBIOutOfDate: M_Status = 245;
pub const Status_SQLConnectionLost: M_Status = 246;
pub const Status_SQLDeadlock: M_Status = 247;
pub const Status_UnknownFormat: M_Status = 248;
pub const Status_AppkeysetAlreadyExists: M_Status = 249;
pub const Status_DuplicateGroupEntry: M_Status = 250;
pub const Status_EntityAlreadyExists: M_Status = 251;
pub const Status_GroupAlreadyExists: M_Status = 252;
pub const Status_GroupPermissionAlreadyExists: M_Status = 253;
pub const Status_KeysetAlreadyExists: M_Status = 254;
pub const Status_NoSuchAppKeyset: M_Status = 255;
pub const Status_NoSuchEntityID: M_Status = 256;
pub const Status_NoSuchEntityName: M_Status = 257;
pub const Status_NoSuchGroup: M_Status = 258;
pub const Status_NoSuchGroupEntry: M_Status = 259;
pub const Status_NoSuchGroupPermission: M_Status = 260;
pub const Status_NoSuchKey: M_Status = 261;
pub const Status_NoSuchKeyset: M_Status = 262;
pub const Status_NoSuchKgdc: M_Status = 263;
pub const Status_UnknownEnrolID: M_Status = 264;
pub const Status_VerifyGuardianStateCertFailed: M_Status = 265;
pub const Status_VerifyKgdcCertFailed: M_Status = 266;
pub const Status_VerifyKgdiCertFailed: M_Status = 267;
pub const Status_VerifyKgkdcpCertFailed: M_Status = 268;
pub const Status_IncompatibleFormat: M_Status = 269;
pub const Status_TrieKeyNotFound: M_Status = 271;
pub const Status_TrieKeyAlreadyExists: M_Status = 272;
pub const Status_UnknownKPSName: M_Status = 273;
pub const Status_DBIResynchronize: M_Status = 274;
pub const Status_StrictFIPSSecurityLevel: M_Status = 275;
pub const Status_MalformedFlashTable: M_Status = 276;
pub const Status_GuardianIsOnStandby: M_Status = 277;
pub const Status_KPSConnectionLost: M_Status = 278;
pub const Status_KPSNoActiveMaster: M_Status = 279;
pub const Status_DBICorruptRecordHash: M_Status = 280;
pub const Status_DBICorruptOrderMismatch: M_Status = 281;
pub const Status_CertMissing: M_Status = 282;
pub const Status_TimeOutOfRange: M_Status = 283;
pub const Status_KPSServiceError: M_Status = 284;
pub const Status_CardNotLoaded: M_Status = 285;
pub const Status_UnknownDatabaseType: M_Status = 286;
pub const Status_KPSSigningKeyMismatch: M_Status = 287;
pub const Status_NoMastersConfigured: M_Status = 288;
pub const Status_NoModulesConfigured: M_Status = 289;
pub const Status_RTCWentBackwards: M_Status = 290;
pub const Status_NewKPSKeys: M_Status = 291;
pub const Status_StarterSystemLimitsExceeded: M_Status = 292;
pub const Status_InvalidDebugLogLevel: M_Status = 293;
pub const Status_ModuleApplicationNotSupported: M_Status = 294;
pub const Status_ModuleMonitorNotSupported: M_Status = 295;
pub const Status_InvalidWarrant: M_Status = 296;
pub const Status_InvalidWarrantRoot: M_Status = 297;
pub const Status_HostDeviceDriverNotSupported: M_Status = 298;
pub const Status_AlreadyConfigured: M_Status = 299;
pub const Status_NotYetConfigured: M_Status = 300;
pub const Status_ModuleNotWarranted: M_Status = 301;
pub const Status_TokenSecureChannelError: M_Status = 302;
pub const Status_TokenMessageError: M_Status = 303;
pub const Status_TooManyDynamicSlotOperations: M_Status = 304;
pub const Status_SynchronizationInitFailed: M_Status = 306;
pub const Status_TokenCommandTimeout: M_Status = 307;
pub const Status_UnlistedCard: M_Status = 308;
pub const Status_FrontPanelRemoteLocked: M_Status = 310;
pub const Status_RemoteLockoutModeNotConfigured: M_Status = 311;
pub const Status_CommandCannotHaveState: M_Status = 312;
pub const Status_NotPoolModule: M_Status = 313;
pub const Status_CommonCriteriaCMTSRestrictions: M_Status = 314;
pub const Status_TokenTransactionRolledBack: M_Status = 315;
pub const Status_TokenTransactionCorrupted: M_Status = 316;
pub const Status_ConnectionClosed: M_Status = 318;
pub const Status_TokenSecureChannelVersionError: M_Status = 321;
pub const Status_InvalidInterfaceName: M_Status = 322;
pub const Status__Max: M_Status = 323;
pub type M_Status = ::core::ffi::c_uint;
pub const nCErrno_UNKNOWN: M_nCErrno = 1;
pub const nCErrno_EPERM: M_nCErrno = 2;
pub const nCErrno_ENOENT: M_nCErrno = 3;
pub const nCErrno_ESRCH: M_nCErrno = 4;
pub const nCErrno_EINTR: M_nCErrno = 5;
pub const nCErrno_EIO: M_nCErrno = 6;
pub const nCErrno_ENXIO: M_nCErrno = 7;
pub const nCErrno_E2BIG: M_nCErrno = 8;
pub const nCErrno_ENOEXEC: M_nCErrno = 9;
pub const nCErrno_EBADF: M_nCErrno = 10;
pub const nCErrno_ECHILD: M_nCErrno = 11;
pub const nCErrno_EAGAIN: M_nCErrno = 12;
pub const nCErrno_ENOMEM: M_nCErrno = 13;
pub const nCErrno_EACCES: M_nCErrno = 14;
pub const nCErrno_EFAULT: M_nCErrno = 15;
pub const nCErrno_ENOTBLK: M_nCErrno = 16;
pub const nCErrno_EBUSY: M_nCErrno = 17;
pub const nCErrno_EEXIST: M_nCErrno = 18;
pub const nCErrno_EXDEV: M_nCErrno = 19;
pub const nCErrno_ENODEV: M_nCErrno = 20;
pub const nCErrno_ENOTDIR: M_nCErrno = 21;
pub const nCErrno_EISDIR: M_nCErrno = 22;
pub const nCErrno_EINVAL: M_nCErrno = 23;
pub const nCErrno_ENFILE: M_nCErrno = 24;
pub const nCErrno_EMFILE: M_nCErrno = 25;
pub const nCErrno_ENOTTY: M_nCErrno = 26;
pub const nCErrno_ETXTBSY: M_nCErrno = 27;
pub const nCErrno_EFBIG: M_nCErrno = 28;
pub const nCErrno_ENOSPC: M_nCErrno = 29;
pub const nCErrno_ESPIPE: M_nCErrno = 30;
pub const nCErrno_EROFS: M_nCErrno = 31;
pub const nCErrno_EMLINK: M_nCErrno = 32;
pub const nCErrno_EPIPE: M_nCErrno = 33;
pub const nCErrno_EDOM: M_nCErrno = 34;
pub const nCErrno_ERANGE: M_nCErrno = 35;
pub const nCErrno_EDEADLK: M_nCErrno = 36;
pub const nCErrno_ENAMETOOLONG: M_nCErrno = 37;
pub const nCErrno_ENOLCK: M_nCErrno = 38;
pub const nCErrno_ENOSYS: M_nCErrno = 39;
pub const nCErrno_ENOTEMPTY: M_nCErrno = 40;
pub const nCErrno_ELOOP: M_nCErrno = 41;
pub const nCErrno_EWOULDBLOCK: M_nCErrno = 42;
pub const nCErrno_ENOMSG: M_nCErrno = 43;
pub const nCErrno_EIDRM: M_nCErrno = 44;
pub const nCErrno_EDEADLOCK: M_nCErrno = 45;
pub const nCErrno_EREMOTE: M_nCErrno = 46;
pub const nCErrno_EOVERFLOW: M_nCErrno = 47;
pub const nCErrno_EBADFD: M_nCErrno = 48;
pub const nCErrno_EILSEQ: M_nCErrno = 49;
pub const nCErrno_EUSERS: M_nCErrno = 50;
pub const nCErrno_ENOTSOCK: M_nCErrno = 51;
pub const nCErrno_EDESTADDRREQ: M_nCErrno = 52;
pub const nCErrno_EMSGSIZE: M_nCErrno = 53;
pub const nCErrno_EPROTOTYPE: M_nCErrno = 54;
pub const nCErrno_ENOPROTOOPT: M_nCErrno = 55;
pub const nCErrno_EPROTONOSUPPORT: M_nCErrno = 56;
pub const nCErrno_ESOCKTNOSUPPORT: M_nCErrno = 57;
pub const nCErrno_EOPNOTSUPP: M_nCErrno = 58;
pub const nCErrno_EPFNOSUPPORT: M_nCErrno = 59;
pub const nCErrno_EAFNOSUPPORT: M_nCErrno = 60;
pub const nCErrno_EADDRINUSE: M_nCErrno = 61;
pub const nCErrno_EADDRNOTAVAIL: M_nCErrno = 62;
pub const nCErrno_ENETDOWN: M_nCErrno = 63;
pub const nCErrno_ENETUNREACH: M_nCErrno = 64;
pub const nCErrno_ENETRESET: M_nCErrno = 65;
pub const nCErrno_ECONNABORTED: M_nCErrno = 66;
pub const nCErrno_ECONNRESET: M_nCErrno = 67;
pub const nCErrno_ENOBUFS: M_nCErrno = 68;
pub const nCErrno_EISCONN: M_nCErrno = 69;
pub const nCErrno_ENOTCONN: M_nCErrno = 70;
pub const nCErrno_ESHUTDOWN: M_nCErrno = 71;
pub const nCErrno_ETOOMANYREFS: M_nCErrno = 72;
pub const nCErrno_ETIMEDOUT: M_nCErrno = 73;
pub const nCErrno_ECONNREFUSED: M_nCErrno = 74;
pub const nCErrno_EHOSTDOWN: M_nCErrno = 75;
pub const nCErrno_EHOSTUNREACH: M_nCErrno = 76;
pub const nCErrno_EALREADY: M_nCErrno = 77;
pub const nCErrno_EINPROGRESS: M_nCErrno = 78;
pub const nCErrno_ESTALE: M_nCErrno = 79;
pub const nCErrno_EREMOTEIO: M_nCErrno = 80;
pub const nCErrno_EDQUOT: M_nCErrno = 81;
pub const nCErrno__Max: M_nCErrno = 82;
pub type M_nCErrno = ::core::ffi::c_uint;
pub const CrossModReason_ExplicitRequest: M_CrossModReason = 1;
pub const CrossModReason_Key: M_CrossModReason = 2;
pub const CrossModReason_Mode: M_CrossModReason = 4;
pub const CrossModReason_HardwareFailed: M_CrossModReason = 5;
pub const CrossModReason_UnitReset: M_CrossModReason = 6;
pub const CrossModReason_ServerKey: M_CrossModReason = 7;
pub const CrossModReason_ServerUnitReset: M_CrossModReason = 8;
pub const CrossModReason_NotPresent: M_CrossModReason = 9;
pub const CrossModReason_NToken: M_CrossModReason = 11;
pub const CrossModReason_NetworkError: M_CrossModReason = 12;
pub const CrossModReason_NoPoolModuleSupport: M_CrossModReason = 13;
pub const CrossModReason__Max: M_CrossModReason = 14;
pub type M_CrossModReason = ::core::ffi::c_uint;
pub const NetworkAddressFamily_INET: M_NetworkAddressFamily = 2;
pub const NetworkAddressFamily_INET6: M_NetworkAddressFamily = 10;
pub const NetworkAddressFamily_HOST: M_NetworkAddressFamily = 19;
pub const NetworkAddressFamily__Max: M_NetworkAddressFamily = 20;
pub type M_NetworkAddressFamily = ::core::ffi::c_uint;
pub const KeyHashMech_SHA1Hash: M_KeyHashMech = 44;
pub const KeyHashMech_SHA256Hash: M_KeyHashMech = 93;
pub const KeyHashMech_SHA512Hash: M_KeyHashMech = 95;
pub const KeyHashMech__Max: M_KeyHashMech = 96;
pub type M_KeyHashMech = ::core::ffi::c_uint;
pub const SlotType_Unknown: M_SlotType = 0;
pub const SlotType_DataKey: M_SlotType = 1;
pub const SlotType_SmartCard: M_SlotType = 2;
pub const SlotType_Emulated: M_SlotType = 3;
pub const SlotType_SoftToken: M_SlotType = 4;
pub const SlotType_Unconnected: M_SlotType = 5;
pub const SlotType__Max: M_SlotType = 6;
pub type M_SlotType = ::core::ffi::c_uint;
pub const PlainTextType_Bytes: M_PlainTextType = 1;
pub const PlainTextType_Hash: M_PlainTextType = 2;
pub const PlainTextType_Bignum: M_PlainTextType = 3;
pub const PlainTextType_Hash16: M_PlainTextType = 4;
pub const PlainTextType_ECPoint: M_PlainTextType = 5;
pub const PlainTextType_Hash24: M_PlainTextType = 6;
pub const PlainTextType_Hash32: M_PlainTextType = 7;
pub const PlainTextType_Hash48: M_PlainTextType = 8;
pub const PlainTextType_Hash64: M_PlainTextType = 9;
pub const PlainTextType_Hash28: M_PlainTextType = 10;
pub const PlainTextType__Max: M_PlainTextType = 11;
pub type M_PlainTextType = ::core::ffi::c_uint;
pub const ChannelType_Any: M_ChannelType = 0;
pub const ChannelType_Simple: M_ChannelType = 1;
pub const ChannelType__Max: M_ChannelType = 2;
pub type M_ChannelType = ::core::ffi::c_uint;
pub const ChannelMode_Encrypt: M_ChannelMode = 1;
pub const ChannelMode_Decrypt: M_ChannelMode = 2;
pub const ChannelMode_Sign: M_ChannelMode = 3;
pub const ChannelMode_Verify: M_ChannelMode = 4;
pub const ChannelMode__Max: M_ChannelMode = 5;
pub type M_ChannelMode = ::core::ffi::c_uint;
pub const CertType_Invalid: M_CertType = 0;
pub const CertType_SigningKey: M_CertType = 1;
pub const CertType_SingleCert: M_CertType = 2;
pub const CertType_SEECert: M_CertType = 3;
pub const CertType__Max: M_CertType = 4;
pub type M_CertType = ::core::ffi::c_uint;
pub const KeyType_Any: M_KeyType = 0;
pub const KeyType_RSAPublic: M_KeyType = 1;
pub const KeyType_RSAPrivate: M_KeyType = 2;
pub const KeyType_DSAPublic: M_KeyType = 3;
pub const KeyType_DHPublic: M_KeyType = 5;
pub const KeyType_DHPrivate: M_KeyType = 6;
pub const KeyType_Random: M_KeyType = 7;
pub const KeyType_DES: M_KeyType = 11;
pub const KeyType_DES3: M_KeyType = 12;
pub const KeyType_None: M_KeyType = 13;
pub const KeyType_ArcFour: M_KeyType = 15;
pub const KeyType_CAST: M_KeyType = 18;
pub const KeyType_DSAPrivate: M_KeyType = 19;
pub const KeyType_DSAComm: M_KeyType = 20;
pub const KeyType_Void: M_KeyType = 21;
pub const KeyType_Wrapped: M_KeyType = 23;
pub const KeyType_DKTemplate: M_KeyType = 24;
pub const KeyType_HMACMD5: M_KeyType = 26;
pub const KeyType_HMACSHA1: M_KeyType = 27;
pub const KeyType_HMACRIPEMD160: M_KeyType = 28;
pub const KeyType_Serpent: M_KeyType = 29;
pub const KeyType_Rijndael: M_KeyType = 30;
pub const KeyType_Twofish: M_KeyType = 31;
pub const KeyType_CAST256: M_KeyType = 32;
pub const KeyType_Blowfish: M_KeyType = 33;
pub const KeyType_HMACSHA256: M_KeyType = 34;
pub const KeyType_HMACSHA384: M_KeyType = 35;
pub const KeyType_HMACSHA512: M_KeyType = 36;
pub const KeyType_HMACTiger: M_KeyType = 37;
pub const KeyType_KCDSAPublic: M_KeyType = 39;
pub const KeyType_KCDSAPrivate: M_KeyType = 40;
pub const KeyType_DES2: M_KeyType = 41;
pub const KeyType_KCDSAComm: M_KeyType = 42;
pub const KeyType_SEED: M_KeyType = 43;
pub const KeyType_ECPublic: M_KeyType = 44;
pub const KeyType_ECPrivate: M_KeyType = 45;
pub const KeyType_ECDSAPublic: M_KeyType = 46;
pub const KeyType_ECDSAPrivate: M_KeyType = 47;
pub const KeyType_ECDHPrivate: M_KeyType = 48;
pub const KeyType_ECDHPublic: M_KeyType = 49;
pub const KeyType_HMACSHA224: M_KeyType = 50;
pub const KeyType_ARIA: M_KeyType = 51;
pub const KeyType_Camellia: M_KeyType = 52;
pub const KeyType_ECDHLaxPrivate: M_KeyType = 53;
pub const KeyType_ECDHLaxPublic: M_KeyType = 54;
pub const KeyType_DSACommVariableSeed: M_KeyType = 55;
pub const KeyType_DSACommFIPS186_3: M_KeyType = 56;
pub const KeyType_X25519Public: M_KeyType = 59;
pub const KeyType_X25519Private: M_KeyType = 60;
pub const KeyType_Ed25519Public: M_KeyType = 65;
pub const KeyType_Ed25519Private: M_KeyType = 66;
pub const KeyType_TUAKSubscriber: M_KeyType = 67;
pub const KeyType_TUAKTOP: M_KeyType = 68;
pub const KeyType_TUAKTOPC: M_KeyType = 69;
pub const KeyType_DHExPublic: M_KeyType = 73;
pub const KeyType_DHExPrivate: M_KeyType = 74;
pub const KeyType__Max: M_KeyType = 75;
pub type M_KeyType = ::core::ffi::c_uint;
pub const ECName_Custom: M_ECName = 1;
pub const ECName_NISTP192: M_ECName = 2;
pub const ECName_NISTP224: M_ECName = 3;
pub const ECName_NISTP256: M_ECName = 4;
pub const ECName_NISTP384: M_ECName = 5;
pub const ECName_NISTP521: M_ECName = 6;
pub const ECName_NISTB163: M_ECName = 7;
pub const ECName_NISTB233: M_ECName = 8;
pub const ECName_NISTB283: M_ECName = 9;
pub const ECName_NISTB409: M_ECName = 10;
pub const ECName_NISTB571: M_ECName = 11;
pub const ECName_NISTK163: M_ECName = 12;
pub const ECName_NISTK233: M_ECName = 13;
pub const ECName_NISTK283: M_ECName = 14;
pub const ECName_NISTK409: M_ECName = 15;
pub const ECName_NISTK571: M_ECName = 16;
pub const ECName_ANSIB163v1: M_ECName = 17;
pub const ECName_ANSIB191v1: M_ECName = 18;
pub const ECName_SECP160r1: M_ECName = 19;
pub const ECName_CustomLCF: M_ECName = 20;
pub const ECName_SECP256k1: M_ECName = 22;
pub const ECName_BrainpoolP160r1: M_ECName = 23;
pub const ECName_BrainpoolP160t1: M_ECName = 24;
pub const ECName_BrainpoolP192r1: M_ECName = 25;
pub const ECName_BrainpoolP192t1: M_ECName = 26;
pub const ECName_BrainpoolP224r1: M_ECName = 27;
pub const ECName_BrainpoolP224t1: M_ECName = 28;
pub const ECName_BrainpoolP256r1: M_ECName = 29;
pub const ECName_BrainpoolP256t1: M_ECName = 30;
pub const ECName_BrainpoolP320r1: M_ECName = 31;
pub const ECName_BrainpoolP320t1: M_ECName = 32;
pub const ECName_BrainpoolP384r1: M_ECName = 33;
pub const ECName_BrainpoolP384t1: M_ECName = 34;
pub const ECName_BrainpoolP512r1: M_ECName = 35;
pub const ECName_BrainpoolP512t1: M_ECName = 36;
pub const ECName__Max: M_ECName = 37;
pub type M_ECName = ::core::ffi::c_uint;
pub const FieldType_Prime: M_FieldType = 1;
pub const FieldType_Binary: M_FieldType = 2;
pub const FieldType_NISTfP192: M_FieldType = 3;
pub const FieldType_NISTfP224: M_FieldType = 4;
pub const FieldType_NISTfP256: M_FieldType = 5;
pub const FieldType_NISTfP384: M_FieldType = 6;
pub const FieldType_NISTfP521: M_FieldType = 7;
pub const FieldType_NISTfB163: M_FieldType = 8;
pub const FieldType_NISTfB233: M_FieldType = 9;
pub const FieldType_NISTfB283: M_FieldType = 10;
pub const FieldType_NISTfB409: M_FieldType = 11;
pub const FieldType_NISTfB571: M_FieldType = 12;
pub const FieldType_ANSIfB163: M_FieldType = 13;
pub const FieldType_ANSIfB191: M_FieldType = 14;
pub const FieldType_SECfP160: M_FieldType = 15;
pub const FieldType_SECP256k1: M_FieldType = 17;
pub const FieldType_BrainpoolP160: M_FieldType = 18;
pub const FieldType_BrainpoolP224: M_FieldType = 19;
pub const FieldType_BrainpoolP256: M_FieldType = 20;
pub const FieldType_BrainpoolP320: M_FieldType = 21;
pub const FieldType_BrainpoolP384: M_FieldType = 22;
pub const FieldType_BrainpoolP512: M_FieldType = 23;
pub const FieldType_BrainpoolP192: M_FieldType = 24;
pub const FieldType__Max: M_FieldType = 25;
pub type M_FieldType = ::core::ffi::c_uint;
pub const Mech_Any: M_Mech = 0;
pub const Mech_DESmCBCi64pPKCS5: M_Mech = 1;
pub const Mech_RSApPKCS1: M_Mech = 2;
pub const Mech_DESmECBpPKCS5: M_Mech = 7;
pub const Mech_DSA: M_Mech = 10;
pub const Mech_ArcFourpNONE: M_Mech = 11;
pub const Mech_DESmCBCMACi64pPKCS5: M_Mech = 17;
pub const Mech_CASTmCBCi64pPKCS5: M_Mech = 19;
pub const Mech_CASTmECBpPKCS5: M_Mech = 20;
pub const Mech_CASTmCBCMACi64pPKCS5: M_Mech = 21;
pub const Mech_DESmECBpNONE: M_Mech = 22;
pub const Mech_DESmCBCpNONE: M_Mech = 24;
pub const Mech_DHKeyExchange: M_Mech = 26;
pub const Mech_ElGamal: M_Mech = 27;
pub const Mech_CASTmECBpNONE: M_Mech = 29;
pub const Mech_CASTmCBCpNONE: M_Mech = 32;
pub const Mech_Generic64: M_Mech = 34;
pub const Mech_Generic64MAC: M_Mech = 35;
pub const Mech_DES3mCBCi64pPKCS5: M_Mech = 37;
pub const Mech_DES3mECBpPKCS5: M_Mech = 38;
pub const Mech_DES3mCBCMACi64pPKCS5: M_Mech = 39;
pub const Mech_DES3mECBpNONE: M_Mech = 40;
pub const Mech_DES3mCBCpNONE: M_Mech = 41;
pub const Mech_SHA1Hash: M_Mech = 44;
pub const Mech_MD5Hash: M_Mech = 45;
pub const Mech_RIPEMD160Hash: M_Mech = 52;
pub const Mech_HMACMD5: M_Mech = 54;
pub const Mech_HMACSHA1: M_Mech = 55;
pub const Mech_HMACRIPEMD160: M_Mech = 56;
pub const Mech_RSAhMD5pPKCS1: M_Mech = 58;
pub const Mech_RSAhSHA1pPKCS1: M_Mech = 59;
pub const Mech_RSAhRIPEMD160pPKCS1: M_Mech = 60;
pub const Mech_RSApPKCS1OAEP: M_Mech = 61;
pub const Mech_Generic128: M_Mech = 62;
pub const Mech_Generic128MAC: M_Mech = 63;
pub const Mech_Generic192: M_Mech = 64;
pub const Mech_Generic256: M_Mech = 66;
pub const Mech_SerpentmCBCi128pPKCS5: M_Mech = 68;
pub const Mech_SerpentmECBpPKCS5: M_Mech = 69;
pub const Mech_SerpentmCBCpNONE: M_Mech = 70;
pub const Mech_SerpentmECBpNONE: M_Mech = 71;
pub const Mech_SerpentmCBCMACi128pPKCS5: M_Mech = 72;
pub const Mech_RijndaelmCBCi128pPKCS5: M_Mech = 73;
pub const Mech_RijndaelmECBpPKCS5: M_Mech = 74;
pub const Mech_RijndaelmCBCpNONE: M_Mech = 75;
pub const Mech_RijndaelmECBpNONE: M_Mech = 76;
pub const Mech_RijndaelmCBCMACi128pPKCS5: M_Mech = 77;
pub const Mech_TwofishmCBCi128pPKCS5: M_Mech = 78;
pub const Mech_TwofishmECBpPKCS5: M_Mech = 79;
pub const Mech_TwofishmCBCpNONE: M_Mech = 80;
pub const Mech_TwofishmECBpNONE: M_Mech = 81;
pub const Mech_TwofishmCBCMACi128pPKCS5: M_Mech = 82;
pub const Mech_CAST256mCBCi128pPKCS5: M_Mech = 83;
pub const Mech_CAST256mECBpPKCS5: M_Mech = 84;
pub const Mech_CAST256mCBCpNONE: M_Mech = 85;
pub const Mech_CAST256mECBpNONE: M_Mech = 86;
pub const Mech_CAST256mCBCMACi128pPKCS5: M_Mech = 87;
pub const Mech_BlowfishmCBCi64pPKCS5: M_Mech = 88;
pub const Mech_BlowfishmECBpPKCS5: M_Mech = 89;
pub const Mech_BlowfishmCBCpNONE: M_Mech = 90;
pub const Mech_BlowfishmECBpNONE: M_Mech = 91;
pub const Mech_BlowfishmCBCMACi64pPKCS5: M_Mech = 92;
pub const Mech_SHA256Hash: M_Mech = 93;
pub const Mech_SHA384Hash: M_Mech = 94;
pub const Mech_SHA512Hash: M_Mech = 95;
pub const Mech_TigerHash: M_Mech = 96;
pub const Mech_HMACSHA256: M_Mech = 97;
pub const Mech_HMACSHA384: M_Mech = 98;
pub const Mech_HMACSHA512: M_Mech = 99;
pub const Mech_HMACTiger: M_Mech = 100;
pub const Mech_Imech: M_Mech = 101;
pub const Mech_DES3wSHA1: M_Mech = 102;
pub const Mech_DES3wCRC32: M_Mech = 103;
pub const Mech_HAS160Hash: M_Mech = 109;
pub const Mech_KCDSAHAS160: M_Mech = 110;
pub const Mech_KCDSASHA1: M_Mech = 111;
pub const Mech_KCDSARIPEMD160: M_Mech = 112;
pub const Mech_DES2mCBCi64pPKCS5: M_Mech = 113;
pub const Mech_DES2mCBCpNONE: M_Mech = 114;
pub const Mech_DES2mECBpPKCS5: M_Mech = 115;
pub const Mech_DES2mCBCMACi64pPKCS5: M_Mech = 116;
pub const Mech_DES2mECBpNONE: M_Mech = 117;
pub const Mech_RSApPKCS1pPKCS11: M_Mech = 118;
pub const Mech_SEEDmECBpNONE: M_Mech = 119;
pub const Mech_SEEDmECBpPKCS5: M_Mech = 120;
pub const Mech_SEEDmCBCpNONE: M_Mech = 121;
pub const Mech_SEEDmCBCi128pPKCS5: M_Mech = 122;
pub const Mech_SEEDmCBCMACi128pPKCS5: M_Mech = 123;
pub const Mech_DLIESe3DEShSHA1: M_Mech = 124;
pub const Mech_DLIESeAEShSHA1: M_Mech = 125;
pub const Mech_DESmCBCMACi0pPKCS5: M_Mech = 130;
pub const Mech_CASTmCBCMACi0pPKCS5: M_Mech = 131;
pub const Mech_DES3mCBCMACi0pPKCS5: M_Mech = 132;
pub const Mech_BlowfishmCBCMACi0pPKCS5: M_Mech = 134;
pub const Mech_DES2mCBCMACi0pPKCS5: M_Mech = 135;
pub const Mech_SerpentmCBCMACi0pPKCS5: M_Mech = 136;
pub const Mech_RijndaelmCBCMACi0pPKCS5: M_Mech = 137;
pub const Mech_TwofishmCBCMACi0pPKCS5: M_Mech = 138;
pub const Mech_CAST256mCBCMACi0pPKCS5: M_Mech = 139;
pub const Mech_SEEDmCBCMACi0pPKCS5: M_Mech = 140;
pub const Mech_BlobCryptv2kHasheRijndaelCBC0hSHA1mSHA1HMAC: M_Mech = 141;
pub const Mech_BlobCryptv2kRSAeRijndaelCBC0hSHA1mSHA1HMAC: M_Mech = 142;
pub const Mech_BlobCryptv2kDHeRijndaelCBC0hSHA1mSHA1HMAC: M_Mech = 143;
pub const Mech_BlobCrypt: M_Mech = 144;
pub const Mech_BlobCryptv2kHasheDES3CBC0hSHA1mSHA1HMAC: M_Mech = 145;
pub const Mech_BlobCryptv2kRSAeDES3CBC0hSHA1mSHA1HMAC: M_Mech = 146;
pub const Mech_BlobCryptv2kDHeDES3CBC0hSHA1mSHA1HMAC: M_Mech = 147;
pub const Mech_BlobCryptv2kHasheRijndaelCBC0hSHA256mSHA256HMAC: M_Mech = 148;
pub const Mech_BlobCryptv2kRSAeRijndaelCBC0hSHA256mSHA256HMAC: M_Mech = 149;
pub const Mech_BlobCryptv2kDHeRijndaelCBC0hSHA256mSHA256HMAC: M_Mech = 150;
pub const Mech_BlobCryptv2kHasheRijndaelCBC0hSHA512mSHA512HMAC: M_Mech = 151;
pub const Mech_BlobCryptv2kRSAeRijndaelCBC0hSHA512mSHA512HMAC: M_Mech = 152;
pub const Mech_BlobCryptv2kDHeRijndaelCBC0hSHA512mSHA512HMAC: M_Mech = 153;
pub const Mech_ECDSA: M_Mech = 154;
pub const Mech_ECDHKeyExchange: M_Mech = 155;
pub const Mech_DESmCBCMACi0pNONE: M_Mech = 156;
pub const Mech_DES2mCBCMACi0pNONE: M_Mech = 157;
pub const Mech_DES3mCBCMACi0pNONE: M_Mech = 158;
pub const Mech_RijndaelmCBCMACi0pNONE: M_Mech = 159;
pub const Mech_RSAhSHA1pPSS: M_Mech = 160;
pub const Mech_RSAhSHA256pPSS: M_Mech = 161;
pub const Mech_RSAhSHA384pPSS: M_Mech = 162;
pub const Mech_RSAhSHA512pPSS: M_Mech = 163;
pub const Mech_RSAhSHA256pPKCS1: M_Mech = 164;
pub const Mech_RSAhSHA384pPKCS1: M_Mech = 165;
pub const Mech_RSAhSHA512pPKCS1: M_Mech = 166;
pub const Mech_SHA224Hash: M_Mech = 167;
pub const Mech_HMACSHA224: M_Mech = 168;
pub const Mech_DSAhSHA224: M_Mech = 169;
pub const Mech_DSAhSHA256: M_Mech = 170;
pub const Mech_DSAhSHA384: M_Mech = 171;
pub const Mech_DSAhSHA512: M_Mech = 172;
pub const Mech_RSAhSHA224pPSS: M_Mech = 173;
pub const Mech_RSAhSHA224pPKCS1: M_Mech = 174;
pub const Mech_ARIAmCBCpNONE: M_Mech = 175;
pub const Mech_ARIAmECBpNONE: M_Mech = 176;
pub const Mech_RijndaelmCMAC: M_Mech = 177;
pub const Mech_GenericGCM128: M_Mech = 178;
pub const Mech_RijndaelmGCM: M_Mech = 179;
pub const Mech_KCDSASHA224: M_Mech = 180;
pub const Mech_KCDSASHA256: M_Mech = 181;
pub const Mech_ECDSAhSHA224: M_Mech = 184;
pub const Mech_ECDSAhSHA256: M_Mech = 185;
pub const Mech_ECDSAhSHA384: M_Mech = 186;
pub const Mech_ECDSAhSHA512: M_Mech = 187;
pub const Mech_CamelliamCBCpNONE: M_Mech = 188;
pub const Mech_CamelliamECBpNONE: M_Mech = 189;
pub const Mech_ECDHLaxKeyExchange: M_Mech = 190;
pub const Mech_RSAhRIPEMD160pPSS: M_Mech = 191;
pub const Mech_ECDSAhRIPEMD160: M_Mech = 192;
pub const Mech_DSAhRIPEMD160: M_Mech = 193;
pub const Mech_RSApPKCS1OAEPhSHA224: M_Mech = 195;
pub const Mech_RSApPKCS1OAEPhSHA256: M_Mech = 196;
pub const Mech_RSApPKCS1OAEPhSHA384: M_Mech = 197;
pub const Mech_RSApPKCS1OAEPhSHA512: M_Mech = 198;
pub const Mech_SEEDmCBCMACi0pNONE: M_Mech = 203;
pub const Mech_ECDSAhSHA256kGBCS: M_Mech = 204;
pub const Mech_SHA3b224Hash: M_Mech = 205;
pub const Mech_SHA3b256Hash: M_Mech = 206;
pub const Mech_SHA3b384Hash: M_Mech = 207;
pub const Mech_SHA3b512Hash: M_Mech = 208;
pub const Mech_Ed25519ph: M_Mech = 217;
pub const Mech_X25519KeyExchange: M_Mech = 218;
pub const Mech_Ed25519: M_Mech = 219;
pub const Mech_BlobCryptv3kNoneeAESCBC0dCTRCMACmSHA256HMAC: M_Mech = 222;
pub const Mech_BlobCryptv3kRSAOAEPeAESCBC0dCTRCMACmSHA256HMAC: M_Mech = 223;
pub const Mech_BlobCryptv3kNoneeAESCBC0dCTRCMACmSHA512HMAC: M_Mech = 224;
pub const Mech_BlobCryptv3kRSAOAEPeAESCBC0dCTRCMACmSHA512HMAC: M_Mech = 225;
pub const Mech_DHExKeyExchange: M_Mech = 226;
pub const Mech_DLIESeAEShSHA1DHEx: M_Mech = 227;
pub const Mech_AESKeyWrapPadded: M_Mech = 228;
pub const Mech_ECDHCKeyExchange: M_Mech = 229;
pub const Mech_AESmGCM: M_Mech = 232;
pub const Mech__Max: M_Mech = 233;
pub type M_Mech = ::core::ffi::c_uint;
pub const FileDevice_PhysToken: M_FileDevice = 1;
pub const FileDevice_NVMem: M_FileDevice = 2;
pub const FileDevice_NVMemPersist: M_FileDevice = 3;
pub const FileDevice__Max: M_FileDevice = 4;
pub type M_FileDevice = ::core::ffi::c_uint;
pub const BlobFormat_None: M_BlobFormat = 0;
pub const BlobFormat_Module: M_BlobFormat = 5;
pub const BlobFormat_Token: M_BlobFormat = 6;
pub const BlobFormat_Direct: M_BlobFormat = 7;
pub const BlobFormat_Indirect: M_BlobFormat = 8;
pub const BlobFormat_UserKey: M_BlobFormat = 9;
pub const BlobFormat__Max: M_BlobFormat = 10;
pub type M_BlobFormat = ::core::ffi::c_uint;
pub const DeriveMech_Any: M_DeriveMech = 0;
pub const DeriveMech_DESsplitXOR: M_DeriveMech = 1;
pub const DeriveMech_DESjoinXOR: M_DeriveMech = 2;
pub const DeriveMech_DES3splitXOR: M_DeriveMech = 3;
pub const DeriveMech_DES3joinXOR: M_DeriveMech = 4;
pub const DeriveMech_DESjoinXORsetParity: M_DeriveMech = 5;
pub const DeriveMech_DES3joinXORsetParity: M_DeriveMech = 6;
pub const DeriveMech_RandsplitXOR: M_DeriveMech = 7;
pub const DeriveMech_RandjoinXOR: M_DeriveMech = 8;
pub const DeriveMech_CASTsplitXOR: M_DeriveMech = 9;
pub const DeriveMech_CASTjoinXOR: M_DeriveMech = 10;
pub const DeriveMech_EncryptMarshalled: M_DeriveMech = 11;
pub const DeriveMech_DecryptMarshalled: M_DeriveMech = 12;
pub const DeriveMech_SSL3withRSA: M_DeriveMech = 13;
pub const DeriveMech_TLSwithRSA: M_DeriveMech = 14;
pub const DeriveMech_SSL3withDH: M_DeriveMech = 15;
pub const DeriveMech_TLSwithDH: M_DeriveMech = 16;
pub const DeriveMech_RawEncrypt: M_DeriveMech = 17;
pub const DeriveMech_RawDecrypt: M_DeriveMech = 18;
pub const DeriveMech_DES2splitXOR: M_DeriveMech = 19;
pub const DeriveMech_DES2joinXOR: M_DeriveMech = 20;
pub const DeriveMech_DES2joinXORsetParity: M_DeriveMech = 21;
pub const DeriveMech_PKCS8Encrypt: M_DeriveMech = 22;
pub const DeriveMech_PKCS8Decrypt: M_DeriveMech = 23;
pub const DeriveMech_RSAComponents: M_DeriveMech = 24;
pub const DeriveMech_KDPKeyWrapDES3: M_DeriveMech = 25;
pub const DeriveMech_AESsplitXOR: M_DeriveMech = 26;
pub const DeriveMech_AESjoinXOR: M_DeriveMech = 27;
pub const DeriveMech_SignedKDPKeyWrapDES3: M_DeriveMech = 28;
pub const DeriveMech_PublicFromPrivate: M_DeriveMech = 29;
pub const DeriveMech_ECCMQV: M_DeriveMech = 30;
pub const DeriveMech_ConcatenateBytes: M_DeriveMech = 31;
pub const DeriveMech_ConcatenationKDF: M_DeriveMech = 32;
pub const DeriveMech_NISTKDFmCTRpRijndaelCMACr32: M_DeriveMech = 33;
pub const DeriveMech_RawEncryptZeroPad: M_DeriveMech = 34;
pub const DeriveMech_RawDecryptZeroPad: M_DeriveMech = 35;
pub const DeriveMech_AESKeyWrap: M_DeriveMech = 36;
pub const DeriveMech_AESKeyUnwrap: M_DeriveMech = 37;
pub const DeriveMech_PKCS8DecryptEx: M_DeriveMech = 38;
pub const DeriveMech_CompositeWatchWordVerify: M_DeriveMech = 39;
pub const DeriveMech_CompositeWatchWordSign: M_DeriveMech = 40;
pub const DeriveMech_CompositeARQCVerify: M_DeriveMech = 41;
pub const DeriveMech_HyperledgerClient: M_DeriveMech = 43;
pub const DeriveMech_ECDHKA: M_DeriveMech = 46;
pub const DeriveMech_ECIESKeyWrap: M_DeriveMech = 47;
pub const DeriveMech_ECIESKeyUnwrap: M_DeriveMech = 48;
pub const DeriveMech_NISTKDFmCTRr8: M_DeriveMech = 49;
pub const DeriveMech_ECCMQVdNISTCKDF: M_DeriveMech = 50;
pub const DeriveMech_TUAKTOPC: M_DeriveMech = 51;
pub const DeriveMech_TUAKf1: M_DeriveMech = 52;
pub const DeriveMech_TUAKf1s: M_DeriveMech = 53;
pub const DeriveMech_TUAKf2345: M_DeriveMech = 54;
pub const DeriveMech_TUAKf5s: M_DeriveMech = 55;
pub const DeriveMech_DHKA: M_DeriveMech = 56;
pub const DeriveMech_X25519KA: M_DeriveMech = 57;
pub const DeriveMech_TestKX: M_DeriveMech = 58;
pub const DeriveMech_GenerateRSAB36: M_DeriveMech = 59;
pub const DeriveMech__Max: M_DeriveMech = 60;
pub type M_DeriveMech = ::core::ffi::c_uint;
pub const ARQCScheme_EMV2000: M_ARQCScheme = 1;
pub const ARQCScheme_EMV2004: M_ARQCScheme = 2;
pub const ARQCScheme_MCHIP21: M_ARQCScheme = 3;
pub const ARQCScheme_VIS10: M_ARQCScheme = 4;
pub const ARQCScheme_VIS10TDS: M_ARQCScheme = 5;
pub const ARQCScheme_MCHIP21TDS: M_ARQCScheme = 6;
pub const ARQCScheme_VIS18: M_ARQCScheme = 7;
pub const ARQCScheme_VIS18TDS: M_ARQCScheme = 8;
pub const ARQCScheme_VIS22: M_ARQCScheme = 9;
pub const ARQCScheme_VIS22TDS: M_ARQCScheme = 10;
pub const ARQCScheme__Max: M_ARQCScheme = 11;
pub type M_ARQCScheme = ::core::ffi::c_uint;
pub const KAPrimitive_Any: M_KAPrimitive = 0;
pub const KAPrimitive_ECDHdKDF2: M_KAPrimitive = 1;
pub const KAPrimitive_ECDHCdKDF2: M_KAPrimitive = 2;
pub const KAPrimitive_PKCS11LSB: M_KAPrimitive = 3;
pub const KAPrimitive_PKCS11MSB: M_KAPrimitive = 4;
pub const KAPrimitive__Max: M_KAPrimitive = 5;
pub type M_KAPrimitive = ::core::ffi::c_uint;
pub const IESCipherMode_Any: M_IESCipherMode = 0;
pub const IESCipherMode_XORwithHMAC: M_IESCipherMode = 1;
pub const IESCipherMode__Max: M_IESCipherMode = 2;
pub type M_IESCipherMode = ::core::ffi::c_uint;
pub const TestKXGroup_ImpathMODP3072: M_TestKXGroup = 1;
pub const TestKXGroup_SecureChannelv1: M_TestKXGroup = 2;
pub const TestKXGroup__Max: M_TestKXGroup = 3;
pub type M_TestKXGroup = ::core::ffi::c_uint;
pub const TestKXSessionKey_OutboundEncryption: M_TestKXSessionKey = 1;
pub const TestKXSessionKey_OutboundMAC: M_TestKXSessionKey = 2;
pub const TestKXSessionKey_InboundEncryption: M_TestKXSessionKey = 3;
pub const TestKXSessionKey_InboundMAC: M_TestKXSessionKey = 4;
pub const TestKXSessionKey__Max: M_TestKXSessionKey = 5;
pub type M_TestKXSessionKey = ::core::ffi::c_uint;
pub const RemoteServerOp_All: M_RemoteServerOp = 1;
pub const RemoteServerOp_ExportSlot: M_RemoteServerOp = 2;
pub const RemoteServerOp_ExportModule: M_RemoteServerOp = 3;
pub const RemoteServerOp_AccessFiles: M_RemoteServerOp = 4;
pub const RemoteServerOp__Max: M_RemoteServerOp = 5;
pub type M_RemoteServerOp = ::core::ffi::c_uint;
pub const ClientPermission_Unpriv: M_ClientPermission = 1;
pub const ClientPermission_Unix: M_ClientPermission = 2;
pub const ClientPermission_Wideopen: M_ClientPermission = 3;
pub const ClientPermission__Max: M_ClientPermission = 4;
pub type M_ClientPermission = ::core::ffi::c_uint;
pub const ModuleAttribTag_None: M_ModuleAttribTag = 0;
pub const ModuleAttribTag_Challenge: M_ModuleAttribTag = 1;
pub const ModuleAttribTag_ESN: M_ModuleAttribTag = 2;
pub const ModuleAttribTag_KML: M_ModuleAttribTag = 3;
pub const ModuleAttribTag_KLF: M_ModuleAttribTag = 4;
pub const ModuleAttribTag_KNSO: M_ModuleAttribTag = 5;
pub const ModuleAttribTag_KMList: M_ModuleAttribTag = 6;
pub const ModuleAttribTag_PhysSerial: M_ModuleAttribTag = 7;
pub const ModuleAttribTag_PhysFIPSl3: M_ModuleAttribTag = 8;
pub const ModuleAttribTag_FeatureGoldCert: M_ModuleAttribTag = 9;
pub const ModuleAttribTag_Enquiry: M_ModuleAttribTag = 10;
pub const ModuleAttribTag_AdditionalInfo: M_ModuleAttribTag = 11;
pub const ModuleAttribTag_ModKeyInfo: M_ModuleAttribTag = 12;
pub const ModuleAttribTag_KLF2: M_ModuleAttribTag = 13;
pub const ModuleAttribTag_KAL: M_ModuleAttribTag = 14;
pub const ModuleAttribTag_KLF3: M_ModuleAttribTag = 15;
pub const ModuleAttribTag_WarrantKLF2: M_ModuleAttribTag = 16;
pub const ModuleAttribTag_WarrantKLF3: M_ModuleAttribTag = 17;
pub const ModuleAttribTag__Max: M_ModuleAttribTag = 18;
pub type M_ModuleAttribTag = ::core::ffi::c_uint;
pub const ModuleType_None: M_ModuleType = 0;
pub const ModuleType_Clyde: M_ModuleType = 2;
pub const ModuleType_Chili: M_ModuleType = 4;
pub const ModuleType_Ariel: M_ModuleType = 5;
pub const ModuleType_Persil: M_ModuleType = 6;
pub const ModuleType_Dorris: M_ModuleType = 7;
pub const ModuleType_Morris: M_ModuleType = 8;
pub const ModuleType_SeaBird: M_ModuleType = 9;
pub const ModuleType_Cosmo: M_ModuleType = 10;
pub const ModuleType_Zowie: M_ModuleType = 11;
pub const ModuleType_Sawshark: M_ModuleType = 12;
pub const ModuleType_Emulator: M_ModuleType = 13;
pub const ModuleType_Ultra: M_ModuleType = 14;
pub const ModuleType_Unknown: M_ModuleType = 999;
pub const ModuleType_PoolModule: M_ModuleType = 1001;
pub const ModuleType__Max: M_ModuleType = 1002;
pub type M_ModuleType = ::core::ffi::c_uint;
pub const SEEMachineType_None: M_SEEMachineType = 0;
pub const SEEMachineType_gen1AIF: M_SEEMachineType = 1;
pub const SEEMachineType_PowerPCSXF: M_SEEMachineType = 2;
pub const SEEMachineType_Virtual: M_SEEMachineType = 3;
pub const SEEMachineType_ARMtype2: M_SEEMachineType = 4;
pub const SEEMachineType_PowerPCELF: M_SEEMachineType = 5;
pub const SEEMachineType__Max: M_SEEMachineType = 6;
pub type M_SEEMachineType = ::core::ffi::c_uint;
pub const FeatureGoldCertVendor_VeriSign: M_FeatureGoldCertVendor = 1;
pub const FeatureGoldCertVendor_InternalTestingOnly: M_FeatureGoldCertVendor = 2;
pub const FeatureGoldCertVendor__Max: M_FeatureGoldCertVendor = 3;
pub type M_FeatureGoldCertVendor = ::core::ffi::c_uint;
pub const Cmd_ErrorReturn: M_Cmd = 0;
pub const Cmd_ModExp: M_Cmd = 1;
pub const Cmd_ModExpCrt: M_Cmd = 2;
pub const Cmd_GeneratePrime: M_Cmd = 5;
pub const Cmd_GenerateRandom: M_Cmd = 8;
pub const Cmd_GenerateKey: M_Cmd = 9;
pub const Cmd_GenerateKeyPair: M_Cmd = 10;
pub const Cmd_Import: M_Cmd = 11;
pub const Cmd_Duplicate: M_Cmd = 12;
pub const Cmd_GetKeyInfo: M_Cmd = 13;
pub const Cmd_Destroy: M_Cmd = 14;
pub const Cmd_Encrypt: M_Cmd = 15;
pub const Cmd_Decrypt: M_Cmd = 16;
pub const Cmd_Verify: M_Cmd = 17;
pub const Cmd_Export: M_Cmd = 18;
pub const Cmd_GetAppData: M_Cmd = 19;
pub const Cmd_SetAppData: M_Cmd = 20;
pub const Cmd_NewClient: M_Cmd = 21;
pub const Cmd_ExistingClient: M_Cmd = 22;
pub const Cmd_GetWhichModule: M_Cmd = 23;
pub const Cmd_MergeKeyIDs: M_Cmd = 24;
pub const Cmd_GenerateLogicalToken: M_Cmd = 26;
pub const Cmd_WriteShare: M_Cmd = 27;
pub const Cmd_GetSlotList: M_Cmd = 28;
pub const Cmd_GetSlotInfo: M_Cmd = 29;
pub const Cmd_ReadShare: M_Cmd = 30;
pub const Cmd_LoadBlob: M_Cmd = 32;
pub const Cmd_LoadLogicalToken: M_Cmd = 34;
pub const Cmd_EraseShare: M_Cmd = 35;
pub const Cmd_ChangeSharePIN: M_Cmd = 36;
pub const Cmd_WriteFile: M_Cmd = 37;
pub const Cmd_ReadFile: M_Cmd = 38;
pub const Cmd_EraseFile: M_Cmd = 39;
pub const Cmd_ProgrammingBegin: M_Cmd = 40;
pub const Cmd_ProgrammingBeginChunk: M_Cmd = 41;
pub const Cmd_ProgrammingLoadBlock: M_Cmd = 42;
pub const Cmd_ProgrammingEndChunk: M_Cmd = 43;
pub const Cmd_ProgrammingEnd: M_Cmd = 44;
pub const Cmd_FormatToken: M_Cmd = 45;
pub const Cmd_SetKM: M_Cmd = 47;
pub const Cmd_RemoveKM: M_Cmd = 48;
pub const Cmd_GetKMList: M_Cmd = 49;
pub const Cmd_InitialiseUnit: M_Cmd = 50;
pub const Cmd_Maintenance: M_Cmd = 51;
pub const Cmd_Fail: M_Cmd = 52;
pub const Cmd_NewEnquiry: M_Cmd = 53;
pub const Cmd_NoOp: M_Cmd = 54;
pub const Cmd_Sign: M_Cmd = 55;
pub const Cmd_ModuleInfo: M_Cmd = 56;
pub const Cmd_ProgrammingGetKeyList: M_Cmd = 57;
pub const Cmd_InsertSoftToken: M_Cmd = 58;
pub const Cmd_RemoveSoftToken: M_Cmd = 59;
pub const Cmd_GetChallenge: M_Cmd = 60;
pub const Cmd_ANModuleReset: M_Cmd = 61;
pub const Cmd_MakeBlob: M_Cmd = 62;
pub const Cmd_GetLogicalTokenInfo: M_Cmd = 63;
pub const Cmd_GetKML: M_Cmd = 64;
pub const Cmd_ANReadTerminated: M_Cmd = 65;
pub const Cmd_ANPleaseClearUnitSoon: M_Cmd = 66;
pub const Cmd_ANPleaseClearUnitNow: M_Cmd = 67;
pub const Cmd_PauseForNotifications: M_Cmd = 68;
pub const Cmd_Hash: M_Cmd = 69;
pub const Cmd_ClearUnit: M_Cmd = 70;
pub const Cmd_ChannelOpen: M_Cmd = 71;
pub const Cmd_ChannelUpdate: M_Cmd = 72;
pub const Cmd_GetACL: M_Cmd = 73;
pub const Cmd_SetACL: M_Cmd = 74;
pub const Cmd_DeriveKey: M_Cmd = 75;
pub const Cmd_RetryFailedModule: M_Cmd = 76;
pub const Cmd_BignumOp: M_Cmd = 77;
pub const Cmd_RSAImmedSignDecrypt: M_Cmd = 78;
pub const Cmd_RSAImmedVerifyEncrypt: M_Cmd = 79;
pub const Cmd_StatEnumTree: M_Cmd = 80;
pub const Cmd_StatGetValues: M_Cmd = 81;
pub const Cmd_LoadRaw: M_Cmd = 87;
pub const Cmd_NVMemAlloc: M_Cmd = 88;
pub const Cmd_NVMemList: M_Cmd = 89;
pub const Cmd_NVMemOp: M_Cmd = 90;
pub const Cmd_NVMemFree: M_Cmd = 91;
pub const Cmd_GetRTC: M_Cmd = 92;
pub const Cmd_SetRTC: M_Cmd = 93;
pub const Cmd_CreateSEEWorld: M_Cmd = 94;
pub const Cmd_SEEJob: M_Cmd = 95;
pub const Cmd_CreateBuffer: M_Cmd = 96;
pub const Cmd_LoadBuffer: M_Cmd = 97;
pub const Cmd_SetSEEMachine: M_Cmd = 98;
pub const Cmd_TraceSEEWorld: M_Cmd = 99;
pub const Cmd_GetTicket: M_Cmd = 100;
pub const Cmd_RedeemTicket: M_Cmd = 101;
pub const Cmd_SetNSOPerms: M_Cmd = 102;
pub const Cmd_PollModuleState: M_Cmd = 103;
pub const Cmd_PollSlotList: M_Cmd = 104;
pub const Cmd_ANModuleChangeEvent: M_Cmd = 105;
pub const Cmd_ANSlotChangeEvent: M_Cmd = 106;
pub const Cmd_ImpathKXBegin: M_Cmd = 107;
pub const Cmd_ImpathKXFinish: M_Cmd = 108;
pub const Cmd_ImpathGetInfo: M_Cmd = 109;
pub const Cmd_ImpathSend: M_Cmd = 110;
pub const Cmd_ImpathReceive: M_Cmd = 111;
pub const Cmd_SendShare: M_Cmd = 112;
pub const Cmd_ReceiveShare: M_Cmd = 113;
pub const Cmd_ImportSlot: M_Cmd = 119;
pub const Cmd_UnimportSlot: M_Cmd = 120;
pub const Cmd_ExportSlot: M_Cmd = 121;
pub const Cmd_ServerSendShare: M_Cmd = 122;
pub const Cmd_GetClientHash: M_Cmd = 123;
pub const Cmd_UpdateMergedKey: M_Cmd = 124;
pub const Cmd_GetWorldSigners: M_Cmd = 125;
pub const Cmd_ForeignTokenOpen: M_Cmd = 126;
pub const Cmd_ForeignTokenCmd: M_Cmd = 127;
pub const Cmd_GetKeyInfoEx: M_Cmd = 129;
pub const Cmd_FirmwareAuthenticate: M_Cmd = 130;
pub const Cmd_SignModuleState: M_Cmd = 131;
pub const Cmd_GenerateKLF: M_Cmd = 132;
pub const Cmd_GetKLF: M_Cmd = 133;
pub const Cmd_AddRemoteServerPermission: M_Cmd = 134;
pub const Cmd_RemoveRemoteServerPermission: M_Cmd = 135;
pub const Cmd_ListRemoteServerPermission: M_Cmd = 136;
pub const Cmd_ANRemoteSlotDisconnected: M_Cmd = 137;
pub const Cmd_GetLogicalTokenInfoEx: M_Cmd = 138;
pub const Cmd_GetShareACL: M_Cmd = 139;
pub const Cmd_StaticFeatureEnable: M_Cmd = 140;
pub const Cmd_CheckUserAction: M_Cmd = 142;
pub const Cmd_FileCreate: M_Cmd = 143;
pub const Cmd_FileErase: M_Cmd = 144;
pub const Cmd_FileOp: M_Cmd = 145;
pub const Cmd_FileCopy: M_Cmd = 146;
pub const Cmd_ImportModule: M_Cmd = 147;
pub const Cmd_UnimportModule: M_Cmd = 148;
pub const Cmd_SetMaxNumClients: M_Cmd = 149;
pub const Cmd_ExportModule: M_Cmd = 150;
pub const Cmd_ANRemoteModuleDisconnected: M_Cmd = 151;
pub const Cmd_GetModuleState: M_Cmd = 152;
pub const Cmd_ServerNoOp: M_Cmd = 153;
pub const Cmd_FTSessionOpen: M_Cmd = 154;
pub const Cmd_FTStartRead: M_Cmd = 155;
pub const Cmd_FTRead: M_Cmd = 156;
pub const Cmd_FTStartWrite: M_Cmd = 157;
pub const Cmd_FTWrite: M_Cmd = 158;
pub const Cmd_FTStartListDir: M_Cmd = 159;
pub const Cmd_FTListDir: M_Cmd = 160;
pub const Cmd_SetPublishedObject: M_Cmd = 161;
pub const Cmd_RemovePublishedObject: M_Cmd = 162;
pub const Cmd_GetPublishedObject: M_Cmd = 163;
pub const Cmd_ReReadConfig: M_Cmd = 164;
pub const Cmd_RemoteSlots: M_Cmd = 165;
pub const Cmd_GetKnetiPub: M_Cmd = 166;
pub const Cmd_AnonymousKnetiHash: M_Cmd = 167;
pub const Cmd_IOBoardReprogram: M_Cmd = 169;
pub const Cmd_FTStat: M_Cmd = 173;
pub const Cmd_GetServerConfig: M_Cmd = 181;
pub const Cmd_QueryLongJobs: M_Cmd = 182;
pub const Cmd_FastSEEJob: M_Cmd = 183;
pub const Cmd_FTDelete: M_Cmd = 184;
pub const Cmd_FTChecksum: M_Cmd = 185;
pub const Cmd_FRAGMENT: M_Cmd = 186;
pub const Cmd_ProductionSetup: M_Cmd = 187;
pub const Cmd_MakeSEEWill: M_Cmd = 188;
pub const Cmd_ExecuteSEEWill: M_Cmd = 189;
pub const Cmd_ReadSoftTokenShare: M_Cmd = 194;
pub const Cmd_CreateClient: M_Cmd = 195;
pub const Cmd_InitialiseUnitEx: M_Cmd = 197;
pub const Cmd_GetMonitorLoaderState: M_Cmd = 198;
pub const Cmd_LoadMonitor: M_Cmd = 199;
pub const Cmd_ClearUnitEx: M_Cmd = 200;
pub const Cmd_VerifyCertificate: M_Cmd = 201;
pub const Cmd_DynamicSlotExchangeAPDUs: M_Cmd = 202;
pub const Cmd_StartUpdateWorld: M_Cmd = 204;
pub const Cmd_CheckWorld: M_Cmd = 205;
pub const Cmd_ReportWorldState: M_Cmd = 206;
pub const Cmd_DynamicSlotsConfigure: M_Cmd = 208;
pub const Cmd_ANSlotsConfigurationChangeEvent: M_Cmd = 209;
pub const Cmd_DynamicSlotCreateAssociation: M_Cmd = 210;
pub const Cmd_GetHardwareError: M_Cmd = 211;
pub const Cmd_DynamicSlotsConfigureQuery: M_Cmd = 212;
pub const Cmd_SetPrimarySlot: M_Cmd = 213;
pub const Cmd_ANLogEvent: M_Cmd = 214;
pub const Cmd_GetApplianceVersion: M_Cmd = 215;
pub const Cmd_RemoteReboot: M_Cmd = 216;
pub const Cmd_UpgradeApplianceFirmware: M_Cmd = 217;
pub const Cmd_SetApplianceUpgradeStatus: M_Cmd = 218;
pub const Cmd_GetApplianceUpgradeStatus: M_Cmd = 219;
pub const Cmd_FailDriver: M_Cmd = 223;
pub const Cmd_ConfigurePoolModule: M_Cmd = 224;
pub const Cmd_GetPoolInfo: M_Cmd = 226;
pub const Cmd_ApplyFeatureFile: M_Cmd = 231;
pub const Cmd_SendKey: M_Cmd = 232;
pub const Cmd_ReceiveKey: M_Cmd = 233;
pub const Cmd_ANSendAuditLogEvent: M_Cmd = 234;
pub const Cmd_EraseWorld: M_Cmd = 235;
pub const Cmd_GetApplianceTime: M_Cmd = 236;
pub const Cmd_SetApplianceTime: M_Cmd = 237;
pub const Cmd_GetKLF2: M_Cmd = 238;
pub const Cmd_ChangeShareGroupPIN: M_Cmd = 239;
pub const Cmd_HotReset: M_Cmd = 240;
pub const Cmd_DevTest: M_Cmd = 241;
pub const Cmd_ListRemoteServerPermissionEx: M_Cmd = 242;
pub const Cmd__Max: M_Cmd = 243;
pub type M_Cmd = ::core::ffi::c_uint;
pub const ModuleMode_Default: M_ModuleMode = 0;
pub const ModuleMode_Maintenance: M_ModuleMode = 1;
pub const ModuleMode_Operational: M_ModuleMode = 2;
pub const ModuleMode_Initialisation: M_ModuleMode = 3;
pub const ModuleMode__Max: M_ModuleMode = 4;
pub type M_ModuleMode = ::core::ffi::c_uint;
pub const CreateClientVer_Zero: M_CreateClientVer = 0;
pub const CreateClientVer_One: M_CreateClientVer = 1;
pub const CreateClientVer__Max: M_CreateClientVer = 2;
pub type M_CreateClientVer = ::core::ffi::c_uint;
pub const DevTestOp_GetFastRaw: M_DevTestOp = 0;
pub const DevTestOp_GetSlowRaw: M_DevTestOp = 1;
pub const DevTestOp__Max: M_DevTestOp = 2;
pub type M_DevTestOp = ::core::ffi::c_uint;
pub const NVMemOpType_Read: M_NVMemOpType = 1;
pub const NVMemOpType_Write: M_NVMemOpType = 2;
pub const NVMemOpType_Incr: M_NVMemOpType = 3;
pub const NVMemOpType_Decr: M_NVMemOpType = 4;
pub const NVMemOpType_BitSet: M_NVMemOpType = 5;
pub const NVMemOpType_BitClear: M_NVMemOpType = 6;
pub const NVMemOpType_Free: M_NVMemOpType = 7;
pub const NVMemOpType_IncrRead: M_NVMemOpType = 8;
pub const NVMemOpType_DecrRead: M_NVMemOpType = 9;
pub const NVMemOpType_BitSetRead: M_NVMemOpType = 10;
pub const NVMemOpType_BitClearRead: M_NVMemOpType = 11;
pub const NVMemOpType_GetACL: M_NVMemOpType = 12;
pub const NVMemOpType_Resize: M_NVMemOpType = 13;
pub const NVMemOpType__Max: M_NVMemOpType = 14;
pub type M_NVMemOpType = ::core::ffi::c_uint;
pub const FwAuthType_NFFHMAC1: M_FwAuthType = 1;
pub const FwAuthType_PRNG1: M_FwAuthType = 2;
pub const FwAuthType__Max: M_FwAuthType = 3;
pub type M_FwAuthType = ::core::ffi::c_uint;
pub const PhysTokenType_Invalid: M_PhysTokenType = 0;
pub const PhysTokenType_ISO7816: M_PhysTokenType = 1;
pub const PhysTokenType__Max: M_PhysTokenType = 2;
pub type M_PhysTokenType = ::core::ffi::c_uint;
pub const PoolInfo_StoreInfo: M_PoolInfo = 1;
pub const PoolInfo_ClientInfo: M_PoolInfo = 2;
pub const PoolInfo_ModuleInfo: M_PoolInfo = 3;
pub const PoolInfo_KeyInfo: M_PoolInfo = 4;
pub const PoolInfo__Max: M_PoolInfo = 5;
pub type M_PoolInfo = ::core::ffi::c_uint;
pub const TicketDestination_Any: M_TicketDestination = 0;
pub const TicketDestination_AnyClient: M_TicketDestination = 1;
pub const TicketDestination_NamedClient: M_TicketDestination = 2;
pub const TicketDestination_AnySEEWorld: M_TicketDestination = 3;
pub const TicketDestination_NamedSEEWorld: M_TicketDestination = 4;
pub const TicketDestination_AnyKernelClient: M_TicketDestination = 5;
pub const TicketDestination__Max: M_TicketDestination = 6;
pub type M_TicketDestination = ::core::ffi::c_uint;
pub const KMLType_DSAp1024s160: M_KMLType = 0;
pub const KMLType_DSAp3072s256: M_KMLType = 1;
pub const KMLType__Max: M_KMLType = 2;
pub type M_KMLType = ::core::ffi::c_uint;
pub const UpgradeState_Invalid: M_UpgradeState = 0;
pub const UpgradeState_Initiated: M_UpgradeState = 1;
pub const UpgradeState_Transferred: M_UpgradeState = 2;
pub const UpgradeState_Verified: M_UpgradeState = 3;
pub const UpgradeState_Upgraded: M_UpgradeState = 4;
pub const UpgradeState__Max: M_UpgradeState = 5;
pub type M_UpgradeState = ::core::ffi::c_uint;
pub const SignerType_KLF: M_SignerType = 1;
pub const SignerType_KML: M_SignerType = 2;
pub const SignerType_AppKey: M_SignerType = 3;
pub const SignerType_KLF2: M_SignerType = 4;
pub const SignerType__Max: M_SignerType = 5;
pub type M_SignerType = ::core::ffi::c_uint;
pub const CertificateKind_ModuleIdentification: M_CertificateKind = 1;
pub const CertificateKind__Max: M_CertificateKind = 2;
pub type M_CertificateKind = ::core::ffi::c_uint;
pub const StackOp_NoOp: M_StackOp = 0;
pub const StackOp_Add: M_StackOp = 1;
pub const StackOp_Sub: M_StackOp = 2;
pub const StackOp_RSub: M_StackOp = 3;
pub const StackOp_Mul: M_StackOp = 4;
pub const StackOp_Div: M_StackOp = 5;
pub const StackOp_Mod: M_StackOp = 6;
pub const StackOp_DivMod: M_StackOp = 7;
pub const StackOp_ModExp: M_StackOp = 8;
pub const StackOp_ModInv: M_StackOp = 9;
pub const StackOp_Dup: M_StackOp = 10;
pub const StackOp_Drop: M_StackOp = 11;
pub const StackOp_Rot: M_StackOp = 12;
pub const StackOp_Set: M_StackOp = 13;
pub const StackOp_Test: M_StackOp = 14;
pub const StackOp_TestPrime: M_StackOp = 15;
pub const StackOp_Neg: M_StackOp = 16;
pub const StackOp_Abs: M_StackOp = 17;
pub const StackOp_GCD: M_StackOp = 18;
pub const StackOp_LCM: M_StackOp = 19;
pub const StackOp__Max: M_StackOp = 20;
pub type M_StackOp = ::core::ffi::c_uint;
pub const ImpathWarrantType_KLF2: M_ImpathWarrantType = 1;
pub const ImpathWarrantType__Max: M_ImpathWarrantType = 2;
pub type M_ImpathWarrantType = ::core::ffi::c_uint;
pub const UseLim_Global: M_UseLim = 1;
pub const UseLim_AuthOld: M_UseLim = 2;
pub const UseLim_Time: M_UseLim = 3;
pub const UseLim_NonVolatile: M_UseLim = 4;
pub const UseLim_Auth: M_UseLim = 6;
pub const UseLim__Max: M_UseLim = 7;
pub type M_UseLim = ::core::ffi::c_uint;
pub const Act_NoAction: M_Act = 0;
pub const Act_OpPermissions: M_Act = 1;
pub const Act_MakeBlob: M_Act = 2;
pub const Act_MakeArchiveBlob: M_Act = 3;
pub const Act_NSOPermissions: M_Act = 4;
pub const Act_DeriveKey: M_Act = 5;
pub const Act_NVMemOpPerms: M_Act = 6;
pub const Act_FeatureEnable: M_Act = 7;
pub const Act_NVMemUseLimit: M_Act = 8;
pub const Act_SendShare: M_Act = 9;
pub const Act_ReadShare: M_Act = 10;
pub const Act_StaticFeatureEnable: M_Act = 11;
pub const Act_UserAction: M_Act = 12;
pub const Act_FileCopy: M_Act = 15;
pub const Act_DeriveKeyEx: M_Act = 47;
pub const Act_SendKey: M_Act = 48;
pub const Act__Max: M_Act = 49;
pub type M_Act = ::core::ffi::c_uint;
pub const DeriveRole_TemplateKey: M_DeriveRole = 0;
pub const DeriveRole_BaseKey: M_DeriveRole = 1;
pub const DeriveRole_WrapKey: M_DeriveRole = 2;
pub const DeriveRole_Key3: M_DeriveRole = 3;
pub const DeriveRole_Key4: M_DeriveRole = 4;
pub const DeriveRole_Key5: M_DeriveRole = 5;
pub const DeriveRole__Max: M_DeriveRole = 6;
pub type M_DeriveRole = ::core::ffi::c_uint;
pub const EnqVer_Zero: M_EnqVer = 0;
pub const EnqVer_One: M_EnqVer = 1;
pub const EnqVer_Two: M_EnqVer = 2;
pub const EnqVer_Three: M_EnqVer = 3;
pub const EnqVer_Four: M_EnqVer = 4;
pub const EnqVer_Five: M_EnqVer = 5;
pub const EnqVer_Six: M_EnqVer = 6;
pub const EnqVer__Max: M_EnqVer = 7;
pub type M_EnqVer = ::core::ffi::c_uint;
pub const LogTokenState_Present: M_LogTokenState = 1;
pub const LogTokenState_Reading: M_LogTokenState = 2;
pub const LogTokenState_Writing: M_LogTokenState = 3;
pub const LogTokenState_TokenAssemblyFailed: M_LogTokenState = 5;
pub const LogTokenState_PhysTokenNotPresent: M_LogTokenState = 6;
pub const LogTokenState_TimeLimitExceeded: M_LogTokenState = 7;
pub const LogTokenState__Max: M_LogTokenState = 8;
pub type M_LogTokenState = ::core::ffi::c_uint;
pub const MonitorLoaderState_Ready: M_MonitorLoaderState = 1;
pub const MonitorLoaderState_Finished: M_MonitorLoaderState = 2;
pub const MonitorLoaderState_AlreadyLoaded: M_MonitorLoaderState = 3;
pub const MonitorLoaderState__Max: M_MonitorLoaderState = 4;
pub type M_MonitorLoaderState = ::core::ffi::c_uint;
pub const ImpathState_Exchange: M_ImpathState = 1;
pub const ImpathState_UpAndRunning: M_ImpathState = 2;
pub const ImpathState_Expired: M_ImpathState = 3;
pub const ImpathState__Max: M_ImpathState = 4;
pub type M_ImpathState = ::core::ffi::c_uint;
pub const InfoFormat_HardwareRev1: M_InfoFormat = 1;
pub const InfoFormat_HardwareRev2: M_InfoFormat = 2;
pub const InfoFormat__Max: M_InfoFormat = 3;
pub type M_InfoFormat = ::core::ffi::c_uint;
pub const LogTokenShareState_OK: M_LogTokenShareState = 1;
pub const LogTokenShareState_NotYetWritten: M_LogTokenShareState = 2;
pub const LogTokenShareState_NotYetRead: M_LogTokenShareState = 3;
pub const LogTokenShareState__Max: M_LogTokenShareState = 4;
pub type M_LogTokenShareState = ::core::ffi::c_uint;
pub const BusType_SCSI: M_BusType = 0;
pub const BusType_PCI: M_BusType = 1;
pub const BusType_USB: M_BusType = 2;
pub const BusType_Local: M_BusType = 3;
pub const BusType_Serial: M_BusType = 4;
pub const BusType_I2C: M_BusType = 5;
pub const BusType_OneWire: M_BusType = 6;
pub const BusType_XBus: M_BusType = 7;
pub const BusType_PS2: M_BusType = 8;
pub const BusType__Max: M_BusType = 9;
pub type M_BusType = ::core::ffi::c_uint;
pub const StatID_Uptime: M_StatID = 1;
pub const StatID_CmdCount: M_StatID = 2;
pub const StatID_ReplyCount: M_StatID = 3;
pub const StatID_CmdBytes: M_StatID = 4;
pub const StatID_ReplyBytes: M_StatID = 5;
pub const StatID_CmdMarshalErrors: M_StatID = 6;
pub const StatID_ReplyMarshalErrors: M_StatID = 7;
pub const StatID_HostWriteCount: M_StatID = 8;
pub const StatID_HostWriteErrors: M_StatID = 9;
pub const StatID_HostWriteOverruns: M_StatID = 10;
pub const StatID_HostWriteNoMemory: M_StatID = 11;
pub const StatID_HostReadCount: M_StatID = 12;
pub const StatID_HostReadErrors: M_StatID = 13;
pub const StatID_HostReadEmpty: M_StatID = 14;
pub const StatID_HostReadUnderruns: M_StatID = 15;
pub const StatID_HostReadDeferred: M_StatID = 16;
pub const StatID_HostReadTerminated: M_StatID = 17;
pub const StatID_PFNIssued: M_StatID = 19;
pub const StatID_PFNRejected: M_StatID = 20;
pub const StatID_PFNCompleted: M_StatID = 21;
pub const StatID_ANIssued: M_StatID = 22;
pub const StatID_ChanJobsIssued: M_StatID = 23;
pub const StatID_ChanJobsCompleted: M_StatID = 24;
pub const StatID_CPULoadPercent: M_StatID = 25;
pub const StatID_HostIRQs: M_StatID = 26;
pub const StatID_ChanJobErrors: M_StatID = 27;
pub const StatID_HostDebugIRQs: M_StatID = 28;
pub const StatID_HostUnhandledIRQs: M_StatID = 29;
pub const StatID_HostReadReconnect: M_StatID = 30;
pub const StatID_SCSIConnections: M_StatID = 31;
pub const StatID_SCSICommands: M_StatID = 32;
pub const StatID_SCSIInquiries: M_StatID = 33;
pub const StatID_SCSIDisconnects: M_StatID = 34;
pub const StatID_SCSIReconnects: M_StatID = 35;
pub const StatID_SCSILUN0Use: M_StatID = 36;
pub const StatID_SCSILUN1Use: M_StatID = 37;
pub const StatID_SCSICmdErrors: M_StatID = 38;
pub const StatID_SCSIBusResets: M_StatID = 39;
pub const StatID_SCSICtrlErrors: M_StatID = 40;
pub const StatID_SCSITagQUse: M_StatID = 41;
pub const StatID_SCSIReconFailures: M_StatID = 42;
pub const StatID_HostWriteBadData: M_StatID = 43;
pub const StatID_ClientCount: M_StatID = 44;
pub const StatID_MaxClients: M_StatID = 45;
pub const StatID_QOutstanding: M_StatID = 46;
pub const StatID_DeviceFails: M_StatID = 47;
pub const StatID_DeviceRestarts: M_StatID = 48;
pub const StatID_DevOutstanding: M_StatID = 49;
pub const StatID_ObjectsCreated: M_StatID = 50;
pub const StatID_ObjectsDestroyed: M_StatID = 51;
pub const StatID_ObjectCount: M_StatID = 52;
pub const StatID_SCSIWideNeg: M_StatID = 53;
pub const StatID_SCSISyncNeg: M_StatID = 54;
pub const StatID_CurrentTempC: M_StatID = 55;
pub const StatID_MaxTempC: M_StatID = 56;
pub const StatID_MinTempC: M_StatID = 57;
pub const StatID_MemTotal: M_StatID = 58;
pub const StatID_MemAllocKernel: M_StatID = 59;
pub const StatID_MemAllocUser: M_StatID = 60;
pub const StatID_CurrentTemp2C: M_StatID = 61;
pub const StatID_MaxTemp2C: M_StatID = 62;
pub const StatID_MinTemp2C: M_StatID = 63;
pub const StatID_VoltageOn5VSupply: M_StatID = 64;
pub const StatID_VoltageOn12VSupply: M_StatID = 65;
pub const StatID_CurrentFanRPM: M_StatID = 66;
pub const StatID_CurrentFan2RPM: M_StatID = 67;
pub const StatID_CurrentFan3RPM: M_StatID = 68;
pub const StatID_CurrentFan4RPM: M_StatID = 69;
pub const StatID_CurrentFan5RPM: M_StatID = 70;
pub const StatID_CurrentFan6RPM: M_StatID = 71;
pub const StatID_HostKernReadCount: M_StatID = 72;
pub const StatID_HostKernReadDeferred: M_StatID = 73;
pub const StatID_HostKernReadReconnect: M_StatID = 74;
pub const StatID_HostKernReadErrors: M_StatID = 75;
pub const StatID_HostKernWriteCount: M_StatID = 76;
pub const StatID_HostKernWriteErrors: M_StatID = 77;
pub const StatID_HostReadPushedDMA: M_StatID = 78;
pub const StatID_HostReadPushedPIO: M_StatID = 79;
pub const StatID_HostKernReadPushedDMA: M_StatID = 80;
pub const StatID_HostKernReadPushedPIO: M_StatID = 81;
pub const StatID_RemoteIPAddr: M_StatID = 82;
pub const StatID_LongOutstanding: M_StatID = 83;
pub const StatID_CmdFragments: M_StatID = 84;
pub const StatID_ReplyFragments: M_StatID = 85;
pub const StatID_DriverIRQs: M_StatID = 86;
pub const StatID_DriverReadIRQs: M_StatID = 87;
pub const StatID_DriverWriteIRQs: M_StatID = 88;
pub const StatID_DriverWriteFails: M_StatID = 89;
pub const StatID_DriverWriteBlocks: M_StatID = 90;
pub const StatID_DriverWriteBytes: M_StatID = 91;
pub const StatID_DriverReadFails: M_StatID = 92;
pub const StatID_DriverReadBlocks: M_StatID = 93;
pub const StatID_DriverReadBytes: M_StatID = 94;
pub const StatID_DriverEnsureFail: M_StatID = 95;
pub const StatID_DriverEnsure: M_StatID = 96;
pub const StatID_JobsOutstanding: M_StatID = 97;
pub const StatID_LongJobsOutstanding: M_StatID = 98;
pub const StatID_VoltageOn3p3VSupply: M_StatID = 99;
pub const StatID_CurrentOn3p3VSupply: M_StatID = 100;
pub const StatID_TamperBattery1: M_StatID = 101;
pub const StatID_CurrentOn5VSupply: M_StatID = 102;
pub const StatID_TamperBattery2: M_StatID = 103;
pub const StatID_CurrentOn12VSupply: M_StatID = 104;
pub const StatID_VoltageOn5VSBSupply: M_StatID = 105;
pub const StatID_CurrentOn5VSBSupply: M_StatID = 106;
pub const StatID_PSUFailure: M_StatID = 107;
pub const StatID_ClientProcessID: M_StatID = 108;
pub const StatID_ClientProcessName: M_StatID = 109;
pub const StatID_ClientNumber: M_StatID = 110;
pub const StatID_ObjectCountTotal: M_StatID = 111;
pub const StatID_TempSP: M_StatID = 112;
pub const StatID_CurrentCPUTemp1: M_StatID = 113;
pub const StatID_CurrentCPUTemp2: M_StatID = 114;
pub const StatID_CurrentFanSpeed: M_StatID = 115;
pub const StatID_CurrentFanDuty: M_StatID = 116;
pub const StatID_CPUVoltage1: M_StatID = 117;
pub const StatID_CPUVoltage2: M_StatID = 118;
pub const StatID_CPUVoltage3: M_StatID = 119;
pub const StatID_CPUVoltage4: M_StatID = 120;
pub const StatID_CPUVoltage5: M_StatID = 121;
pub const StatID_CPUVoltage6: M_StatID = 122;
pub const StatID_CPUVoltage7: M_StatID = 123;
pub const StatID_CPUVoltage8: M_StatID = 124;
pub const StatID_CPUVoltage9: M_StatID = 125;
pub const StatID_CPUVoltage10: M_StatID = 127;
pub const StatID_CPUVoltage11: M_StatID = 128;
pub const StatID_CacheEntryCount: M_StatID = 129;
pub const StatID_CacheEntriesInserted: M_StatID = 130;
pub const StatID_CacheEntriesRemoved: M_StatID = 131;
pub const StatID_AIS31PrelimAlarms: M_StatID = 132;
pub const StatID_MceCount: M_StatID = 133;
pub const StatID_SpiRetries: M_StatID = 134;
pub const StatID_SpI2c1: M_StatID = 135;
pub const StatID_SpI2c2: M_StatID = 136;
pub const StatID_SpTempExcursion: M_StatID = 137;
pub const StatID_SpVoltageExcursion: M_StatID = 138;
pub const StatID_HostBusExceptions: M_StatID = 139;
pub const StatID_CryptoBusExceptions: M_StatID = 140;
pub const StatID_SerialNumber: M_StatID = 141;
pub const StatID_CurrentTime: M_StatID = 142;
pub const StatID_XCSpLogEventID: M_StatID = 143;
pub const StatID_XCSpLogEventDate: M_StatID = 144;
pub const StatID_SpSensorCmdFails: M_StatID = 145;
pub const StatID_JobsStarted: M_StatID = 146;
pub const StatID_JobsComplete: M_StatID = 147;
pub const StatID_RepliesQueued: M_StatID = 148;
pub const StatID_ReservedMax: M_StatID = 1000;
pub const StatID__Max: M_StatID = 1001;
pub type M_StatID = ::core::ffi::c_uint;
pub const SEEInitStatus_OK: M_SEEInitStatus = 0;
pub const SEEInitStatus_MachineFailed: M_SEEInitStatus = 1;
pub const SEEInitStatus__Max: M_SEEInitStatus = 2;
pub type M_SEEInitStatus = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_Hash {
    pub bytes: [::core::ffi::c_uchar; 20usize],
    pub words: [M_Word; 5usize],
}
#[test]
fn bindgen_test_layout_M_Hash() {
    const UNINIT: ::core::mem::MaybeUninit<M_Hash> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Hash>(),
        20usize,
        concat!("Size of: ", stringify!(M_Hash))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Hash>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Hash))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Hash),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).words) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Hash),
            "::",
            stringify!(words)
        )
    );
}
impl Default for M_Hash {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Hash {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Hash {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_Hash28 {
    pub bytes: [::core::ffi::c_uchar; 28usize],
    pub words: [M_Word; 7usize],
}
#[test]
fn bindgen_test_layout_M_Hash28() {
    const UNINIT: ::core::mem::MaybeUninit<M_Hash28> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Hash28>(),
        28usize,
        concat!("Size of: ", stringify!(M_Hash28))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Hash28>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Hash28))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Hash28),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).words) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Hash28),
            "::",
            stringify!(words)
        )
    );
}
impl Default for M_Hash28 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Hash28 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Hash28 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_Hash32 {
    pub bytes: [::core::ffi::c_uchar; 32usize],
    pub words: [M_Word; 8usize],
}
#[test]
fn bindgen_test_layout_M_Hash32() {
    const UNINIT: ::core::mem::MaybeUninit<M_Hash32> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Hash32>(),
        32usize,
        concat!("Size of: ", stringify!(M_Hash32))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Hash32>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Hash32))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Hash32),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).words) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Hash32),
            "::",
            stringify!(words)
        )
    );
}
impl Default for M_Hash32 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Hash32 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Hash32 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_Hash48 {
    pub bytes: [::core::ffi::c_uchar; 48usize],
    pub words: [M_Word; 12usize],
}
#[test]
fn bindgen_test_layout_M_Hash48() {
    const UNINIT: ::core::mem::MaybeUninit<M_Hash48> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Hash48>(),
        48usize,
        concat!("Size of: ", stringify!(M_Hash48))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Hash48>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Hash48))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Hash48),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).words) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Hash48),
            "::",
            stringify!(words)
        )
    );
}
impl Default for M_Hash48 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Hash48 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Hash48 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_Hash64 {
    pub bytes: [::core::ffi::c_uchar; 64usize],
    pub words: [M_Word; 16usize],
}
#[test]
fn bindgen_test_layout_M_Hash64() {
    const UNINIT: ::core::mem::MaybeUninit<M_Hash64> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Hash64>(),
        64usize,
        concat!("Size of: ", stringify!(M_Hash64))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Hash64>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Hash64))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Hash64),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).words) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Hash64),
            "::",
            stringify!(words)
        )
    );
}
impl Default for M_Hash64 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Hash64 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Hash64 {{ union }}")
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Status_AttemptedDowngrade_ErrorInfo {
    pub oldvsn: M_Word,
    pub newvsn: M_Word,
}
#[test]
fn bindgen_test_layout_M_Status_AttemptedDowngrade_ErrorInfo() {
    const UNINIT: ::core::mem::MaybeUninit<M_Status_AttemptedDowngrade_ErrorInfo> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Status_AttemptedDowngrade_ErrorInfo>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(M_Status_AttemptedDowngrade_ErrorInfo)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<M_Status_AttemptedDowngrade_ErrorInfo>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(M_Status_AttemptedDowngrade_ErrorInfo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).oldvsn) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Status_AttemptedDowngrade_ErrorInfo),
            "::",
            stringify!(oldvsn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).newvsn) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Status_AttemptedDowngrade_ErrorInfo),
            "::",
            stringify!(newvsn)
        )
    );
}
pub type M_vec_CrossModuleReason = *mut M_CrossModuleReason;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Status_CrossModule_ErrorInfo {
    pub n_reasons: ::core::ffi::c_int,
    pub reasons: M_vec_CrossModuleReason,
}
#[test]
fn bindgen_test_layout_M_Status_CrossModule_ErrorInfo() {
    const UNINIT: ::core::mem::MaybeUninit<M_Status_CrossModule_ErrorInfo> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Status_CrossModule_ErrorInfo>(),
        16usize,
        concat!("Size of: ", stringify!(M_Status_CrossModule_ErrorInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Status_CrossModule_ErrorInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Status_CrossModule_ErrorInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_reasons) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Status_CrossModule_ErrorInfo),
            "::",
            stringify!(n_reasons)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reasons) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Status_CrossModule_ErrorInfo),
            "::",
            stringify!(reasons)
        )
    );
}
impl Default for M_Status_CrossModule_ErrorInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Status_RemoteServerFailed_ErrorInfo_flags = M_Word;
pub type M_opt_StatusErrorInfo = *mut M_StatusErrorInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Status_RemoteServerFailed_ErrorInfo {
    pub flags: M_Status_RemoteServerFailed_ErrorInfo_flags,
    pub stinfo: M_opt_StatusErrorInfo,
    pub addr: *mut M_NetworkAddress,
}
#[test]
fn bindgen_test_layout_M_Status_RemoteServerFailed_ErrorInfo() {
    const UNINIT: ::core::mem::MaybeUninit<M_Status_RemoteServerFailed_ErrorInfo> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Status_RemoteServerFailed_ErrorInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(M_Status_RemoteServerFailed_ErrorInfo)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<M_Status_RemoteServerFailed_ErrorInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(M_Status_RemoteServerFailed_ErrorInfo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Status_RemoteServerFailed_ErrorInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stinfo) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Status_RemoteServerFailed_ErrorInfo),
            "::",
            stringify!(stinfo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).addr) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Status_RemoteServerFailed_ErrorInfo),
            "::",
            stringify!(addr)
        )
    );
}
impl Default for M_Status_RemoteServerFailed_ErrorInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Status_SlotUnconnected_ErrorInfo {
    pub stinfo: M_opt_StatusErrorInfo,
}
#[test]
fn bindgen_test_layout_M_Status_SlotUnconnected_ErrorInfo() {
    const UNINIT: ::core::mem::MaybeUninit<M_Status_SlotUnconnected_ErrorInfo> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Status_SlotUnconnected_ErrorInfo>(),
        8usize,
        concat!("Size of: ", stringify!(M_Status_SlotUnconnected_ErrorInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Status_SlotUnconnected_ErrorInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(M_Status_SlotUnconnected_ErrorInfo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stinfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Status_SlotUnconnected_ErrorInfo),
            "::",
            stringify!(stinfo)
        )
    );
}
impl Default for M_Status_SlotUnconnected_ErrorInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Status_TokenTransactionCorrupted_ErrorInfo {
    pub tokenstatus: M_Status,
}
#[test]
fn bindgen_test_layout_M_Status_TokenTransactionCorrupted_ErrorInfo() {
    const UNINIT: ::core::mem::MaybeUninit<M_Status_TokenTransactionCorrupted_ErrorInfo> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Status_TokenTransactionCorrupted_ErrorInfo>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(M_Status_TokenTransactionCorrupted_ErrorInfo)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<M_Status_TokenTransactionCorrupted_ErrorInfo>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(M_Status_TokenTransactionCorrupted_ErrorInfo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tokenstatus) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Status_TokenTransactionCorrupted_ErrorInfo),
            "::",
            stringify!(tokenstatus)
        )
    );
}
impl Default for M_Status_TokenTransactionCorrupted_ErrorInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Status_TokenTransactionRolledBack_ErrorInfo {
    pub tokenstatus: M_Status,
}
#[test]
fn bindgen_test_layout_M_Status_TokenTransactionRolledBack_ErrorInfo() {
    const UNINIT: ::core::mem::MaybeUninit<M_Status_TokenTransactionRolledBack_ErrorInfo> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Status_TokenTransactionRolledBack_ErrorInfo>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(M_Status_TokenTransactionRolledBack_ErrorInfo)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<M_Status_TokenTransactionRolledBack_ErrorInfo>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(M_Status_TokenTransactionRolledBack_ErrorInfo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tokenstatus) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Status_TokenTransactionRolledBack_ErrorInfo),
            "::",
            stringify!(tokenstatus)
        )
    );
}
impl Default for M_Status_TokenTransactionRolledBack_ErrorInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Status_UnknownKPSName_ErrorInfo {
    pub knownkps: M_ASCIIString,
}
#[test]
fn bindgen_test_layout_M_Status_UnknownKPSName_ErrorInfo() {
    const UNINIT: ::core::mem::MaybeUninit<M_Status_UnknownKPSName_ErrorInfo> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Status_UnknownKPSName_ErrorInfo>(),
        8usize,
        concat!("Size of: ", stringify!(M_Status_UnknownKPSName_ErrorInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Status_UnknownKPSName_ErrorInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(M_Status_UnknownKPSName_ErrorInfo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).knownkps) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Status_UnknownKPSName_ErrorInfo),
            "::",
            stringify!(knownkps)
        )
    );
}
impl Default for M_Status_UnknownKPSName_ErrorInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_KeyHash = M_Hash;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Status_UnknownKeyHash_ErrorInfo {
    pub hk: M_KeyHash,
}
#[test]
fn bindgen_test_layout_M_Status_UnknownKeyHash_ErrorInfo() {
    const UNINIT: ::core::mem::MaybeUninit<M_Status_UnknownKeyHash_ErrorInfo> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Status_UnknownKeyHash_ErrorInfo>(),
        20usize,
        concat!("Size of: ", stringify!(M_Status_UnknownKeyHash_ErrorInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Status_UnknownKeyHash_ErrorInfo>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(M_Status_UnknownKeyHash_ErrorInfo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hk) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Status_UnknownKeyHash_ErrorInfo),
            "::",
            stringify!(hk)
        )
    );
}
impl Default for M_Status_UnknownKeyHash_ErrorInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Status_UnknownKeyHash_ErrorInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Status_UnknownKeyHash_ErrorInfo {{ hk: {:?} }}",
            self.hk
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Status_nCErrno_ErrorInfo {
    pub err: M_nCErrno,
    pub strerr: M_ASCIIString,
}
#[test]
fn bindgen_test_layout_M_Status_nCErrno_ErrorInfo() {
    const UNINIT: ::core::mem::MaybeUninit<M_Status_nCErrno_ErrorInfo> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Status_nCErrno_ErrorInfo>(),
        16usize,
        concat!("Size of: ", stringify!(M_Status_nCErrno_ErrorInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Status_nCErrno_ErrorInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Status_nCErrno_ErrorInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).err) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Status_nCErrno_ErrorInfo),
            "::",
            stringify!(err)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).strerr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Status_nCErrno_ErrorInfo),
            "::",
            stringify!(strerr)
        )
    );
}
impl Default for M_Status_nCErrno_ErrorInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_Status__ErrorInfo {
    pub attempteddowngrade: M_Status_AttemptedDowngrade_ErrorInfo,
    pub crossmodule: M_Status_CrossModule_ErrorInfo,
    pub remoteserverfailed: M_Status_RemoteServerFailed_ErrorInfo,
    pub slotunconnected: M_Status_SlotUnconnected_ErrorInfo,
    pub tokentransactioncorrupted: M_Status_TokenTransactionCorrupted_ErrorInfo,
    pub tokentransactionrolledback: M_Status_TokenTransactionRolledBack_ErrorInfo,
    pub unknownkpsname: M_Status_UnknownKPSName_ErrorInfo,
    pub unknownkeyhash: M_Status_UnknownKeyHash_ErrorInfo,
    pub ncerrno: M_Status_nCErrno_ErrorInfo,
}
#[test]
fn bindgen_test_layout_M_Status__ErrorInfo() {
    const UNINIT: ::core::mem::MaybeUninit<M_Status__ErrorInfo> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Status__ErrorInfo>(),
        24usize,
        concat!("Size of: ", stringify!(M_Status__ErrorInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Status__ErrorInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Status__ErrorInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).attempteddowngrade) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Status__ErrorInfo),
            "::",
            stringify!(attempteddowngrade)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).crossmodule) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Status__ErrorInfo),
            "::",
            stringify!(crossmodule)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).remoteserverfailed) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Status__ErrorInfo),
            "::",
            stringify!(remoteserverfailed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).slotunconnected) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Status__ErrorInfo),
            "::",
            stringify!(slotunconnected)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tokentransactioncorrupted) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Status__ErrorInfo),
            "::",
            stringify!(tokentransactioncorrupted)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tokentransactionrolledback) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Status__ErrorInfo),
            "::",
            stringify!(tokentransactionrolledback)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unknownkpsname) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Status__ErrorInfo),
            "::",
            stringify!(unknownkpsname)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unknownkeyhash) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Status__ErrorInfo),
            "::",
            stringify!(unknownkeyhash)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ncerrno) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Status__ErrorInfo),
            "::",
            stringify!(ncerrno)
        )
    );
}
impl Default for M_Status__ErrorInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Status__ErrorInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Status__ErrorInfo {{ union }}")
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_CrossModReason_Key_Info {
    pub key: M_KeyID,
}
#[test]
fn bindgen_test_layout_M_CrossModReason_Key_Info() {
    const UNINIT: ::core::mem::MaybeUninit<M_CrossModReason_Key_Info> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_CrossModReason_Key_Info>(),
        4usize,
        concat!("Size of: ", stringify!(M_CrossModReason_Key_Info))
    );
    assert_eq!(
        ::core::mem::align_of::<M_CrossModReason_Key_Info>(),
        4usize,
        concat!("Alignment of ", stringify!(M_CrossModReason_Key_Info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_CrossModReason_Key_Info),
            "::",
            stringify!(key)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_CrossModReason__Info {
    pub key: M_CrossModReason_Key_Info,
}
#[test]
fn bindgen_test_layout_M_CrossModReason__Info() {
    const UNINIT: ::core::mem::MaybeUninit<M_CrossModReason__Info> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_CrossModReason__Info>(),
        4usize,
        concat!("Size of: ", stringify!(M_CrossModReason__Info))
    );
    assert_eq!(
        ::core::mem::align_of::<M_CrossModReason__Info>(),
        4usize,
        concat!("Alignment of ", stringify!(M_CrossModReason__Info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_CrossModReason__Info),
            "::",
            stringify!(key)
        )
    );
}
impl Default for M_CrossModReason__Info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_CrossModReason__Info {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_CrossModReason__Info {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_CrossModuleReason {
    pub type_: M_CrossModReason,
    pub info: M_CrossModReason__Info,
}
#[test]
fn bindgen_test_layout_M_CrossModuleReason() {
    const UNINIT: ::core::mem::MaybeUninit<M_CrossModuleReason> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_CrossModuleReason>(),
        8usize,
        concat!("Size of: ", stringify!(M_CrossModuleReason))
    );
    assert_eq!(
        ::core::mem::align_of::<M_CrossModuleReason>(),
        4usize,
        concat!("Alignment of ", stringify!(M_CrossModuleReason))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_CrossModuleReason),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_CrossModuleReason),
            "::",
            stringify!(info)
        )
    );
}
impl Default for M_CrossModuleReason {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_CrossModuleReason {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_CrossModuleReason {{ type: {:?}, info: {:?} }}",
            self.type_, self.info
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_StatusErrorInfo {
    pub st: M_Status,
    pub einfo: M_Status__ErrorInfo,
}
#[test]
fn bindgen_test_layout_M_StatusErrorInfo() {
    const UNINIT: ::core::mem::MaybeUninit<M_StatusErrorInfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_StatusErrorInfo>(),
        32usize,
        concat!("Size of: ", stringify!(M_StatusErrorInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<M_StatusErrorInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(M_StatusErrorInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).st) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_StatusErrorInfo),
            "::",
            stringify!(st)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).einfo) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_StatusErrorInfo),
            "::",
            stringify!(einfo)
        )
    );
}
impl Default for M_StatusErrorInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_StatusErrorInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_StatusErrorInfo {{ st: {:?}, einfo: {:?} }}",
            self.st, self.einfo
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_NetworkAddressFamily_HOST_Value {
    pub addr: M_ASCIIString,
    pub port: M_Word,
}
#[test]
fn bindgen_test_layout_M_NetworkAddressFamily_HOST_Value() {
    const UNINIT: ::core::mem::MaybeUninit<M_NetworkAddressFamily_HOST_Value> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_NetworkAddressFamily_HOST_Value>(),
        16usize,
        concat!("Size of: ", stringify!(M_NetworkAddressFamily_HOST_Value))
    );
    assert_eq!(
        ::core::mem::align_of::<M_NetworkAddressFamily_HOST_Value>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(M_NetworkAddressFamily_HOST_Value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_NetworkAddressFamily_HOST_Value),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).port) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_NetworkAddressFamily_HOST_Value),
            "::",
            stringify!(port)
        )
    );
}
impl Default for M_NetworkAddressFamily_HOST_Value {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_IPv4Address {
    pub bytes: [::core::ffi::c_uchar; 4usize],
    pub words: [M_Word; 1usize],
}
#[test]
fn bindgen_test_layout_M_IPv4Address() {
    const UNINIT: ::core::mem::MaybeUninit<M_IPv4Address> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_IPv4Address>(),
        4usize,
        concat!("Size of: ", stringify!(M_IPv4Address))
    );
    assert_eq!(
        ::core::mem::align_of::<M_IPv4Address>(),
        4usize,
        concat!("Alignment of ", stringify!(M_IPv4Address))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_IPv4Address),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).words) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_IPv4Address),
            "::",
            stringify!(words)
        )
    );
}
impl Default for M_IPv4Address {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_IPv4Address {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_IPv4Address {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_NetworkAddressFamily_INET_Value {
    pub addr: M_IPv4Address,
    pub port: M_Word,
}
#[test]
fn bindgen_test_layout_M_NetworkAddressFamily_INET_Value() {
    const UNINIT: ::core::mem::MaybeUninit<M_NetworkAddressFamily_INET_Value> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_NetworkAddressFamily_INET_Value>(),
        8usize,
        concat!("Size of: ", stringify!(M_NetworkAddressFamily_INET_Value))
    );
    assert_eq!(
        ::core::mem::align_of::<M_NetworkAddressFamily_INET_Value>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(M_NetworkAddressFamily_INET_Value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_NetworkAddressFamily_INET_Value),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).port) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_NetworkAddressFamily_INET_Value),
            "::",
            stringify!(port)
        )
    );
}
impl Default for M_NetworkAddressFamily_INET_Value {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_NetworkAddressFamily_INET_Value {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_NetworkAddressFamily_INET_Value {{ addr: {:?}, port: {:?} }}",
            self.addr, self.port
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_IPv6Address {
    pub bytes: [::core::ffi::c_uchar; 16usize],
    pub words: [M_Word; 4usize],
}
#[test]
fn bindgen_test_layout_M_IPv6Address() {
    const UNINIT: ::core::mem::MaybeUninit<M_IPv6Address> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_IPv6Address>(),
        16usize,
        concat!("Size of: ", stringify!(M_IPv6Address))
    );
    assert_eq!(
        ::core::mem::align_of::<M_IPv6Address>(),
        4usize,
        concat!("Alignment of ", stringify!(M_IPv6Address))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_IPv6Address),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).words) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_IPv6Address),
            "::",
            stringify!(words)
        )
    );
}
impl Default for M_IPv6Address {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_IPv6Address {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_IPv6Address {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_NetworkAddressFamily_INET6_Value {
    pub addr: M_IPv6Address,
    pub port: M_Word,
}
#[test]
fn bindgen_test_layout_M_NetworkAddressFamily_INET6_Value() {
    const UNINIT: ::core::mem::MaybeUninit<M_NetworkAddressFamily_INET6_Value> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_NetworkAddressFamily_INET6_Value>(),
        20usize,
        concat!("Size of: ", stringify!(M_NetworkAddressFamily_INET6_Value))
    );
    assert_eq!(
        ::core::mem::align_of::<M_NetworkAddressFamily_INET6_Value>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(M_NetworkAddressFamily_INET6_Value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_NetworkAddressFamily_INET6_Value),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).port) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_NetworkAddressFamily_INET6_Value),
            "::",
            stringify!(port)
        )
    );
}
impl Default for M_NetworkAddressFamily_INET6_Value {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_NetworkAddressFamily_INET6_Value {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_NetworkAddressFamily_INET6_Value {{ addr: {:?}, port: {:?} }}",
            self.addr, self.port
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_NetworkAddressFamily__Value {
    pub host: M_NetworkAddressFamily_HOST_Value,
    pub inet: M_NetworkAddressFamily_INET_Value,
    pub inet6: M_NetworkAddressFamily_INET6_Value,
}
#[test]
fn bindgen_test_layout_M_NetworkAddressFamily__Value() {
    const UNINIT: ::core::mem::MaybeUninit<M_NetworkAddressFamily__Value> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_NetworkAddressFamily__Value>(),
        24usize,
        concat!("Size of: ", stringify!(M_NetworkAddressFamily__Value))
    );
    assert_eq!(
        ::core::mem::align_of::<M_NetworkAddressFamily__Value>(),
        8usize,
        concat!("Alignment of ", stringify!(M_NetworkAddressFamily__Value))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).host) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_NetworkAddressFamily__Value),
            "::",
            stringify!(host)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).inet) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_NetworkAddressFamily__Value),
            "::",
            stringify!(inet)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).inet6) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_NetworkAddressFamily__Value),
            "::",
            stringify!(inet6)
        )
    );
}
impl Default for M_NetworkAddressFamily__Value {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_NetworkAddressFamily__Value {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_NetworkAddressFamily__Value {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_NetworkAddress {
    pub af: M_NetworkAddressFamily,
    pub addr: M_NetworkAddressFamily__Value,
}
#[test]
fn bindgen_test_layout_M_NetworkAddress() {
    const UNINIT: ::core::mem::MaybeUninit<M_NetworkAddress> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_NetworkAddress>(),
        32usize,
        concat!("Size of: ", stringify!(M_NetworkAddress))
    );
    assert_eq!(
        ::core::mem::align_of::<M_NetworkAddress>(),
        8usize,
        concat!("Alignment of ", stringify!(M_NetworkAddress))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).af) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_NetworkAddress),
            "::",
            stringify!(af)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).addr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_NetworkAddress),
            "::",
            stringify!(addr)
        )
    );
}
impl Default for M_NetworkAddress {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_NetworkAddress {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_NetworkAddress {{ af: {:?}, addr: {:?} }}",
            self.af, self.addr
        )
    }
}
pub type M_ClientID = M_Hash;
pub type M_LimitID = M_Hash;
pub type M_Hash20 = M_Hash;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_KeyHashMech_SHA1Hash_KeyHashData {
    pub hash: M_Hash20,
}
#[test]
fn bindgen_test_layout_M_KeyHashMech_SHA1Hash_KeyHashData() {
    const UNINIT: ::core::mem::MaybeUninit<M_KeyHashMech_SHA1Hash_KeyHashData> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_KeyHashMech_SHA1Hash_KeyHashData>(),
        20usize,
        concat!("Size of: ", stringify!(M_KeyHashMech_SHA1Hash_KeyHashData))
    );
    assert_eq!(
        ::core::mem::align_of::<M_KeyHashMech_SHA1Hash_KeyHashData>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(M_KeyHashMech_SHA1Hash_KeyHashData)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hash) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyHashMech_SHA1Hash_KeyHashData),
            "::",
            stringify!(hash)
        )
    );
}
impl Default for M_KeyHashMech_SHA1Hash_KeyHashData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_KeyHashMech_SHA1Hash_KeyHashData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_KeyHashMech_SHA1Hash_KeyHashData {{ hash: {:?} }}",
            self.hash
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_KeyHashMech_SHA256Hash_KeyHashData {
    pub hash: M_Hash32,
}
#[test]
fn bindgen_test_layout_M_KeyHashMech_SHA256Hash_KeyHashData() {
    const UNINIT: ::core::mem::MaybeUninit<M_KeyHashMech_SHA256Hash_KeyHashData> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_KeyHashMech_SHA256Hash_KeyHashData>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(M_KeyHashMech_SHA256Hash_KeyHashData)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<M_KeyHashMech_SHA256Hash_KeyHashData>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(M_KeyHashMech_SHA256Hash_KeyHashData)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hash) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyHashMech_SHA256Hash_KeyHashData),
            "::",
            stringify!(hash)
        )
    );
}
impl Default for M_KeyHashMech_SHA256Hash_KeyHashData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_KeyHashMech_SHA256Hash_KeyHashData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_KeyHashMech_SHA256Hash_KeyHashData {{ hash: {:?} }}",
            self.hash
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_KeyHashMech_SHA512Hash_KeyHashData {
    pub hash: M_Hash64,
}
#[test]
fn bindgen_test_layout_M_KeyHashMech_SHA512Hash_KeyHashData() {
    const UNINIT: ::core::mem::MaybeUninit<M_KeyHashMech_SHA512Hash_KeyHashData> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_KeyHashMech_SHA512Hash_KeyHashData>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(M_KeyHashMech_SHA512Hash_KeyHashData)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<M_KeyHashMech_SHA512Hash_KeyHashData>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(M_KeyHashMech_SHA512Hash_KeyHashData)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hash) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyHashMech_SHA512Hash_KeyHashData),
            "::",
            stringify!(hash)
        )
    );
}
impl Default for M_KeyHashMech_SHA512Hash_KeyHashData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_KeyHashMech_SHA512Hash_KeyHashData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_KeyHashMech_SHA512Hash_KeyHashData {{ hash: {:?} }}",
            self.hash
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_KeyHashMech__KeyHashData {
    pub sha1hash: M_KeyHashMech_SHA1Hash_KeyHashData,
    pub sha256hash: M_KeyHashMech_SHA256Hash_KeyHashData,
    pub sha512hash: M_KeyHashMech_SHA512Hash_KeyHashData,
}
#[test]
fn bindgen_test_layout_M_KeyHashMech__KeyHashData() {
    const UNINIT: ::core::mem::MaybeUninit<M_KeyHashMech__KeyHashData> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_KeyHashMech__KeyHashData>(),
        64usize,
        concat!("Size of: ", stringify!(M_KeyHashMech__KeyHashData))
    );
    assert_eq!(
        ::core::mem::align_of::<M_KeyHashMech__KeyHashData>(),
        4usize,
        concat!("Alignment of ", stringify!(M_KeyHashMech__KeyHashData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sha1hash) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyHashMech__KeyHashData),
            "::",
            stringify!(sha1hash)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sha256hash) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyHashMech__KeyHashData),
            "::",
            stringify!(sha256hash)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sha512hash) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyHashMech__KeyHashData),
            "::",
            stringify!(sha512hash)
        )
    );
}
impl Default for M_KeyHashMech__KeyHashData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_KeyHashMech__KeyHashData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_KeyHashMech__KeyHashData {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_KeyHashEx {
    pub mech: M_KeyHashMech,
    pub data: M_KeyHashMech__KeyHashData,
}
#[test]
fn bindgen_test_layout_M_KeyHashEx() {
    const UNINIT: ::core::mem::MaybeUninit<M_KeyHashEx> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_KeyHashEx>(),
        68usize,
        concat!("Size of: ", stringify!(M_KeyHashEx))
    );
    assert_eq!(
        ::core::mem::align_of::<M_KeyHashEx>(),
        4usize,
        concat!("Alignment of ", stringify!(M_KeyHashEx))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mech) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyHashEx),
            "::",
            stringify!(mech)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyHashEx),
            "::",
            stringify!(data)
        )
    );
}
impl Default for M_KeyHashEx {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_KeyHashEx {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_KeyHashEx {{ mech: {:?}, data: {:?} }}",
            self.mech, self.data
        )
    }
}
pub type M_TokenHash = M_Hash;
pub type M_KMHash = M_Hash;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_PhysToken {
    pub module: M_ModuleID,
    pub slot: M_SlotID,
    pub ic: M_Word,
}
#[test]
fn bindgen_test_layout_M_PhysToken() {
    const UNINIT: ::core::mem::MaybeUninit<M_PhysToken> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_PhysToken>(),
        12usize,
        concat!("Size of: ", stringify!(M_PhysToken))
    );
    assert_eq!(
        ::core::mem::align_of::<M_PhysToken>(),
        4usize,
        concat!("Alignment of ", stringify!(M_PhysToken))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_PhysToken),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).slot) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_PhysToken),
            "::",
            stringify!(slot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ic) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_PhysToken),
            "::",
            stringify!(ic)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_SlotType_Unconnected_SlotExData {
    pub stinfo: M_StatusErrorInfo,
}
#[test]
fn bindgen_test_layout_M_SlotType_Unconnected_SlotExData() {
    const UNINIT: ::core::mem::MaybeUninit<M_SlotType_Unconnected_SlotExData> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_SlotType_Unconnected_SlotExData>(),
        32usize,
        concat!("Size of: ", stringify!(M_SlotType_Unconnected_SlotExData))
    );
    assert_eq!(
        ::core::mem::align_of::<M_SlotType_Unconnected_SlotExData>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(M_SlotType_Unconnected_SlotExData)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stinfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_SlotType_Unconnected_SlotExData),
            "::",
            stringify!(stinfo)
        )
    );
}
impl Default for M_SlotType_Unconnected_SlotExData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_SlotType_Unconnected_SlotExData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_SlotType_Unconnected_SlotExData {{ stinfo: {:?} }}",
            self.stinfo
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_SlotType__SlotExData {
    pub unconnected: M_SlotType_Unconnected_SlotExData,
}
#[test]
fn bindgen_test_layout_M_SlotType__SlotExData() {
    const UNINIT: ::core::mem::MaybeUninit<M_SlotType__SlotExData> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_SlotType__SlotExData>(),
        32usize,
        concat!("Size of: ", stringify!(M_SlotType__SlotExData))
    );
    assert_eq!(
        ::core::mem::align_of::<M_SlotType__SlotExData>(),
        8usize,
        concat!("Alignment of ", stringify!(M_SlotType__SlotExData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unconnected) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_SlotType__SlotExData),
            "::",
            stringify!(unconnected)
        )
    );
}
impl Default for M_SlotType__SlotExData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_SlotType__SlotExData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_SlotType__SlotExData {{ union }}")
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_PlainTextType_Bignum_Data {
    pub m: M_Bignum,
}
#[test]
fn bindgen_test_layout_M_PlainTextType_Bignum_Data() {
    const UNINIT: ::core::mem::MaybeUninit<M_PlainTextType_Bignum_Data> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_PlainTextType_Bignum_Data>(),
        8usize,
        concat!("Size of: ", stringify!(M_PlainTextType_Bignum_Data))
    );
    assert_eq!(
        ::core::mem::align_of::<M_PlainTextType_Bignum_Data>(),
        8usize,
        concat!("Alignment of ", stringify!(M_PlainTextType_Bignum_Data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_PlainTextType_Bignum_Data),
            "::",
            stringify!(m)
        )
    );
}
impl Default for M_PlainTextType_Bignum_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_PlainTextType_Bytes_Data {
    pub data: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_PlainTextType_Bytes_Data() {
    const UNINIT: ::core::mem::MaybeUninit<M_PlainTextType_Bytes_Data> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_PlainTextType_Bytes_Data>(),
        16usize,
        concat!("Size of: ", stringify!(M_PlainTextType_Bytes_Data))
    );
    assert_eq!(
        ::core::mem::align_of::<M_PlainTextType_Bytes_Data>(),
        8usize,
        concat!("Alignment of ", stringify!(M_PlainTextType_Bytes_Data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_PlainTextType_Bytes_Data),
            "::",
            stringify!(data)
        )
    );
}
impl Default for M_PlainTextType_Bytes_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_ECPoint_flags = M_Word;
pub type M_FieldElement = M_Bignum;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_ECPoint {
    pub flags: M_ECPoint_flags,
    pub x: M_FieldElement,
    pub y: M_FieldElement,
}
#[test]
fn bindgen_test_layout_M_ECPoint() {
    const UNINIT: ::core::mem::MaybeUninit<M_ECPoint> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_ECPoint>(),
        24usize,
        concat!("Size of: ", stringify!(M_ECPoint))
    );
    assert_eq!(
        ::core::mem::align_of::<M_ECPoint>(),
        8usize,
        concat!("Alignment of ", stringify!(M_ECPoint))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ECPoint),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ECPoint),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ECPoint),
            "::",
            stringify!(y)
        )
    );
}
impl Default for M_ECPoint {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_PlainTextType_ECPoint_Data {
    pub data: M_ECPoint,
}
#[test]
fn bindgen_test_layout_M_PlainTextType_ECPoint_Data() {
    const UNINIT: ::core::mem::MaybeUninit<M_PlainTextType_ECPoint_Data> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_PlainTextType_ECPoint_Data>(),
        24usize,
        concat!("Size of: ", stringify!(M_PlainTextType_ECPoint_Data))
    );
    assert_eq!(
        ::core::mem::align_of::<M_PlainTextType_ECPoint_Data>(),
        8usize,
        concat!("Alignment of ", stringify!(M_PlainTextType_ECPoint_Data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_PlainTextType_ECPoint_Data),
            "::",
            stringify!(data)
        )
    );
}
impl Default for M_PlainTextType_ECPoint_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_PlainTextType_Hash_Data {
    pub data: M_Hash,
}
#[test]
fn bindgen_test_layout_M_PlainTextType_Hash_Data() {
    const UNINIT: ::core::mem::MaybeUninit<M_PlainTextType_Hash_Data> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_PlainTextType_Hash_Data>(),
        20usize,
        concat!("Size of: ", stringify!(M_PlainTextType_Hash_Data))
    );
    assert_eq!(
        ::core::mem::align_of::<M_PlainTextType_Hash_Data>(),
        4usize,
        concat!("Alignment of ", stringify!(M_PlainTextType_Hash_Data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_PlainTextType_Hash_Data),
            "::",
            stringify!(data)
        )
    );
}
impl Default for M_PlainTextType_Hash_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_PlainTextType_Hash_Data {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_PlainTextType_Hash_Data {{ data: {:?} }}", self.data)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_Hash16 {
    pub bytes: [::core::ffi::c_uchar; 16usize],
    pub words: [M_Word; 4usize],
}
#[test]
fn bindgen_test_layout_M_Hash16() {
    const UNINIT: ::core::mem::MaybeUninit<M_Hash16> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Hash16>(),
        16usize,
        concat!("Size of: ", stringify!(M_Hash16))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Hash16>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Hash16))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Hash16),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).words) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Hash16),
            "::",
            stringify!(words)
        )
    );
}
impl Default for M_Hash16 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Hash16 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Hash16 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_PlainTextType_Hash16_Data {
    pub data: M_Hash16,
}
#[test]
fn bindgen_test_layout_M_PlainTextType_Hash16_Data() {
    const UNINIT: ::core::mem::MaybeUninit<M_PlainTextType_Hash16_Data> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_PlainTextType_Hash16_Data>(),
        16usize,
        concat!("Size of: ", stringify!(M_PlainTextType_Hash16_Data))
    );
    assert_eq!(
        ::core::mem::align_of::<M_PlainTextType_Hash16_Data>(),
        4usize,
        concat!("Alignment of ", stringify!(M_PlainTextType_Hash16_Data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_PlainTextType_Hash16_Data),
            "::",
            stringify!(data)
        )
    );
}
impl Default for M_PlainTextType_Hash16_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_PlainTextType_Hash16_Data {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_PlainTextType_Hash16_Data {{ data: {:?} }}", self.data)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_Hash24 {
    pub bytes: [::core::ffi::c_uchar; 24usize],
    pub words: [M_Word; 6usize],
}
#[test]
fn bindgen_test_layout_M_Hash24() {
    const UNINIT: ::core::mem::MaybeUninit<M_Hash24> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Hash24>(),
        24usize,
        concat!("Size of: ", stringify!(M_Hash24))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Hash24>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Hash24))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Hash24),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).words) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Hash24),
            "::",
            stringify!(words)
        )
    );
}
impl Default for M_Hash24 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Hash24 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Hash24 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_PlainTextType_Hash24_Data {
    pub data: M_Hash24,
}
#[test]
fn bindgen_test_layout_M_PlainTextType_Hash24_Data() {
    const UNINIT: ::core::mem::MaybeUninit<M_PlainTextType_Hash24_Data> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_PlainTextType_Hash24_Data>(),
        24usize,
        concat!("Size of: ", stringify!(M_PlainTextType_Hash24_Data))
    );
    assert_eq!(
        ::core::mem::align_of::<M_PlainTextType_Hash24_Data>(),
        4usize,
        concat!("Alignment of ", stringify!(M_PlainTextType_Hash24_Data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_PlainTextType_Hash24_Data),
            "::",
            stringify!(data)
        )
    );
}
impl Default for M_PlainTextType_Hash24_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_PlainTextType_Hash24_Data {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_PlainTextType_Hash24_Data {{ data: {:?} }}", self.data)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_PlainTextType_Hash28_Data {
    pub data: M_Hash28,
}
#[test]
fn bindgen_test_layout_M_PlainTextType_Hash28_Data() {
    const UNINIT: ::core::mem::MaybeUninit<M_PlainTextType_Hash28_Data> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_PlainTextType_Hash28_Data>(),
        28usize,
        concat!("Size of: ", stringify!(M_PlainTextType_Hash28_Data))
    );
    assert_eq!(
        ::core::mem::align_of::<M_PlainTextType_Hash28_Data>(),
        4usize,
        concat!("Alignment of ", stringify!(M_PlainTextType_Hash28_Data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_PlainTextType_Hash28_Data),
            "::",
            stringify!(data)
        )
    );
}
impl Default for M_PlainTextType_Hash28_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_PlainTextType_Hash28_Data {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_PlainTextType_Hash28_Data {{ data: {:?} }}", self.data)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_PlainTextType_Hash32_Data {
    pub data: M_Hash32,
}
#[test]
fn bindgen_test_layout_M_PlainTextType_Hash32_Data() {
    const UNINIT: ::core::mem::MaybeUninit<M_PlainTextType_Hash32_Data> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_PlainTextType_Hash32_Data>(),
        32usize,
        concat!("Size of: ", stringify!(M_PlainTextType_Hash32_Data))
    );
    assert_eq!(
        ::core::mem::align_of::<M_PlainTextType_Hash32_Data>(),
        4usize,
        concat!("Alignment of ", stringify!(M_PlainTextType_Hash32_Data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_PlainTextType_Hash32_Data),
            "::",
            stringify!(data)
        )
    );
}
impl Default for M_PlainTextType_Hash32_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_PlainTextType_Hash32_Data {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_PlainTextType_Hash32_Data {{ data: {:?} }}", self.data)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_PlainTextType_Hash48_Data {
    pub data: M_Hash48,
}
#[test]
fn bindgen_test_layout_M_PlainTextType_Hash48_Data() {
    const UNINIT: ::core::mem::MaybeUninit<M_PlainTextType_Hash48_Data> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_PlainTextType_Hash48_Data>(),
        48usize,
        concat!("Size of: ", stringify!(M_PlainTextType_Hash48_Data))
    );
    assert_eq!(
        ::core::mem::align_of::<M_PlainTextType_Hash48_Data>(),
        4usize,
        concat!("Alignment of ", stringify!(M_PlainTextType_Hash48_Data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_PlainTextType_Hash48_Data),
            "::",
            stringify!(data)
        )
    );
}
impl Default for M_PlainTextType_Hash48_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_PlainTextType_Hash48_Data {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_PlainTextType_Hash48_Data {{ data: {:?} }}", self.data)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_PlainTextType_Hash64_Data {
    pub data: M_Hash64,
}
#[test]
fn bindgen_test_layout_M_PlainTextType_Hash64_Data() {
    const UNINIT: ::core::mem::MaybeUninit<M_PlainTextType_Hash64_Data> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_PlainTextType_Hash64_Data>(),
        64usize,
        concat!("Size of: ", stringify!(M_PlainTextType_Hash64_Data))
    );
    assert_eq!(
        ::core::mem::align_of::<M_PlainTextType_Hash64_Data>(),
        4usize,
        concat!("Alignment of ", stringify!(M_PlainTextType_Hash64_Data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_PlainTextType_Hash64_Data),
            "::",
            stringify!(data)
        )
    );
}
impl Default for M_PlainTextType_Hash64_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_PlainTextType_Hash64_Data {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_PlainTextType_Hash64_Data {{ data: {:?} }}", self.data)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_PlainTextType__Data {
    pub bignum: M_PlainTextType_Bignum_Data,
    pub bytes: M_PlainTextType_Bytes_Data,
    pub ecpoint: M_PlainTextType_ECPoint_Data,
    pub hash: M_PlainTextType_Hash_Data,
    pub hash16: M_PlainTextType_Hash16_Data,
    pub hash24: M_PlainTextType_Hash24_Data,
    pub hash28: M_PlainTextType_Hash28_Data,
    pub hash32: M_PlainTextType_Hash32_Data,
    pub hash48: M_PlainTextType_Hash48_Data,
    pub hash64: M_PlainTextType_Hash64_Data,
}
#[test]
fn bindgen_test_layout_M_PlainTextType__Data() {
    const UNINIT: ::core::mem::MaybeUninit<M_PlainTextType__Data> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_PlainTextType__Data>(),
        64usize,
        concat!("Size of: ", stringify!(M_PlainTextType__Data))
    );
    assert_eq!(
        ::core::mem::align_of::<M_PlainTextType__Data>(),
        8usize,
        concat!("Alignment of ", stringify!(M_PlainTextType__Data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bignum) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_PlainTextType__Data),
            "::",
            stringify!(bignum)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_PlainTextType__Data),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ecpoint) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_PlainTextType__Data),
            "::",
            stringify!(ecpoint)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hash) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_PlainTextType__Data),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hash16) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_PlainTextType__Data),
            "::",
            stringify!(hash16)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hash24) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_PlainTextType__Data),
            "::",
            stringify!(hash24)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hash28) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_PlainTextType__Data),
            "::",
            stringify!(hash28)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hash32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_PlainTextType__Data),
            "::",
            stringify!(hash32)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hash48) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_PlainTextType__Data),
            "::",
            stringify!(hash48)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hash64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_PlainTextType__Data),
            "::",
            stringify!(hash64)
        )
    );
}
impl Default for M_PlainTextType__Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_PlainTextType__Data {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_PlainTextType__Data {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_ChannelType__ExtraCOI {
    pub union_is_empty_hack: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_M_ChannelType__ExtraCOI() {
    const UNINIT: ::core::mem::MaybeUninit<M_ChannelType__ExtraCOI> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_ChannelType__ExtraCOI>(),
        4usize,
        concat!("Size of: ", stringify!(M_ChannelType__ExtraCOI))
    );
    assert_eq!(
        ::core::mem::align_of::<M_ChannelType__ExtraCOI>(),
        4usize,
        concat!("Alignment of ", stringify!(M_ChannelType__ExtraCOI))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).union_is_empty_hack) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ChannelType__ExtraCOI),
            "::",
            stringify!(union_is_empty_hack)
        )
    );
}
impl Default for M_ChannelType__ExtraCOI {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_ChannelType__ExtraCOI {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_ChannelType__ExtraCOI {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_ChannelOpenInfo {
    pub type_: M_ChannelType,
    pub info: M_ChannelType__ExtraCOI,
}
#[test]
fn bindgen_test_layout_M_ChannelOpenInfo() {
    const UNINIT: ::core::mem::MaybeUninit<M_ChannelOpenInfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_ChannelOpenInfo>(),
        8usize,
        concat!("Size of: ", stringify!(M_ChannelOpenInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<M_ChannelOpenInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(M_ChannelOpenInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ChannelOpenInfo),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ChannelOpenInfo),
            "::",
            stringify!(info)
        )
    );
}
impl Default for M_ChannelOpenInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_ChannelOpenInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_ChannelOpenInfo {{ type: {:?}, info: {:?} }}",
            self.type_, self.info
        )
    }
}
pub type M_AnyKeyID = M_KeyID;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_CertType_SigningKey_CertBody {
    pub key: M_AnyKeyID,
}
#[test]
fn bindgen_test_layout_M_CertType_SigningKey_CertBody() {
    const UNINIT: ::core::mem::MaybeUninit<M_CertType_SigningKey_CertBody> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_CertType_SigningKey_CertBody>(),
        4usize,
        concat!("Size of: ", stringify!(M_CertType_SigningKey_CertBody))
    );
    assert_eq!(
        ::core::mem::align_of::<M_CertType_SigningKey_CertBody>(),
        4usize,
        concat!("Alignment of ", stringify!(M_CertType_SigningKey_CertBody))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_CertType_SigningKey_CertBody),
            "::",
            stringify!(key)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_DESKey {
    pub bytes: [::core::ffi::c_uchar; 8usize],
    pub words: [M_Word; 2usize],
}
#[test]
fn bindgen_test_layout_M_DESKey() {
    const UNINIT: ::core::mem::MaybeUninit<M_DESKey> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_DESKey>(),
        8usize,
        concat!("Size of: ", stringify!(M_DESKey))
    );
    assert_eq!(
        ::core::mem::align_of::<M_DESKey>(),
        4usize,
        concat!("Alignment of ", stringify!(M_DESKey))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DESKey),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).words) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DESKey),
            "::",
            stringify!(words)
        )
    );
}
impl Default for M_DESKey {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_DESKey {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_DESKey {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_KeyType_DES_Data {
    pub k: M_DESKey,
}
#[test]
fn bindgen_test_layout_M_KeyType_DES_Data() {
    const UNINIT: ::core::mem::MaybeUninit<M_KeyType_DES_Data> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_KeyType_DES_Data>(),
        8usize,
        concat!("Size of: ", stringify!(M_KeyType_DES_Data))
    );
    assert_eq!(
        ::core::mem::align_of::<M_KeyType_DES_Data>(),
        4usize,
        concat!("Alignment of ", stringify!(M_KeyType_DES_Data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).k) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_DES_Data),
            "::",
            stringify!(k)
        )
    );
}
impl Default for M_KeyType_DES_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_KeyType_DES_Data {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_KeyType_DES_Data {{ k: {:?} }}", self.k)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_DES2Key {
    pub bytes: [::core::ffi::c_uchar; 16usize],
    pub words: [M_Word; 4usize],
}
#[test]
fn bindgen_test_layout_M_DES2Key() {
    const UNINIT: ::core::mem::MaybeUninit<M_DES2Key> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_DES2Key>(),
        16usize,
        concat!("Size of: ", stringify!(M_DES2Key))
    );
    assert_eq!(
        ::core::mem::align_of::<M_DES2Key>(),
        4usize,
        concat!("Alignment of ", stringify!(M_DES2Key))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DES2Key),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).words) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DES2Key),
            "::",
            stringify!(words)
        )
    );
}
impl Default for M_DES2Key {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_DES2Key {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_DES2Key {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_KeyType_DES2_Data {
    pub k: M_DES2Key,
}
#[test]
fn bindgen_test_layout_M_KeyType_DES2_Data() {
    const UNINIT: ::core::mem::MaybeUninit<M_KeyType_DES2_Data> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_KeyType_DES2_Data>(),
        16usize,
        concat!("Size of: ", stringify!(M_KeyType_DES2_Data))
    );
    assert_eq!(
        ::core::mem::align_of::<M_KeyType_DES2_Data>(),
        4usize,
        concat!("Alignment of ", stringify!(M_KeyType_DES2_Data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).k) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_DES2_Data),
            "::",
            stringify!(k)
        )
    );
}
impl Default for M_KeyType_DES2_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_KeyType_DES2_Data {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_KeyType_DES2_Data {{ k: {:?} }}", self.k)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_DES3Key {
    pub bytes: [::core::ffi::c_uchar; 24usize],
    pub words: [M_Word; 6usize],
}
#[test]
fn bindgen_test_layout_M_DES3Key() {
    const UNINIT: ::core::mem::MaybeUninit<M_DES3Key> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_DES3Key>(),
        24usize,
        concat!("Size of: ", stringify!(M_DES3Key))
    );
    assert_eq!(
        ::core::mem::align_of::<M_DES3Key>(),
        4usize,
        concat!("Alignment of ", stringify!(M_DES3Key))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DES3Key),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).words) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DES3Key),
            "::",
            stringify!(words)
        )
    );
}
impl Default for M_DES3Key {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_DES3Key {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_DES3Key {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_KeyType_DES3_Data {
    pub k: M_DES3Key,
}
#[test]
fn bindgen_test_layout_M_KeyType_DES3_Data() {
    const UNINIT: ::core::mem::MaybeUninit<M_KeyType_DES3_Data> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_KeyType_DES3_Data>(),
        24usize,
        concat!("Size of: ", stringify!(M_KeyType_DES3_Data))
    );
    assert_eq!(
        ::core::mem::align_of::<M_KeyType_DES3_Data>(),
        4usize,
        concat!("Alignment of ", stringify!(M_KeyType_DES3_Data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).k) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_DES3_Data),
            "::",
            stringify!(k)
        )
    );
}
impl Default for M_KeyType_DES3_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_KeyType_DES3_Data {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_KeyType_DES3_Data {{ k: {:?} }}", self.k)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_DSADiscreteLogGroup {
    pub p: M_Bignum,
    pub q: M_Bignum,
    pub g: M_Bignum,
}
#[test]
fn bindgen_test_layout_M_DSADiscreteLogGroup() {
    const UNINIT: ::core::mem::MaybeUninit<M_DSADiscreteLogGroup> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_DSADiscreteLogGroup>(),
        24usize,
        concat!("Size of: ", stringify!(M_DSADiscreteLogGroup))
    );
    assert_eq!(
        ::core::mem::align_of::<M_DSADiscreteLogGroup>(),
        8usize,
        concat!("Alignment of ", stringify!(M_DSADiscreteLogGroup))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DSADiscreteLogGroup),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).q) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DSADiscreteLogGroup),
            "::",
            stringify!(q)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).g) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DSADiscreteLogGroup),
            "::",
            stringify!(g)
        )
    );
}
impl Default for M_DSADiscreteLogGroup {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_DHExDiscreteLogGroup = M_DSADiscreteLogGroup;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_KeyType_DHExPrivate_Data {
    pub dlg: M_DHExDiscreteLogGroup,
    pub x: M_Bignum,
}
#[test]
fn bindgen_test_layout_M_KeyType_DHExPrivate_Data() {
    const UNINIT: ::core::mem::MaybeUninit<M_KeyType_DHExPrivate_Data> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_KeyType_DHExPrivate_Data>(),
        32usize,
        concat!("Size of: ", stringify!(M_KeyType_DHExPrivate_Data))
    );
    assert_eq!(
        ::core::mem::align_of::<M_KeyType_DHExPrivate_Data>(),
        8usize,
        concat!("Alignment of ", stringify!(M_KeyType_DHExPrivate_Data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dlg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_DHExPrivate_Data),
            "::",
            stringify!(dlg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_DHExPrivate_Data),
            "::",
            stringify!(x)
        )
    );
}
impl Default for M_KeyType_DHExPrivate_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_KeyType_DHExPublic_Data {
    pub dlg: M_DHExDiscreteLogGroup,
    pub gx: M_Bignum,
}
#[test]
fn bindgen_test_layout_M_KeyType_DHExPublic_Data() {
    const UNINIT: ::core::mem::MaybeUninit<M_KeyType_DHExPublic_Data> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_KeyType_DHExPublic_Data>(),
        32usize,
        concat!("Size of: ", stringify!(M_KeyType_DHExPublic_Data))
    );
    assert_eq!(
        ::core::mem::align_of::<M_KeyType_DHExPublic_Data>(),
        8usize,
        concat!("Alignment of ", stringify!(M_KeyType_DHExPublic_Data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dlg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_DHExPublic_Data),
            "::",
            stringify!(dlg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gx) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_DHExPublic_Data),
            "::",
            stringify!(gx)
        )
    );
}
impl Default for M_KeyType_DHExPublic_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_DiscreteLogGroup {
    pub p: M_Bignum,
    pub g: M_Bignum,
}
#[test]
fn bindgen_test_layout_M_DiscreteLogGroup() {
    const UNINIT: ::core::mem::MaybeUninit<M_DiscreteLogGroup> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_DiscreteLogGroup>(),
        16usize,
        concat!("Size of: ", stringify!(M_DiscreteLogGroup))
    );
    assert_eq!(
        ::core::mem::align_of::<M_DiscreteLogGroup>(),
        8usize,
        concat!("Alignment of ", stringify!(M_DiscreteLogGroup))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DiscreteLogGroup),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).g) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DiscreteLogGroup),
            "::",
            stringify!(g)
        )
    );
}
impl Default for M_DiscreteLogGroup {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_KeyType_DHPrivate_Data {
    pub dlg: M_DiscreteLogGroup,
    pub x: M_Bignum,
}
#[test]
fn bindgen_test_layout_M_KeyType_DHPrivate_Data() {
    const UNINIT: ::core::mem::MaybeUninit<M_KeyType_DHPrivate_Data> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_KeyType_DHPrivate_Data>(),
        24usize,
        concat!("Size of: ", stringify!(M_KeyType_DHPrivate_Data))
    );
    assert_eq!(
        ::core::mem::align_of::<M_KeyType_DHPrivate_Data>(),
        8usize,
        concat!("Alignment of ", stringify!(M_KeyType_DHPrivate_Data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dlg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_DHPrivate_Data),
            "::",
            stringify!(dlg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_DHPrivate_Data),
            "::",
            stringify!(x)
        )
    );
}
impl Default for M_KeyType_DHPrivate_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_KeyType_DHPublic_Data {
    pub dlg: M_DiscreteLogGroup,
    pub gx: M_Bignum,
}
#[test]
fn bindgen_test_layout_M_KeyType_DHPublic_Data() {
    const UNINIT: ::core::mem::MaybeUninit<M_KeyType_DHPublic_Data> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_KeyType_DHPublic_Data>(),
        24usize,
        concat!("Size of: ", stringify!(M_KeyType_DHPublic_Data))
    );
    assert_eq!(
        ::core::mem::align_of::<M_KeyType_DHPublic_Data>(),
        8usize,
        concat!("Alignment of ", stringify!(M_KeyType_DHPublic_Data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dlg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_DHPublic_Data),
            "::",
            stringify!(dlg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gx) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_DHPublic_Data),
            "::",
            stringify!(gx)
        )
    );
}
impl Default for M_KeyType_DHPublic_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_KeyType_DKTemplate_Data {
    pub appdata: M_ByteBlock,
    pub nested_acl: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_KeyType_DKTemplate_Data() {
    const UNINIT: ::core::mem::MaybeUninit<M_KeyType_DKTemplate_Data> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_KeyType_DKTemplate_Data>(),
        32usize,
        concat!("Size of: ", stringify!(M_KeyType_DKTemplate_Data))
    );
    assert_eq!(
        ::core::mem::align_of::<M_KeyType_DKTemplate_Data>(),
        8usize,
        concat!("Alignment of ", stringify!(M_KeyType_DKTemplate_Data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).appdata) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_DKTemplate_Data),
            "::",
            stringify!(appdata)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nested_acl) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_DKTemplate_Data),
            "::",
            stringify!(nested_acl)
        )
    );
}
impl Default for M_KeyType_DKTemplate_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_DSAInitValues {
    pub seed: M_Hash,
    pub counter: M_Word,
    pub h: M_Word,
}
#[test]
fn bindgen_test_layout_M_DSAInitValues() {
    const UNINIT: ::core::mem::MaybeUninit<M_DSAInitValues> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_DSAInitValues>(),
        28usize,
        concat!("Size of: ", stringify!(M_DSAInitValues))
    );
    assert_eq!(
        ::core::mem::align_of::<M_DSAInitValues>(),
        4usize,
        concat!("Alignment of ", stringify!(M_DSAInitValues))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).seed) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DSAInitValues),
            "::",
            stringify!(seed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).counter) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DSAInitValues),
            "::",
            stringify!(counter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DSAInitValues),
            "::",
            stringify!(h)
        )
    );
}
impl Default for M_DSAInitValues {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_DSAInitValues {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_DSAInitValues {{ seed: {:?}, counter: {:?}, h: {:?} }}",
            self.seed, self.counter, self.h
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_KeyType_DSAComm_Data {
    pub iv: M_DSAInitValues,
    pub dlg: M_DSADiscreteLogGroup,
}
#[test]
fn bindgen_test_layout_M_KeyType_DSAComm_Data() {
    const UNINIT: ::core::mem::MaybeUninit<M_KeyType_DSAComm_Data> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_KeyType_DSAComm_Data>(),
        56usize,
        concat!("Size of: ", stringify!(M_KeyType_DSAComm_Data))
    );
    assert_eq!(
        ::core::mem::align_of::<M_KeyType_DSAComm_Data>(),
        8usize,
        concat!("Alignment of ", stringify!(M_KeyType_DSAComm_Data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iv) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_DSAComm_Data),
            "::",
            stringify!(iv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dlg) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_DSAComm_Data),
            "::",
            stringify!(dlg)
        )
    );
}
impl Default for M_KeyType_DSAComm_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_KeyType_DSAComm_Data {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_KeyType_DSAComm_Data {{ iv: {:?}, dlg: {:?} }}",
            self.iv, self.dlg
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_DSAInitValuesVarSeed {
    pub seed: M_ByteBlock,
    pub counter: M_Word,
    pub h: M_Word,
}
#[test]
fn bindgen_test_layout_M_DSAInitValuesVarSeed() {
    const UNINIT: ::core::mem::MaybeUninit<M_DSAInitValuesVarSeed> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_DSAInitValuesVarSeed>(),
        24usize,
        concat!("Size of: ", stringify!(M_DSAInitValuesVarSeed))
    );
    assert_eq!(
        ::core::mem::align_of::<M_DSAInitValuesVarSeed>(),
        8usize,
        concat!("Alignment of ", stringify!(M_DSAInitValuesVarSeed))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).seed) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DSAInitValuesVarSeed),
            "::",
            stringify!(seed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).counter) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DSAInitValuesVarSeed),
            "::",
            stringify!(counter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DSAInitValuesVarSeed),
            "::",
            stringify!(h)
        )
    );
}
impl Default for M_DSAInitValuesVarSeed {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_KeyType_DSACommVariableSeed_Data {
    pub iv: M_DSAInitValuesVarSeed,
    pub dlg: M_DSADiscreteLogGroup,
}
#[test]
fn bindgen_test_layout_M_KeyType_DSACommVariableSeed_Data() {
    const UNINIT: ::core::mem::MaybeUninit<M_KeyType_DSACommVariableSeed_Data> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_KeyType_DSACommVariableSeed_Data>(),
        48usize,
        concat!("Size of: ", stringify!(M_KeyType_DSACommVariableSeed_Data))
    );
    assert_eq!(
        ::core::mem::align_of::<M_KeyType_DSACommVariableSeed_Data>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(M_KeyType_DSACommVariableSeed_Data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iv) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_DSACommVariableSeed_Data),
            "::",
            stringify!(iv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dlg) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_DSACommVariableSeed_Data),
            "::",
            stringify!(dlg)
        )
    );
}
impl Default for M_KeyType_DSACommVariableSeed_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_KeyType_DSAPrivate_Data {
    pub dlg: M_DSADiscreteLogGroup,
    pub x: M_Bignum,
}
#[test]
fn bindgen_test_layout_M_KeyType_DSAPrivate_Data() {
    const UNINIT: ::core::mem::MaybeUninit<M_KeyType_DSAPrivate_Data> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_KeyType_DSAPrivate_Data>(),
        32usize,
        concat!("Size of: ", stringify!(M_KeyType_DSAPrivate_Data))
    );
    assert_eq!(
        ::core::mem::align_of::<M_KeyType_DSAPrivate_Data>(),
        8usize,
        concat!("Alignment of ", stringify!(M_KeyType_DSAPrivate_Data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dlg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_DSAPrivate_Data),
            "::",
            stringify!(dlg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_DSAPrivate_Data),
            "::",
            stringify!(x)
        )
    );
}
impl Default for M_KeyType_DSAPrivate_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_KeyType_DSAPublic_Data {
    pub dlg: M_DSADiscreteLogGroup,
    pub y: M_Bignum,
}
#[test]
fn bindgen_test_layout_M_KeyType_DSAPublic_Data() {
    const UNINIT: ::core::mem::MaybeUninit<M_KeyType_DSAPublic_Data> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_KeyType_DSAPublic_Data>(),
        32usize,
        concat!("Size of: ", stringify!(M_KeyType_DSAPublic_Data))
    );
    assert_eq!(
        ::core::mem::align_of::<M_KeyType_DSAPublic_Data>(),
        8usize,
        concat!("Alignment of ", stringify!(M_KeyType_DSAPublic_Data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dlg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_DSAPublic_Data),
            "::",
            stringify!(dlg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_DSAPublic_Data),
            "::",
            stringify!(y)
        )
    );
}
impl Default for M_KeyType_DSAPublic_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_FieldType_Binary_Data_flags = M_Word;
pub type M_vec_Word = *mut M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_FieldType_Binary_Data {
    pub flags: M_FieldType_Binary_Data_flags,
    pub n_exponents: ::core::ffi::c_int,
    pub exponents: M_vec_Word,
    pub beta: *mut M_Bignum,
}
#[test]
fn bindgen_test_layout_M_FieldType_Binary_Data() {
    const UNINIT: ::core::mem::MaybeUninit<M_FieldType_Binary_Data> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_FieldType_Binary_Data>(),
        24usize,
        concat!("Size of: ", stringify!(M_FieldType_Binary_Data))
    );
    assert_eq!(
        ::core::mem::align_of::<M_FieldType_Binary_Data>(),
        8usize,
        concat!("Alignment of ", stringify!(M_FieldType_Binary_Data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_FieldType_Binary_Data),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_exponents) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_FieldType_Binary_Data),
            "::",
            stringify!(n_exponents)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).exponents) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_FieldType_Binary_Data),
            "::",
            stringify!(exponents)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).beta) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_FieldType_Binary_Data),
            "::",
            stringify!(beta)
        )
    );
}
impl Default for M_FieldType_Binary_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_FieldType_Prime_Data_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_FieldType_Prime_Data {
    pub flags: M_FieldType_Prime_Data_flags,
    pub p: M_Bignum,
}
#[test]
fn bindgen_test_layout_M_FieldType_Prime_Data() {
    const UNINIT: ::core::mem::MaybeUninit<M_FieldType_Prime_Data> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_FieldType_Prime_Data>(),
        16usize,
        concat!("Size of: ", stringify!(M_FieldType_Prime_Data))
    );
    assert_eq!(
        ::core::mem::align_of::<M_FieldType_Prime_Data>(),
        8usize,
        concat!("Alignment of ", stringify!(M_FieldType_Prime_Data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_FieldType_Prime_Data),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_FieldType_Prime_Data),
            "::",
            stringify!(p)
        )
    );
}
impl Default for M_FieldType_Prime_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_FieldType__Data {
    pub binary: M_FieldType_Binary_Data,
    pub prime: M_FieldType_Prime_Data,
}
#[test]
fn bindgen_test_layout_M_FieldType__Data() {
    const UNINIT: ::core::mem::MaybeUninit<M_FieldType__Data> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_FieldType__Data>(),
        24usize,
        concat!("Size of: ", stringify!(M_FieldType__Data))
    );
    assert_eq!(
        ::core::mem::align_of::<M_FieldType__Data>(),
        8usize,
        concat!("Alignment of ", stringify!(M_FieldType__Data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).binary) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_FieldType__Data),
            "::",
            stringify!(binary)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_FieldType__Data),
            "::",
            stringify!(prime)
        )
    );
}
impl Default for M_FieldType__Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_FieldType__Data {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_FieldType__Data {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Field {
    pub type_: M_FieldType,
    pub data: M_FieldType__Data,
}
#[test]
fn bindgen_test_layout_M_Field() {
    const UNINIT: ::core::mem::MaybeUninit<M_Field> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Field>(),
        32usize,
        concat!("Size of: ", stringify!(M_Field))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Field>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Field))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Field),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Field),
            "::",
            stringify!(data)
        )
    );
}
impl Default for M_Field {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Field {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Field {{ type: {:?}, data: {:?} }}",
            self.type_, self.data
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_ECName_Custom_Data {
    pub F: M_Field,
    pub a: M_FieldElement,
    pub b: M_FieldElement,
    pub g: M_ECPoint,
    pub r: M_Bignum,
    pub h: M_Word,
}
#[test]
fn bindgen_test_layout_M_ECName_Custom_Data() {
    const UNINIT: ::core::mem::MaybeUninit<M_ECName_Custom_Data> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_ECName_Custom_Data>(),
        88usize,
        concat!("Size of: ", stringify!(M_ECName_Custom_Data))
    );
    assert_eq!(
        ::core::mem::align_of::<M_ECName_Custom_Data>(),
        8usize,
        concat!("Alignment of ", stringify!(M_ECName_Custom_Data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).F) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ECName_Custom_Data),
            "::",
            stringify!(F)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).a) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ECName_Custom_Data),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ECName_Custom_Data),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).g) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ECName_Custom_Data),
            "::",
            stringify!(g)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).r) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ECName_Custom_Data),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ECName_Custom_Data),
            "::",
            stringify!(h)
        )
    );
}
impl Default for M_ECName_Custom_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_ECName_Custom_Data {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_ECName_Custom_Data {{ F: {:?}, a: {:?}, b: {:?}, g: {:?}, r: {:?}, h: {:?} }}",
            self.F, self.a, self.b, self.g, self.r, self.h
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_ECName_CustomLCF_Data {
    pub F: M_Field,
    pub a: M_FieldElement,
    pub b: M_FieldElement,
    pub g: M_ECPoint,
    pub r: M_Bignum,
    pub h: M_Bignum,
}
#[test]
fn bindgen_test_layout_M_ECName_CustomLCF_Data() {
    const UNINIT: ::core::mem::MaybeUninit<M_ECName_CustomLCF_Data> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_ECName_CustomLCF_Data>(),
        88usize,
        concat!("Size of: ", stringify!(M_ECName_CustomLCF_Data))
    );
    assert_eq!(
        ::core::mem::align_of::<M_ECName_CustomLCF_Data>(),
        8usize,
        concat!("Alignment of ", stringify!(M_ECName_CustomLCF_Data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).F) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ECName_CustomLCF_Data),
            "::",
            stringify!(F)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).a) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ECName_CustomLCF_Data),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ECName_CustomLCF_Data),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).g) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ECName_CustomLCF_Data),
            "::",
            stringify!(g)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).r) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ECName_CustomLCF_Data),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ECName_CustomLCF_Data),
            "::",
            stringify!(h)
        )
    );
}
impl Default for M_ECName_CustomLCF_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_ECName_CustomLCF_Data {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_ECName_CustomLCF_Data {{ F: {:?}, a: {:?}, b: {:?}, g: {:?}, r: {:?}, h: {:?} }}",
            self.F, self.a, self.b, self.g, self.r, self.h
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_ECName__Data {
    pub custom: M_ECName_Custom_Data,
    pub customlcf: M_ECName_CustomLCF_Data,
}
#[test]
fn bindgen_test_layout_M_ECName__Data() {
    const UNINIT: ::core::mem::MaybeUninit<M_ECName__Data> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_ECName__Data>(),
        88usize,
        concat!("Size of: ", stringify!(M_ECName__Data))
    );
    assert_eq!(
        ::core::mem::align_of::<M_ECName__Data>(),
        8usize,
        concat!("Alignment of ", stringify!(M_ECName__Data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).custom) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ECName__Data),
            "::",
            stringify!(custom)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).customlcf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ECName__Data),
            "::",
            stringify!(customlcf)
        )
    );
}
impl Default for M_ECName__Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_ECName__Data {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_ECName__Data {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_EllipticCurve {
    pub name: M_ECName,
    pub data: M_ECName__Data,
}
#[test]
fn bindgen_test_layout_M_EllipticCurve() {
    const UNINIT: ::core::mem::MaybeUninit<M_EllipticCurve> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_EllipticCurve>(),
        96usize,
        concat!("Size of: ", stringify!(M_EllipticCurve))
    );
    assert_eq!(
        ::core::mem::align_of::<M_EllipticCurve>(),
        8usize,
        concat!("Alignment of ", stringify!(M_EllipticCurve))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EllipticCurve),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EllipticCurve),
            "::",
            stringify!(data)
        )
    );
}
impl Default for M_EllipticCurve {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_EllipticCurve {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_EllipticCurve {{ name: {:?}, data: {:?} }}",
            self.name, self.data
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_KeyType_ECPrivate_Data {
    pub curve: M_EllipticCurve,
    pub d: M_Bignum,
}
#[test]
fn bindgen_test_layout_M_KeyType_ECPrivate_Data() {
    const UNINIT: ::core::mem::MaybeUninit<M_KeyType_ECPrivate_Data> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_KeyType_ECPrivate_Data>(),
        104usize,
        concat!("Size of: ", stringify!(M_KeyType_ECPrivate_Data))
    );
    assert_eq!(
        ::core::mem::align_of::<M_KeyType_ECPrivate_Data>(),
        8usize,
        concat!("Alignment of ", stringify!(M_KeyType_ECPrivate_Data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).curve) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_ECPrivate_Data),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).d) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_ECPrivate_Data),
            "::",
            stringify!(d)
        )
    );
}
impl Default for M_KeyType_ECPrivate_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_KeyType_ECPrivate_Data {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_KeyType_ECPrivate_Data {{ curve: {:?}, d: {:?} }}",
            self.curve, self.d
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_KeyType_ECPublic_Data {
    pub curve: M_EllipticCurve,
    pub Q: M_ECPoint,
}
#[test]
fn bindgen_test_layout_M_KeyType_ECPublic_Data() {
    const UNINIT: ::core::mem::MaybeUninit<M_KeyType_ECPublic_Data> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_KeyType_ECPublic_Data>(),
        120usize,
        concat!("Size of: ", stringify!(M_KeyType_ECPublic_Data))
    );
    assert_eq!(
        ::core::mem::align_of::<M_KeyType_ECPublic_Data>(),
        8usize,
        concat!("Alignment of ", stringify!(M_KeyType_ECPublic_Data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).curve) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_ECPublic_Data),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Q) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_ECPublic_Data),
            "::",
            stringify!(Q)
        )
    );
}
impl Default for M_KeyType_ECPublic_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_KeyType_ECPublic_Data {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_KeyType_ECPublic_Data {{ curve: {:?}, Q: {:?} }}",
            self.curve, self.Q
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_KCDSAInitValues {
    pub seed: M_ByteBlock,
    pub counter: M_Word,
}
#[test]
fn bindgen_test_layout_M_KCDSAInitValues() {
    const UNINIT: ::core::mem::MaybeUninit<M_KCDSAInitValues> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_KCDSAInitValues>(),
        24usize,
        concat!("Size of: ", stringify!(M_KCDSAInitValues))
    );
    assert_eq!(
        ::core::mem::align_of::<M_KCDSAInitValues>(),
        8usize,
        concat!("Alignment of ", stringify!(M_KCDSAInitValues))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).seed) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KCDSAInitValues),
            "::",
            stringify!(seed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).counter) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KCDSAInitValues),
            "::",
            stringify!(counter)
        )
    );
}
impl Default for M_KCDSAInitValues {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_KCDSADiscreteLogGroup = M_DSADiscreteLogGroup;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_KeyType_KCDSAComm_Data {
    pub iv: M_KCDSAInitValues,
    pub dlg: M_KCDSADiscreteLogGroup,
}
#[test]
fn bindgen_test_layout_M_KeyType_KCDSAComm_Data() {
    const UNINIT: ::core::mem::MaybeUninit<M_KeyType_KCDSAComm_Data> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_KeyType_KCDSAComm_Data>(),
        48usize,
        concat!("Size of: ", stringify!(M_KeyType_KCDSAComm_Data))
    );
    assert_eq!(
        ::core::mem::align_of::<M_KeyType_KCDSAComm_Data>(),
        8usize,
        concat!("Alignment of ", stringify!(M_KeyType_KCDSAComm_Data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iv) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_KCDSAComm_Data),
            "::",
            stringify!(iv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dlg) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_KCDSAComm_Data),
            "::",
            stringify!(dlg)
        )
    );
}
impl Default for M_KeyType_KCDSAComm_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_KeyType_KCDSAPrivate_Data {
    pub dlg: M_KCDSADiscreteLogGroup,
    pub y: M_Bignum,
    pub x: M_Bignum,
}
#[test]
fn bindgen_test_layout_M_KeyType_KCDSAPrivate_Data() {
    const UNINIT: ::core::mem::MaybeUninit<M_KeyType_KCDSAPrivate_Data> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_KeyType_KCDSAPrivate_Data>(),
        40usize,
        concat!("Size of: ", stringify!(M_KeyType_KCDSAPrivate_Data))
    );
    assert_eq!(
        ::core::mem::align_of::<M_KeyType_KCDSAPrivate_Data>(),
        8usize,
        concat!("Alignment of ", stringify!(M_KeyType_KCDSAPrivate_Data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dlg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_KCDSAPrivate_Data),
            "::",
            stringify!(dlg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_KCDSAPrivate_Data),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_KCDSAPrivate_Data),
            "::",
            stringify!(x)
        )
    );
}
impl Default for M_KeyType_KCDSAPrivate_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_KeyType_KCDSAPublic_Data {
    pub dlg: M_KCDSADiscreteLogGroup,
    pub y: M_Bignum,
}
#[test]
fn bindgen_test_layout_M_KeyType_KCDSAPublic_Data() {
    const UNINIT: ::core::mem::MaybeUninit<M_KeyType_KCDSAPublic_Data> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_KeyType_KCDSAPublic_Data>(),
        32usize,
        concat!("Size of: ", stringify!(M_KeyType_KCDSAPublic_Data))
    );
    assert_eq!(
        ::core::mem::align_of::<M_KeyType_KCDSAPublic_Data>(),
        8usize,
        concat!("Alignment of ", stringify!(M_KeyType_KCDSAPublic_Data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dlg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_KCDSAPublic_Data),
            "::",
            stringify!(dlg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_KCDSAPublic_Data),
            "::",
            stringify!(y)
        )
    );
}
impl Default for M_KeyType_KCDSAPublic_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_KeyType_RSAPrivate_Data {
    pub p: M_Bignum,
    pub q: M_Bignum,
    pub dmp1: M_Bignum,
    pub dmq1: M_Bignum,
    pub iqmp: M_Bignum,
    pub e: M_Bignum,
}
#[test]
fn bindgen_test_layout_M_KeyType_RSAPrivate_Data() {
    const UNINIT: ::core::mem::MaybeUninit<M_KeyType_RSAPrivate_Data> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_KeyType_RSAPrivate_Data>(),
        48usize,
        concat!("Size of: ", stringify!(M_KeyType_RSAPrivate_Data))
    );
    assert_eq!(
        ::core::mem::align_of::<M_KeyType_RSAPrivate_Data>(),
        8usize,
        concat!("Alignment of ", stringify!(M_KeyType_RSAPrivate_Data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_RSAPrivate_Data),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).q) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_RSAPrivate_Data),
            "::",
            stringify!(q)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dmp1) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_RSAPrivate_Data),
            "::",
            stringify!(dmp1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dmq1) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_RSAPrivate_Data),
            "::",
            stringify!(dmq1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iqmp) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_RSAPrivate_Data),
            "::",
            stringify!(iqmp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).e) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_RSAPrivate_Data),
            "::",
            stringify!(e)
        )
    );
}
impl Default for M_KeyType_RSAPrivate_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_KeyType_RSAPublic_Data {
    pub e: M_Bignum,
    pub n: M_Bignum,
}
#[test]
fn bindgen_test_layout_M_KeyType_RSAPublic_Data() {
    const UNINIT: ::core::mem::MaybeUninit<M_KeyType_RSAPublic_Data> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_KeyType_RSAPublic_Data>(),
        16usize,
        concat!("Size of: ", stringify!(M_KeyType_RSAPublic_Data))
    );
    assert_eq!(
        ::core::mem::align_of::<M_KeyType_RSAPublic_Data>(),
        8usize,
        concat!("Alignment of ", stringify!(M_KeyType_RSAPublic_Data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).e) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_RSAPublic_Data),
            "::",
            stringify!(e)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_RSAPublic_Data),
            "::",
            stringify!(n)
        )
    );
}
impl Default for M_KeyType_RSAPublic_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_KeyType_Random_Data {
    pub k: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_KeyType_Random_Data() {
    const UNINIT: ::core::mem::MaybeUninit<M_KeyType_Random_Data> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_KeyType_Random_Data>(),
        16usize,
        concat!("Size of: ", stringify!(M_KeyType_Random_Data))
    );
    assert_eq!(
        ::core::mem::align_of::<M_KeyType_Random_Data>(),
        8usize,
        concat!("Alignment of ", stringify!(M_KeyType_Random_Data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).k) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_Random_Data),
            "::",
            stringify!(k)
        )
    );
}
impl Default for M_KeyType_Random_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_TUAKTOP {
    pub bytes: [::core::ffi::c_uchar; 32usize],
    pub words: [M_Word; 8usize],
}
#[test]
fn bindgen_test_layout_M_TUAKTOP() {
    const UNINIT: ::core::mem::MaybeUninit<M_TUAKTOP> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_TUAKTOP>(),
        32usize,
        concat!("Size of: ", stringify!(M_TUAKTOP))
    );
    assert_eq!(
        ::core::mem::align_of::<M_TUAKTOP>(),
        4usize,
        concat!("Alignment of ", stringify!(M_TUAKTOP))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_TUAKTOP),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).words) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_TUAKTOP),
            "::",
            stringify!(words)
        )
    );
}
impl Default for M_TUAKTOP {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_TUAKTOP {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_TUAKTOP {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_KeyType_TUAKTOP_Data {
    pub data: M_TUAKTOP,
}
#[test]
fn bindgen_test_layout_M_KeyType_TUAKTOP_Data() {
    const UNINIT: ::core::mem::MaybeUninit<M_KeyType_TUAKTOP_Data> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_KeyType_TUAKTOP_Data>(),
        32usize,
        concat!("Size of: ", stringify!(M_KeyType_TUAKTOP_Data))
    );
    assert_eq!(
        ::core::mem::align_of::<M_KeyType_TUAKTOP_Data>(),
        4usize,
        concat!("Alignment of ", stringify!(M_KeyType_TUAKTOP_Data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_TUAKTOP_Data),
            "::",
            stringify!(data)
        )
    );
}
impl Default for M_KeyType_TUAKTOP_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_KeyType_TUAKTOP_Data {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_KeyType_TUAKTOP_Data {{ data: {:?} }}", self.data)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_KeyType__Data {
    pub des: M_KeyType_DES_Data,
    pub des2: M_KeyType_DES2_Data,
    pub des3: M_KeyType_DES3_Data,
    pub dhexprivate: M_KeyType_DHExPrivate_Data,
    pub dhexpublic: M_KeyType_DHExPublic_Data,
    pub dhprivate: M_KeyType_DHPrivate_Data,
    pub dhpublic: M_KeyType_DHPublic_Data,
    pub dktemplate: M_KeyType_DKTemplate_Data,
    pub dsacomm: M_KeyType_DSAComm_Data,
    pub dsacommvariableseed: M_KeyType_DSACommVariableSeed_Data,
    pub dsaprivate: M_KeyType_DSAPrivate_Data,
    pub dsapublic: M_KeyType_DSAPublic_Data,
    pub ecprivate: M_KeyType_ECPrivate_Data,
    pub ecpublic: M_KeyType_ECPublic_Data,
    pub kcdsacomm: M_KeyType_KCDSAComm_Data,
    pub kcdsaprivate: M_KeyType_KCDSAPrivate_Data,
    pub kcdsapublic: M_KeyType_KCDSAPublic_Data,
    pub rsaprivate: M_KeyType_RSAPrivate_Data,
    pub rsapublic: M_KeyType_RSAPublic_Data,
    pub random: M_KeyType_Random_Data,
    pub tuaktop: M_KeyType_TUAKTOP_Data,
}
#[test]
fn bindgen_test_layout_M_KeyType__Data() {
    const UNINIT: ::core::mem::MaybeUninit<M_KeyType__Data> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_KeyType__Data>(),
        120usize,
        concat!("Size of: ", stringify!(M_KeyType__Data))
    );
    assert_eq!(
        ::core::mem::align_of::<M_KeyType__Data>(),
        8usize,
        concat!("Alignment of ", stringify!(M_KeyType__Data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).des) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType__Data),
            "::",
            stringify!(des)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).des2) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType__Data),
            "::",
            stringify!(des2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).des3) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType__Data),
            "::",
            stringify!(des3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dhexprivate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType__Data),
            "::",
            stringify!(dhexprivate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dhexpublic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType__Data),
            "::",
            stringify!(dhexpublic)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dhprivate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType__Data),
            "::",
            stringify!(dhprivate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dhpublic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType__Data),
            "::",
            stringify!(dhpublic)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dktemplate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType__Data),
            "::",
            stringify!(dktemplate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dsacomm) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType__Data),
            "::",
            stringify!(dsacomm)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dsacommvariableseed) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType__Data),
            "::",
            stringify!(dsacommvariableseed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dsaprivate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType__Data),
            "::",
            stringify!(dsaprivate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dsapublic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType__Data),
            "::",
            stringify!(dsapublic)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ecprivate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType__Data),
            "::",
            stringify!(ecprivate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ecpublic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType__Data),
            "::",
            stringify!(ecpublic)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kcdsacomm) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType__Data),
            "::",
            stringify!(kcdsacomm)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kcdsaprivate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType__Data),
            "::",
            stringify!(kcdsaprivate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kcdsapublic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType__Data),
            "::",
            stringify!(kcdsapublic)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rsaprivate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType__Data),
            "::",
            stringify!(rsaprivate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rsapublic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType__Data),
            "::",
            stringify!(rsapublic)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).random) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType__Data),
            "::",
            stringify!(random)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tuaktop) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType__Data),
            "::",
            stringify!(tuaktop)
        )
    );
}
impl Default for M_KeyType__Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_KeyType__Data {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_KeyType__Data {{ union }}")
    }
}
pub type M_KeyType_DHExPrivate_GenParams_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_KeyType_DHExPrivate_GenParams {
    pub flags: M_KeyType_DHExPrivate_GenParams_flags,
    pub plength: M_Word,
    pub qlength: M_Word,
    pub dlg: *mut M_DHExDiscreteLogGroup,
}
#[test]
fn bindgen_test_layout_M_KeyType_DHExPrivate_GenParams() {
    const UNINIT: ::core::mem::MaybeUninit<M_KeyType_DHExPrivate_GenParams> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_KeyType_DHExPrivate_GenParams>(),
        24usize,
        concat!("Size of: ", stringify!(M_KeyType_DHExPrivate_GenParams))
    );
    assert_eq!(
        ::core::mem::align_of::<M_KeyType_DHExPrivate_GenParams>(),
        8usize,
        concat!("Alignment of ", stringify!(M_KeyType_DHExPrivate_GenParams))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_DHExPrivate_GenParams),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).plength) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_DHExPrivate_GenParams),
            "::",
            stringify!(plength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).qlength) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_DHExPrivate_GenParams),
            "::",
            stringify!(qlength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dlg) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_DHExPrivate_GenParams),
            "::",
            stringify!(dlg)
        )
    );
}
impl Default for M_KeyType_DHExPrivate_GenParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_KeyType_DHPrivate_GenParams_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_KeyType_DHPrivate_GenParams {
    pub flags: M_KeyType_DHPrivate_GenParams_flags,
    pub plength: M_Word,
    pub xlength: M_Word,
    pub dlg: *mut M_DiscreteLogGroup,
}
#[test]
fn bindgen_test_layout_M_KeyType_DHPrivate_GenParams() {
    const UNINIT: ::core::mem::MaybeUninit<M_KeyType_DHPrivate_GenParams> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_KeyType_DHPrivate_GenParams>(),
        24usize,
        concat!("Size of: ", stringify!(M_KeyType_DHPrivate_GenParams))
    );
    assert_eq!(
        ::core::mem::align_of::<M_KeyType_DHPrivate_GenParams>(),
        8usize,
        concat!("Alignment of ", stringify!(M_KeyType_DHPrivate_GenParams))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_DHPrivate_GenParams),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).plength) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_DHPrivate_GenParams),
            "::",
            stringify!(plength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xlength) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_DHPrivate_GenParams),
            "::",
            stringify!(xlength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dlg) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_DHPrivate_GenParams),
            "::",
            stringify!(dlg)
        )
    );
}
impl Default for M_KeyType_DHPrivate_GenParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_KeyType_DSAComm_GenParams_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_KeyType_DSAComm_GenParams {
    pub flags: M_KeyType_DSAComm_GenParams_flags,
    pub lenbits: M_Word,
    pub iv: *mut M_DSAInitValues,
}
#[test]
fn bindgen_test_layout_M_KeyType_DSAComm_GenParams() {
    const UNINIT: ::core::mem::MaybeUninit<M_KeyType_DSAComm_GenParams> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_KeyType_DSAComm_GenParams>(),
        16usize,
        concat!("Size of: ", stringify!(M_KeyType_DSAComm_GenParams))
    );
    assert_eq!(
        ::core::mem::align_of::<M_KeyType_DSAComm_GenParams>(),
        8usize,
        concat!("Alignment of ", stringify!(M_KeyType_DSAComm_GenParams))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_DSAComm_GenParams),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lenbits) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_DSAComm_GenParams),
            "::",
            stringify!(lenbits)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iv) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_DSAComm_GenParams),
            "::",
            stringify!(iv)
        )
    );
}
impl Default for M_KeyType_DSAComm_GenParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_KeyType_DSACommVariableSeed_GenParams_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_KeyType_DSACommVariableSeed_GenParams {
    pub flags: M_KeyType_DSACommVariableSeed_GenParams_flags,
    pub lenbits: M_Word,
    pub iv: *mut M_DSAInitValuesVarSeed,
    pub qhash: *mut M_DSAGenerationHash,
}
#[test]
fn bindgen_test_layout_M_KeyType_DSACommVariableSeed_GenParams() {
    const UNINIT: ::core::mem::MaybeUninit<M_KeyType_DSACommVariableSeed_GenParams> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_KeyType_DSACommVariableSeed_GenParams>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(M_KeyType_DSACommVariableSeed_GenParams)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<M_KeyType_DSACommVariableSeed_GenParams>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(M_KeyType_DSACommVariableSeed_GenParams)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_DSACommVariableSeed_GenParams),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lenbits) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_DSACommVariableSeed_GenParams),
            "::",
            stringify!(lenbits)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iv) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_DSACommVariableSeed_GenParams),
            "::",
            stringify!(iv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).qhash) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_DSACommVariableSeed_GenParams),
            "::",
            stringify!(qhash)
        )
    );
}
impl Default for M_KeyType_DSACommVariableSeed_GenParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_KeyType_DSAPrivate_GenParams_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_KeyType_DSAPrivate_GenParams {
    pub flags: M_KeyType_DSAPrivate_GenParams_flags,
    pub lenbits: M_Word,
    pub dlg: *mut M_DSADiscreteLogGroup,
    pub qhash: *mut M_DSAGenerationHash,
}
#[test]
fn bindgen_test_layout_M_KeyType_DSAPrivate_GenParams() {
    const UNINIT: ::core::mem::MaybeUninit<M_KeyType_DSAPrivate_GenParams> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_KeyType_DSAPrivate_GenParams>(),
        24usize,
        concat!("Size of: ", stringify!(M_KeyType_DSAPrivate_GenParams))
    );
    assert_eq!(
        ::core::mem::align_of::<M_KeyType_DSAPrivate_GenParams>(),
        8usize,
        concat!("Alignment of ", stringify!(M_KeyType_DSAPrivate_GenParams))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_DSAPrivate_GenParams),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lenbits) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_DSAPrivate_GenParams),
            "::",
            stringify!(lenbits)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dlg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_DSAPrivate_GenParams),
            "::",
            stringify!(dlg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).qhash) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_DSAPrivate_GenParams),
            "::",
            stringify!(qhash)
        )
    );
}
impl Default for M_KeyType_DSAPrivate_GenParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_KeyType_ECPrivate_GenParams {
    pub curve: M_EllipticCurve,
}
#[test]
fn bindgen_test_layout_M_KeyType_ECPrivate_GenParams() {
    const UNINIT: ::core::mem::MaybeUninit<M_KeyType_ECPrivate_GenParams> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_KeyType_ECPrivate_GenParams>(),
        96usize,
        concat!("Size of: ", stringify!(M_KeyType_ECPrivate_GenParams))
    );
    assert_eq!(
        ::core::mem::align_of::<M_KeyType_ECPrivate_GenParams>(),
        8usize,
        concat!("Alignment of ", stringify!(M_KeyType_ECPrivate_GenParams))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).curve) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_ECPrivate_GenParams),
            "::",
            stringify!(curve)
        )
    );
}
impl Default for M_KeyType_ECPrivate_GenParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_KeyType_ECPrivate_GenParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_KeyType_ECPrivate_GenParams {{ curve: {:?} }}",
            self.curve
        )
    }
}
pub type M_KeyType_KCDSAComm_GenParams_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_KeyType_KCDSAComm_GenParams {
    pub flags: M_KeyType_KCDSAComm_GenParams_flags,
    pub plen: M_Word,
    pub qlen: M_Word,
    pub iv: *mut M_KCDSAInitValues,
}
#[test]
fn bindgen_test_layout_M_KeyType_KCDSAComm_GenParams() {
    const UNINIT: ::core::mem::MaybeUninit<M_KeyType_KCDSAComm_GenParams> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_KeyType_KCDSAComm_GenParams>(),
        24usize,
        concat!("Size of: ", stringify!(M_KeyType_KCDSAComm_GenParams))
    );
    assert_eq!(
        ::core::mem::align_of::<M_KeyType_KCDSAComm_GenParams>(),
        8usize,
        concat!("Alignment of ", stringify!(M_KeyType_KCDSAComm_GenParams))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_KCDSAComm_GenParams),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).plen) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_KCDSAComm_GenParams),
            "::",
            stringify!(plen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).qlen) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_KCDSAComm_GenParams),
            "::",
            stringify!(qlen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iv) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_KCDSAComm_GenParams),
            "::",
            stringify!(iv)
        )
    );
}
impl Default for M_KeyType_KCDSAComm_GenParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_KeyType_KCDSAPrivate_GenParams_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_KeyType_KCDSAPrivate_GenParams {
    pub flags: M_KeyType_KCDSAPrivate_GenParams_flags,
    pub plen: M_Word,
    pub qlen: M_Word,
    pub dlg: *mut M_KCDSADiscreteLogGroup,
}
#[test]
fn bindgen_test_layout_M_KeyType_KCDSAPrivate_GenParams() {
    const UNINIT: ::core::mem::MaybeUninit<M_KeyType_KCDSAPrivate_GenParams> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_KeyType_KCDSAPrivate_GenParams>(),
        24usize,
        concat!("Size of: ", stringify!(M_KeyType_KCDSAPrivate_GenParams))
    );
    assert_eq!(
        ::core::mem::align_of::<M_KeyType_KCDSAPrivate_GenParams>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(M_KeyType_KCDSAPrivate_GenParams)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_KCDSAPrivate_GenParams),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).plen) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_KCDSAPrivate_GenParams),
            "::",
            stringify!(plen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).qlen) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_KCDSAPrivate_GenParams),
            "::",
            stringify!(qlen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dlg) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_KCDSAPrivate_GenParams),
            "::",
            stringify!(dlg)
        )
    );
}
impl Default for M_KeyType_KCDSAPrivate_GenParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_KeyType_RSAPrivate_GenParams_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_KeyType_RSAPrivate_GenParams {
    pub flags: M_KeyType_RSAPrivate_GenParams_flags,
    pub lenbits: M_Word,
    pub given_e: *mut M_Bignum,
    pub nchecks: *mut M_Word,
}
#[test]
fn bindgen_test_layout_M_KeyType_RSAPrivate_GenParams() {
    const UNINIT: ::core::mem::MaybeUninit<M_KeyType_RSAPrivate_GenParams> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_KeyType_RSAPrivate_GenParams>(),
        24usize,
        concat!("Size of: ", stringify!(M_KeyType_RSAPrivate_GenParams))
    );
    assert_eq!(
        ::core::mem::align_of::<M_KeyType_RSAPrivate_GenParams>(),
        8usize,
        concat!("Alignment of ", stringify!(M_KeyType_RSAPrivate_GenParams))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_RSAPrivate_GenParams),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lenbits) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_RSAPrivate_GenParams),
            "::",
            stringify!(lenbits)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).given_e) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_RSAPrivate_GenParams),
            "::",
            stringify!(given_e)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nchecks) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_RSAPrivate_GenParams),
            "::",
            stringify!(nchecks)
        )
    );
}
impl Default for M_KeyType_RSAPrivate_GenParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_KeyType_Random_GenParams {
    pub lenbytes: M_Word,
}
#[test]
fn bindgen_test_layout_M_KeyType_Random_GenParams() {
    const UNINIT: ::core::mem::MaybeUninit<M_KeyType_Random_GenParams> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_KeyType_Random_GenParams>(),
        4usize,
        concat!("Size of: ", stringify!(M_KeyType_Random_GenParams))
    );
    assert_eq!(
        ::core::mem::align_of::<M_KeyType_Random_GenParams>(),
        4usize,
        concat!("Alignment of ", stringify!(M_KeyType_Random_GenParams))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lenbytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_Random_GenParams),
            "::",
            stringify!(lenbytes)
        )
    );
}
pub type M_KeyType_Wrapped_GenParams_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_KeyType_Wrapped_GenParams {
    pub flags: M_KeyType_Wrapped_GenParams_flags,
    pub length: M_Word,
}
#[test]
fn bindgen_test_layout_M_KeyType_Wrapped_GenParams() {
    const UNINIT: ::core::mem::MaybeUninit<M_KeyType_Wrapped_GenParams> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_KeyType_Wrapped_GenParams>(),
        8usize,
        concat!("Size of: ", stringify!(M_KeyType_Wrapped_GenParams))
    );
    assert_eq!(
        ::core::mem::align_of::<M_KeyType_Wrapped_GenParams>(),
        4usize,
        concat!("Alignment of ", stringify!(M_KeyType_Wrapped_GenParams))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_Wrapped_GenParams),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType_Wrapped_GenParams),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_KeyType__GenParams {
    pub dhexprivate: M_KeyType_DHExPrivate_GenParams,
    pub dhprivate: M_KeyType_DHPrivate_GenParams,
    pub dsacomm: M_KeyType_DSAComm_GenParams,
    pub dsacommvariableseed: M_KeyType_DSACommVariableSeed_GenParams,
    pub dsaprivate: M_KeyType_DSAPrivate_GenParams,
    pub ecprivate: M_KeyType_ECPrivate_GenParams,
    pub kcdsacomm: M_KeyType_KCDSAComm_GenParams,
    pub kcdsaprivate: M_KeyType_KCDSAPrivate_GenParams,
    pub rsaprivate: M_KeyType_RSAPrivate_GenParams,
    pub random: M_KeyType_Random_GenParams,
    pub wrapped: M_KeyType_Wrapped_GenParams,
}
#[test]
fn bindgen_test_layout_M_KeyType__GenParams() {
    const UNINIT: ::core::mem::MaybeUninit<M_KeyType__GenParams> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_KeyType__GenParams>(),
        96usize,
        concat!("Size of: ", stringify!(M_KeyType__GenParams))
    );
    assert_eq!(
        ::core::mem::align_of::<M_KeyType__GenParams>(),
        8usize,
        concat!("Alignment of ", stringify!(M_KeyType__GenParams))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dhexprivate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType__GenParams),
            "::",
            stringify!(dhexprivate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dhprivate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType__GenParams),
            "::",
            stringify!(dhprivate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dsacomm) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType__GenParams),
            "::",
            stringify!(dsacomm)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dsacommvariableseed) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType__GenParams),
            "::",
            stringify!(dsacommvariableseed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dsaprivate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType__GenParams),
            "::",
            stringify!(dsaprivate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ecprivate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType__GenParams),
            "::",
            stringify!(ecprivate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kcdsacomm) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType__GenParams),
            "::",
            stringify!(kcdsacomm)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kcdsaprivate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType__GenParams),
            "::",
            stringify!(kcdsaprivate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rsaprivate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType__GenParams),
            "::",
            stringify!(rsaprivate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).random) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType__GenParams),
            "::",
            stringify!(random)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wrapped) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyType__GenParams),
            "::",
            stringify!(wrapped)
        )
    );
}
impl Default for M_KeyType__GenParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_KeyType__GenParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_KeyType__GenParams {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_KeyData {
    pub type_: M_KeyType,
    pub data: M_KeyType__Data,
}
#[test]
fn bindgen_test_layout_M_KeyData() {
    const UNINIT: ::core::mem::MaybeUninit<M_KeyData> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_KeyData>(),
        128usize,
        concat!("Size of: ", stringify!(M_KeyData))
    );
    assert_eq!(
        ::core::mem::align_of::<M_KeyData>(),
        8usize,
        concat!("Alignment of ", stringify!(M_KeyData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyData),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyData),
            "::",
            stringify!(data)
        )
    );
}
impl Default for M_KeyData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_KeyData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_KeyData {{ type: {:?}, data: {:?} }}",
            self.type_, self.data
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Mech_ArcFourpNONE_Cipher {
    pub cipher: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_Mech_ArcFourpNONE_Cipher() {
    const UNINIT: ::core::mem::MaybeUninit<M_Mech_ArcFourpNONE_Cipher> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Mech_ArcFourpNONE_Cipher>(),
        16usize,
        concat!("Size of: ", stringify!(M_Mech_ArcFourpNONE_Cipher))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Mech_ArcFourpNONE_Cipher>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Mech_ArcFourpNONE_Cipher))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cipher) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech_ArcFourpNONE_Cipher),
            "::",
            stringify!(cipher)
        )
    );
}
impl Default for M_Mech_ArcFourpNONE_Cipher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Mech_BlobCrypt_Cipher {
    pub cipher: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_Mech_BlobCrypt_Cipher() {
    const UNINIT: ::core::mem::MaybeUninit<M_Mech_BlobCrypt_Cipher> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Mech_BlobCrypt_Cipher>(),
        16usize,
        concat!("Size of: ", stringify!(M_Mech_BlobCrypt_Cipher))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Mech_BlobCrypt_Cipher>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Mech_BlobCrypt_Cipher))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cipher) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech_BlobCrypt_Cipher),
            "::",
            stringify!(cipher)
        )
    );
}
impl Default for M_Mech_BlobCrypt_Cipher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Mech_DHExKeyExchange_Cipher {
    pub gx: M_Bignum,
}
#[test]
fn bindgen_test_layout_M_Mech_DHExKeyExchange_Cipher() {
    const UNINIT: ::core::mem::MaybeUninit<M_Mech_DHExKeyExchange_Cipher> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Mech_DHExKeyExchange_Cipher>(),
        8usize,
        concat!("Size of: ", stringify!(M_Mech_DHExKeyExchange_Cipher))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Mech_DHExKeyExchange_Cipher>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Mech_DHExKeyExchange_Cipher))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech_DHExKeyExchange_Cipher),
            "::",
            stringify!(gx)
        )
    );
}
impl Default for M_Mech_DHExKeyExchange_Cipher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Mech_DHKeyExchange_Cipher {
    pub gx: M_Bignum,
}
#[test]
fn bindgen_test_layout_M_Mech_DHKeyExchange_Cipher() {
    const UNINIT: ::core::mem::MaybeUninit<M_Mech_DHKeyExchange_Cipher> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Mech_DHKeyExchange_Cipher>(),
        8usize,
        concat!("Size of: ", stringify!(M_Mech_DHKeyExchange_Cipher))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Mech_DHKeyExchange_Cipher>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Mech_DHKeyExchange_Cipher))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech_DHKeyExchange_Cipher),
            "::",
            stringify!(gx)
        )
    );
}
impl Default for M_Mech_DHKeyExchange_Cipher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Mech_DLIESe3DEShSHA1_Cipher {
    pub cipher: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_Mech_DLIESe3DEShSHA1_Cipher() {
    const UNINIT: ::core::mem::MaybeUninit<M_Mech_DLIESe3DEShSHA1_Cipher> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Mech_DLIESe3DEShSHA1_Cipher>(),
        16usize,
        concat!("Size of: ", stringify!(M_Mech_DLIESe3DEShSHA1_Cipher))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Mech_DLIESe3DEShSHA1_Cipher>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Mech_DLIESe3DEShSHA1_Cipher))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cipher) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech_DLIESe3DEShSHA1_Cipher),
            "::",
            stringify!(cipher)
        )
    );
}
impl Default for M_Mech_DLIESe3DEShSHA1_Cipher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Mech_DSA_Cipher {
    pub r: M_Bignum,
    pub s: M_Bignum,
}
#[test]
fn bindgen_test_layout_M_Mech_DSA_Cipher() {
    const UNINIT: ::core::mem::MaybeUninit<M_Mech_DSA_Cipher> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Mech_DSA_Cipher>(),
        16usize,
        concat!("Size of: ", stringify!(M_Mech_DSA_Cipher))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Mech_DSA_Cipher>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Mech_DSA_Cipher))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).r) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech_DSA_Cipher),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).s) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech_DSA_Cipher),
            "::",
            stringify!(s)
        )
    );
}
impl Default for M_Mech_DSA_Cipher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Mech_ECDHKeyExchange_Cipher {
    pub gd: M_ECPoint,
}
#[test]
fn bindgen_test_layout_M_Mech_ECDHKeyExchange_Cipher() {
    const UNINIT: ::core::mem::MaybeUninit<M_Mech_ECDHKeyExchange_Cipher> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Mech_ECDHKeyExchange_Cipher>(),
        24usize,
        concat!("Size of: ", stringify!(M_Mech_ECDHKeyExchange_Cipher))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Mech_ECDHKeyExchange_Cipher>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Mech_ECDHKeyExchange_Cipher))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech_ECDHKeyExchange_Cipher),
            "::",
            stringify!(gd)
        )
    );
}
impl Default for M_Mech_ECDHKeyExchange_Cipher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Mech_ECDSA_Cipher {
    pub r: M_Bignum,
    pub s: M_Bignum,
}
#[test]
fn bindgen_test_layout_M_Mech_ECDSA_Cipher() {
    const UNINIT: ::core::mem::MaybeUninit<M_Mech_ECDSA_Cipher> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Mech_ECDSA_Cipher>(),
        16usize,
        concat!("Size of: ", stringify!(M_Mech_ECDSA_Cipher))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Mech_ECDSA_Cipher>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Mech_ECDSA_Cipher))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).r) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech_ECDSA_Cipher),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).s) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech_ECDSA_Cipher),
            "::",
            stringify!(s)
        )
    );
}
impl Default for M_Mech_ECDSA_Cipher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Mech_Ed25519ph_Cipher {
    pub cipher: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_Mech_Ed25519ph_Cipher() {
    const UNINIT: ::core::mem::MaybeUninit<M_Mech_Ed25519ph_Cipher> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Mech_Ed25519ph_Cipher>(),
        16usize,
        concat!("Size of: ", stringify!(M_Mech_Ed25519ph_Cipher))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Mech_Ed25519ph_Cipher>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Mech_Ed25519ph_Cipher))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cipher) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech_Ed25519ph_Cipher),
            "::",
            stringify!(cipher)
        )
    );
}
impl Default for M_Mech_Ed25519ph_Cipher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Mech_ElGamal_Cipher {
    pub a: M_Bignum,
    pub b: M_Bignum,
}
#[test]
fn bindgen_test_layout_M_Mech_ElGamal_Cipher() {
    const UNINIT: ::core::mem::MaybeUninit<M_Mech_ElGamal_Cipher> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Mech_ElGamal_Cipher>(),
        16usize,
        concat!("Size of: ", stringify!(M_Mech_ElGamal_Cipher))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Mech_ElGamal_Cipher>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Mech_ElGamal_Cipher))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).a) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech_ElGamal_Cipher),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech_ElGamal_Cipher),
            "::",
            stringify!(b)
        )
    );
}
impl Default for M_Mech_ElGamal_Cipher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Mech_Generic128_Cipher {
    pub cipher: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_Mech_Generic128_Cipher() {
    const UNINIT: ::core::mem::MaybeUninit<M_Mech_Generic128_Cipher> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Mech_Generic128_Cipher>(),
        16usize,
        concat!("Size of: ", stringify!(M_Mech_Generic128_Cipher))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Mech_Generic128_Cipher>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Mech_Generic128_Cipher))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cipher) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech_Generic128_Cipher),
            "::",
            stringify!(cipher)
        )
    );
}
impl Default for M_Mech_Generic128_Cipher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_Block128 {
    pub bytes: [::core::ffi::c_uchar; 16usize],
    pub words: [M_Word; 4usize],
}
#[test]
fn bindgen_test_layout_M_Block128() {
    const UNINIT: ::core::mem::MaybeUninit<M_Block128> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Block128>(),
        16usize,
        concat!("Size of: ", stringify!(M_Block128))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Block128>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Block128))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Block128),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).words) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Block128),
            "::",
            stringify!(words)
        )
    );
}
impl Default for M_Block128 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Block128 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Block128 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Mech_Generic128MAC_Cipher {
    pub mac: M_Block128,
}
#[test]
fn bindgen_test_layout_M_Mech_Generic128MAC_Cipher() {
    const UNINIT: ::core::mem::MaybeUninit<M_Mech_Generic128MAC_Cipher> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Mech_Generic128MAC_Cipher>(),
        16usize,
        concat!("Size of: ", stringify!(M_Mech_Generic128MAC_Cipher))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Mech_Generic128MAC_Cipher>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Mech_Generic128MAC_Cipher))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mac) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech_Generic128MAC_Cipher),
            "::",
            stringify!(mac)
        )
    );
}
impl Default for M_Mech_Generic128MAC_Cipher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Mech_Generic128MAC_Cipher {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Mech_Generic128MAC_Cipher {{ mac: {:?} }}", self.mac)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Mech_Generic192_Cipher {
    pub cipher: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_Mech_Generic192_Cipher() {
    const UNINIT: ::core::mem::MaybeUninit<M_Mech_Generic192_Cipher> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Mech_Generic192_Cipher>(),
        16usize,
        concat!("Size of: ", stringify!(M_Mech_Generic192_Cipher))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Mech_Generic192_Cipher>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Mech_Generic192_Cipher))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cipher) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech_Generic192_Cipher),
            "::",
            stringify!(cipher)
        )
    );
}
impl Default for M_Mech_Generic192_Cipher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Mech_Generic256_Cipher {
    pub cipher: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_Mech_Generic256_Cipher() {
    const UNINIT: ::core::mem::MaybeUninit<M_Mech_Generic256_Cipher> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Mech_Generic256_Cipher>(),
        16usize,
        concat!("Size of: ", stringify!(M_Mech_Generic256_Cipher))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Mech_Generic256_Cipher>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Mech_Generic256_Cipher))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cipher) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech_Generic256_Cipher),
            "::",
            stringify!(cipher)
        )
    );
}
impl Default for M_Mech_Generic256_Cipher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Mech_Generic64_Cipher {
    pub cipher: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_Mech_Generic64_Cipher() {
    const UNINIT: ::core::mem::MaybeUninit<M_Mech_Generic64_Cipher> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Mech_Generic64_Cipher>(),
        16usize,
        concat!("Size of: ", stringify!(M_Mech_Generic64_Cipher))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Mech_Generic64_Cipher>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Mech_Generic64_Cipher))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cipher) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech_Generic64_Cipher),
            "::",
            stringify!(cipher)
        )
    );
}
impl Default for M_Mech_Generic64_Cipher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_Block64 {
    pub bytes: [::core::ffi::c_uchar; 8usize],
    pub words: [M_Word; 2usize],
}
#[test]
fn bindgen_test_layout_M_Block64() {
    const UNINIT: ::core::mem::MaybeUninit<M_Block64> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Block64>(),
        8usize,
        concat!("Size of: ", stringify!(M_Block64))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Block64>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Block64))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Block64),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).words) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Block64),
            "::",
            stringify!(words)
        )
    );
}
impl Default for M_Block64 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Block64 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Block64 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Mech_Generic64MAC_Cipher {
    pub mac: M_Block64,
}
#[test]
fn bindgen_test_layout_M_Mech_Generic64MAC_Cipher() {
    const UNINIT: ::core::mem::MaybeUninit<M_Mech_Generic64MAC_Cipher> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Mech_Generic64MAC_Cipher>(),
        8usize,
        concat!("Size of: ", stringify!(M_Mech_Generic64MAC_Cipher))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Mech_Generic64MAC_Cipher>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Mech_Generic64MAC_Cipher))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mac) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech_Generic64MAC_Cipher),
            "::",
            stringify!(mac)
        )
    );
}
impl Default for M_Mech_Generic64MAC_Cipher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Mech_Generic64MAC_Cipher {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Mech_Generic64MAC_Cipher {{ mac: {:?} }}", self.mac)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Mech_GenericGCM128_Cipher {
    pub cipher: M_ByteBlock,
    pub tag: M_Block128,
}
#[test]
fn bindgen_test_layout_M_Mech_GenericGCM128_Cipher() {
    const UNINIT: ::core::mem::MaybeUninit<M_Mech_GenericGCM128_Cipher> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Mech_GenericGCM128_Cipher>(),
        32usize,
        concat!("Size of: ", stringify!(M_Mech_GenericGCM128_Cipher))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Mech_GenericGCM128_Cipher>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Mech_GenericGCM128_Cipher))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cipher) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech_GenericGCM128_Cipher),
            "::",
            stringify!(cipher)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tag) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech_GenericGCM128_Cipher),
            "::",
            stringify!(tag)
        )
    );
}
impl Default for M_Mech_GenericGCM128_Cipher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Mech_GenericGCM128_Cipher {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Mech_GenericGCM128_Cipher {{ cipher: {:?}, tag: {:?} }}",
            self.cipher, self.tag
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Mech_HAS160Hash_Cipher {
    pub h: M_Hash20,
}
#[test]
fn bindgen_test_layout_M_Mech_HAS160Hash_Cipher() {
    const UNINIT: ::core::mem::MaybeUninit<M_Mech_HAS160Hash_Cipher> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Mech_HAS160Hash_Cipher>(),
        20usize,
        concat!("Size of: ", stringify!(M_Mech_HAS160Hash_Cipher))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Mech_HAS160Hash_Cipher>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Mech_HAS160Hash_Cipher))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech_HAS160Hash_Cipher),
            "::",
            stringify!(h)
        )
    );
}
impl Default for M_Mech_HAS160Hash_Cipher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Mech_HAS160Hash_Cipher {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Mech_HAS160Hash_Cipher {{ h: {:?} }}", self.h)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Mech_Imech_Cipher {
    pub c: M_ByteBlock,
    pub len: M_Word,
}
#[test]
fn bindgen_test_layout_M_Mech_Imech_Cipher() {
    const UNINIT: ::core::mem::MaybeUninit<M_Mech_Imech_Cipher> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Mech_Imech_Cipher>(),
        24usize,
        concat!("Size of: ", stringify!(M_Mech_Imech_Cipher))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Mech_Imech_Cipher>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Mech_Imech_Cipher))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).c) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech_Imech_Cipher),
            "::",
            stringify!(c)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech_Imech_Cipher),
            "::",
            stringify!(len)
        )
    );
}
impl Default for M_Mech_Imech_Cipher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Mech_KCDSAHAS160_Cipher {
    pub r: M_ByteBlock,
    pub s: M_Bignum,
}
#[test]
fn bindgen_test_layout_M_Mech_KCDSAHAS160_Cipher() {
    const UNINIT: ::core::mem::MaybeUninit<M_Mech_KCDSAHAS160_Cipher> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Mech_KCDSAHAS160_Cipher>(),
        24usize,
        concat!("Size of: ", stringify!(M_Mech_KCDSAHAS160_Cipher))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Mech_KCDSAHAS160_Cipher>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Mech_KCDSAHAS160_Cipher))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).r) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech_KCDSAHAS160_Cipher),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).s) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech_KCDSAHAS160_Cipher),
            "::",
            stringify!(s)
        )
    );
}
impl Default for M_Mech_KCDSAHAS160_Cipher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Mech_MD5Hash_Cipher {
    pub h: M_Hash16,
}
#[test]
fn bindgen_test_layout_M_Mech_MD5Hash_Cipher() {
    const UNINIT: ::core::mem::MaybeUninit<M_Mech_MD5Hash_Cipher> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Mech_MD5Hash_Cipher>(),
        16usize,
        concat!("Size of: ", stringify!(M_Mech_MD5Hash_Cipher))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Mech_MD5Hash_Cipher>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Mech_MD5Hash_Cipher))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech_MD5Hash_Cipher),
            "::",
            stringify!(h)
        )
    );
}
impl Default for M_Mech_MD5Hash_Cipher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Mech_MD5Hash_Cipher {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Mech_MD5Hash_Cipher {{ h: {:?} }}", self.h)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Mech_RIPEMD160Hash_Cipher {
    pub h: M_Hash20,
}
#[test]
fn bindgen_test_layout_M_Mech_RIPEMD160Hash_Cipher() {
    const UNINIT: ::core::mem::MaybeUninit<M_Mech_RIPEMD160Hash_Cipher> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Mech_RIPEMD160Hash_Cipher>(),
        20usize,
        concat!("Size of: ", stringify!(M_Mech_RIPEMD160Hash_Cipher))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Mech_RIPEMD160Hash_Cipher>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Mech_RIPEMD160Hash_Cipher))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech_RIPEMD160Hash_Cipher),
            "::",
            stringify!(h)
        )
    );
}
impl Default for M_Mech_RIPEMD160Hash_Cipher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Mech_RIPEMD160Hash_Cipher {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Mech_RIPEMD160Hash_Cipher {{ h: {:?} }}", self.h)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Mech_RSApPKCS1_Cipher {
    pub m: M_Bignum,
}
#[test]
fn bindgen_test_layout_M_Mech_RSApPKCS1_Cipher() {
    const UNINIT: ::core::mem::MaybeUninit<M_Mech_RSApPKCS1_Cipher> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Mech_RSApPKCS1_Cipher>(),
        8usize,
        concat!("Size of: ", stringify!(M_Mech_RSApPKCS1_Cipher))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Mech_RSApPKCS1_Cipher>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Mech_RSApPKCS1_Cipher))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech_RSApPKCS1_Cipher),
            "::",
            stringify!(m)
        )
    );
}
impl Default for M_Mech_RSApPKCS1_Cipher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Mech_RSApPKCS1pPKCS11_Cipher {
    pub cipher: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_Mech_RSApPKCS1pPKCS11_Cipher() {
    const UNINIT: ::core::mem::MaybeUninit<M_Mech_RSApPKCS1pPKCS11_Cipher> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Mech_RSApPKCS1pPKCS11_Cipher>(),
        16usize,
        concat!("Size of: ", stringify!(M_Mech_RSApPKCS1pPKCS11_Cipher))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Mech_RSApPKCS1pPKCS11_Cipher>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Mech_RSApPKCS1pPKCS11_Cipher))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cipher) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech_RSApPKCS1pPKCS11_Cipher),
            "::",
            stringify!(cipher)
        )
    );
}
impl Default for M_Mech_RSApPKCS1pPKCS11_Cipher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Mech_SHA1Hash_Cipher {
    pub h: M_Hash20,
}
#[test]
fn bindgen_test_layout_M_Mech_SHA1Hash_Cipher() {
    const UNINIT: ::core::mem::MaybeUninit<M_Mech_SHA1Hash_Cipher> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Mech_SHA1Hash_Cipher>(),
        20usize,
        concat!("Size of: ", stringify!(M_Mech_SHA1Hash_Cipher))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Mech_SHA1Hash_Cipher>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Mech_SHA1Hash_Cipher))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech_SHA1Hash_Cipher),
            "::",
            stringify!(h)
        )
    );
}
impl Default for M_Mech_SHA1Hash_Cipher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Mech_SHA1Hash_Cipher {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Mech_SHA1Hash_Cipher {{ h: {:?} }}", self.h)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Mech_SHA224Hash_Cipher {
    pub h: M_Hash28,
}
#[test]
fn bindgen_test_layout_M_Mech_SHA224Hash_Cipher() {
    const UNINIT: ::core::mem::MaybeUninit<M_Mech_SHA224Hash_Cipher> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Mech_SHA224Hash_Cipher>(),
        28usize,
        concat!("Size of: ", stringify!(M_Mech_SHA224Hash_Cipher))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Mech_SHA224Hash_Cipher>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Mech_SHA224Hash_Cipher))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech_SHA224Hash_Cipher),
            "::",
            stringify!(h)
        )
    );
}
impl Default for M_Mech_SHA224Hash_Cipher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Mech_SHA224Hash_Cipher {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Mech_SHA224Hash_Cipher {{ h: {:?} }}", self.h)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Mech_SHA256Hash_Cipher {
    pub h: M_Hash32,
}
#[test]
fn bindgen_test_layout_M_Mech_SHA256Hash_Cipher() {
    const UNINIT: ::core::mem::MaybeUninit<M_Mech_SHA256Hash_Cipher> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Mech_SHA256Hash_Cipher>(),
        32usize,
        concat!("Size of: ", stringify!(M_Mech_SHA256Hash_Cipher))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Mech_SHA256Hash_Cipher>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Mech_SHA256Hash_Cipher))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech_SHA256Hash_Cipher),
            "::",
            stringify!(h)
        )
    );
}
impl Default for M_Mech_SHA256Hash_Cipher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Mech_SHA256Hash_Cipher {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Mech_SHA256Hash_Cipher {{ h: {:?} }}", self.h)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Mech_SHA384Hash_Cipher {
    pub h: M_Hash48,
}
#[test]
fn bindgen_test_layout_M_Mech_SHA384Hash_Cipher() {
    const UNINIT: ::core::mem::MaybeUninit<M_Mech_SHA384Hash_Cipher> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Mech_SHA384Hash_Cipher>(),
        48usize,
        concat!("Size of: ", stringify!(M_Mech_SHA384Hash_Cipher))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Mech_SHA384Hash_Cipher>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Mech_SHA384Hash_Cipher))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech_SHA384Hash_Cipher),
            "::",
            stringify!(h)
        )
    );
}
impl Default for M_Mech_SHA384Hash_Cipher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Mech_SHA384Hash_Cipher {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Mech_SHA384Hash_Cipher {{ h: {:?} }}", self.h)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Mech_SHA512Hash_Cipher {
    pub h: M_Hash64,
}
#[test]
fn bindgen_test_layout_M_Mech_SHA512Hash_Cipher() {
    const UNINIT: ::core::mem::MaybeUninit<M_Mech_SHA512Hash_Cipher> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Mech_SHA512Hash_Cipher>(),
        64usize,
        concat!("Size of: ", stringify!(M_Mech_SHA512Hash_Cipher))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Mech_SHA512Hash_Cipher>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Mech_SHA512Hash_Cipher))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech_SHA512Hash_Cipher),
            "::",
            stringify!(h)
        )
    );
}
impl Default for M_Mech_SHA512Hash_Cipher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Mech_SHA512Hash_Cipher {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Mech_SHA512Hash_Cipher {{ h: {:?} }}", self.h)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Mech_TigerHash_Cipher {
    pub h: M_Hash24,
}
#[test]
fn bindgen_test_layout_M_Mech_TigerHash_Cipher() {
    const UNINIT: ::core::mem::MaybeUninit<M_Mech_TigerHash_Cipher> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Mech_TigerHash_Cipher>(),
        24usize,
        concat!("Size of: ", stringify!(M_Mech_TigerHash_Cipher))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Mech_TigerHash_Cipher>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Mech_TigerHash_Cipher))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech_TigerHash_Cipher),
            "::",
            stringify!(h)
        )
    );
}
impl Default for M_Mech_TigerHash_Cipher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Mech_TigerHash_Cipher {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Mech_TigerHash_Cipher {{ h: {:?} }}", self.h)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_Mech__Cipher {
    pub arcfourpnone: M_Mech_ArcFourpNONE_Cipher,
    pub blobcrypt: M_Mech_BlobCrypt_Cipher,
    pub dhexkeyexchange: M_Mech_DHExKeyExchange_Cipher,
    pub dhkeyexchange: M_Mech_DHKeyExchange_Cipher,
    pub dliese3deshsha1: M_Mech_DLIESe3DEShSHA1_Cipher,
    pub dsa: M_Mech_DSA_Cipher,
    pub ecdhkeyexchange: M_Mech_ECDHKeyExchange_Cipher,
    pub ecdsa: M_Mech_ECDSA_Cipher,
    pub ed25519ph: M_Mech_Ed25519ph_Cipher,
    pub elgamal: M_Mech_ElGamal_Cipher,
    pub generic128: M_Mech_Generic128_Cipher,
    pub generic128mac: M_Mech_Generic128MAC_Cipher,
    pub generic192: M_Mech_Generic192_Cipher,
    pub generic256: M_Mech_Generic256_Cipher,
    pub generic64: M_Mech_Generic64_Cipher,
    pub generic64mac: M_Mech_Generic64MAC_Cipher,
    pub genericgcm128: M_Mech_GenericGCM128_Cipher,
    pub has160hash: M_Mech_HAS160Hash_Cipher,
    pub imech: M_Mech_Imech_Cipher,
    pub kcdsahas160: M_Mech_KCDSAHAS160_Cipher,
    pub md5hash: M_Mech_MD5Hash_Cipher,
    pub ripemd160hash: M_Mech_RIPEMD160Hash_Cipher,
    pub rsappkcs1: M_Mech_RSApPKCS1_Cipher,
    pub rsappkcs1ppkcs11: M_Mech_RSApPKCS1pPKCS11_Cipher,
    pub sha1hash: M_Mech_SHA1Hash_Cipher,
    pub sha224hash: M_Mech_SHA224Hash_Cipher,
    pub sha256hash: M_Mech_SHA256Hash_Cipher,
    pub sha384hash: M_Mech_SHA384Hash_Cipher,
    pub sha512hash: M_Mech_SHA512Hash_Cipher,
    pub tigerhash: M_Mech_TigerHash_Cipher,
}
#[test]
fn bindgen_test_layout_M_Mech__Cipher() {
    const UNINIT: ::core::mem::MaybeUninit<M_Mech__Cipher> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Mech__Cipher>(),
        64usize,
        concat!("Size of: ", stringify!(M_Mech__Cipher))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Mech__Cipher>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Mech__Cipher))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).arcfourpnone) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech__Cipher),
            "::",
            stringify!(arcfourpnone)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).blobcrypt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech__Cipher),
            "::",
            stringify!(blobcrypt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dhexkeyexchange) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech__Cipher),
            "::",
            stringify!(dhexkeyexchange)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dhkeyexchange) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech__Cipher),
            "::",
            stringify!(dhkeyexchange)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dliese3deshsha1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech__Cipher),
            "::",
            stringify!(dliese3deshsha1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dsa) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech__Cipher),
            "::",
            stringify!(dsa)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ecdhkeyexchange) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech__Cipher),
            "::",
            stringify!(ecdhkeyexchange)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ecdsa) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech__Cipher),
            "::",
            stringify!(ecdsa)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ed25519ph) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech__Cipher),
            "::",
            stringify!(ed25519ph)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).elgamal) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech__Cipher),
            "::",
            stringify!(elgamal)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).generic128) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech__Cipher),
            "::",
            stringify!(generic128)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).generic128mac) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech__Cipher),
            "::",
            stringify!(generic128mac)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).generic192) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech__Cipher),
            "::",
            stringify!(generic192)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).generic256) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech__Cipher),
            "::",
            stringify!(generic256)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).generic64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech__Cipher),
            "::",
            stringify!(generic64)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).generic64mac) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech__Cipher),
            "::",
            stringify!(generic64mac)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).genericgcm128) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech__Cipher),
            "::",
            stringify!(genericgcm128)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has160hash) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech__Cipher),
            "::",
            stringify!(has160hash)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).imech) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech__Cipher),
            "::",
            stringify!(imech)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kcdsahas160) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech__Cipher),
            "::",
            stringify!(kcdsahas160)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).md5hash) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech__Cipher),
            "::",
            stringify!(md5hash)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ripemd160hash) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech__Cipher),
            "::",
            stringify!(ripemd160hash)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rsappkcs1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech__Cipher),
            "::",
            stringify!(rsappkcs1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rsappkcs1ppkcs11) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech__Cipher),
            "::",
            stringify!(rsappkcs1ppkcs11)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sha1hash) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech__Cipher),
            "::",
            stringify!(sha1hash)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sha224hash) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech__Cipher),
            "::",
            stringify!(sha224hash)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sha256hash) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech__Cipher),
            "::",
            stringify!(sha256hash)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sha384hash) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech__Cipher),
            "::",
            stringify!(sha384hash)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sha512hash) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech__Cipher),
            "::",
            stringify!(sha512hash)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tigerhash) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech__Cipher),
            "::",
            stringify!(tigerhash)
        )
    );
}
impl Default for M_Mech__Cipher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Mech__Cipher {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Mech__Cipher {{ union }}")
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Mech_AESmGCM_IV {
    pub taglen: M_Word,
    pub aad: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_Mech_AESmGCM_IV() {
    const UNINIT: ::core::mem::MaybeUninit<M_Mech_AESmGCM_IV> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Mech_AESmGCM_IV>(),
        24usize,
        concat!("Size of: ", stringify!(M_Mech_AESmGCM_IV))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Mech_AESmGCM_IV>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Mech_AESmGCM_IV))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).taglen) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech_AESmGCM_IV),
            "::",
            stringify!(taglen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).aad) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech_AESmGCM_IV),
            "::",
            stringify!(aad)
        )
    );
}
impl Default for M_Mech_AESmGCM_IV {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Mech_Generic128_IV {
    pub iv: M_Block128,
}
#[test]
fn bindgen_test_layout_M_Mech_Generic128_IV() {
    const UNINIT: ::core::mem::MaybeUninit<M_Mech_Generic128_IV> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Mech_Generic128_IV>(),
        16usize,
        concat!("Size of: ", stringify!(M_Mech_Generic128_IV))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Mech_Generic128_IV>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Mech_Generic128_IV))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iv) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech_Generic128_IV),
            "::",
            stringify!(iv)
        )
    );
}
impl Default for M_Mech_Generic128_IV {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Mech_Generic128_IV {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Mech_Generic128_IV {{ iv: {:?} }}", self.iv)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Mech_Generic128MAC_IV {
    pub iv: M_Block128,
}
#[test]
fn bindgen_test_layout_M_Mech_Generic128MAC_IV() {
    const UNINIT: ::core::mem::MaybeUninit<M_Mech_Generic128MAC_IV> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Mech_Generic128MAC_IV>(),
        16usize,
        concat!("Size of: ", stringify!(M_Mech_Generic128MAC_IV))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Mech_Generic128MAC_IV>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Mech_Generic128MAC_IV))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iv) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech_Generic128MAC_IV),
            "::",
            stringify!(iv)
        )
    );
}
impl Default for M_Mech_Generic128MAC_IV {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Mech_Generic128MAC_IV {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Mech_Generic128MAC_IV {{ iv: {:?} }}", self.iv)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_Block192 {
    pub bytes: [::core::ffi::c_uchar; 24usize],
    pub words: [M_Word; 6usize],
}
#[test]
fn bindgen_test_layout_M_Block192() {
    const UNINIT: ::core::mem::MaybeUninit<M_Block192> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Block192>(),
        24usize,
        concat!("Size of: ", stringify!(M_Block192))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Block192>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Block192))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Block192),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).words) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Block192),
            "::",
            stringify!(words)
        )
    );
}
impl Default for M_Block192 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Block192 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Block192 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Mech_Generic192_IV {
    pub iv: M_Block192,
}
#[test]
fn bindgen_test_layout_M_Mech_Generic192_IV() {
    const UNINIT: ::core::mem::MaybeUninit<M_Mech_Generic192_IV> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Mech_Generic192_IV>(),
        24usize,
        concat!("Size of: ", stringify!(M_Mech_Generic192_IV))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Mech_Generic192_IV>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Mech_Generic192_IV))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iv) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech_Generic192_IV),
            "::",
            stringify!(iv)
        )
    );
}
impl Default for M_Mech_Generic192_IV {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Mech_Generic192_IV {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Mech_Generic192_IV {{ iv: {:?} }}", self.iv)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_Block256 {
    pub bytes: [::core::ffi::c_uchar; 32usize],
    pub words: [M_Word; 8usize],
}
#[test]
fn bindgen_test_layout_M_Block256() {
    const UNINIT: ::core::mem::MaybeUninit<M_Block256> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Block256>(),
        32usize,
        concat!("Size of: ", stringify!(M_Block256))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Block256>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Block256))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Block256),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).words) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Block256),
            "::",
            stringify!(words)
        )
    );
}
impl Default for M_Block256 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Block256 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Block256 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Mech_Generic256_IV {
    pub iv: M_Block256,
}
#[test]
fn bindgen_test_layout_M_Mech_Generic256_IV() {
    const UNINIT: ::core::mem::MaybeUninit<M_Mech_Generic256_IV> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Mech_Generic256_IV>(),
        32usize,
        concat!("Size of: ", stringify!(M_Mech_Generic256_IV))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Mech_Generic256_IV>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Mech_Generic256_IV))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iv) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech_Generic256_IV),
            "::",
            stringify!(iv)
        )
    );
}
impl Default for M_Mech_Generic256_IV {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Mech_Generic256_IV {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Mech_Generic256_IV {{ iv: {:?} }}", self.iv)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Mech_Generic64_IV {
    pub iv: M_Block64,
}
#[test]
fn bindgen_test_layout_M_Mech_Generic64_IV() {
    const UNINIT: ::core::mem::MaybeUninit<M_Mech_Generic64_IV> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Mech_Generic64_IV>(),
        8usize,
        concat!("Size of: ", stringify!(M_Mech_Generic64_IV))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Mech_Generic64_IV>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Mech_Generic64_IV))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iv) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech_Generic64_IV),
            "::",
            stringify!(iv)
        )
    );
}
impl Default for M_Mech_Generic64_IV {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Mech_Generic64_IV {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Mech_Generic64_IV {{ iv: {:?} }}", self.iv)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Mech_Generic64MAC_IV {
    pub iv: M_Block64,
}
#[test]
fn bindgen_test_layout_M_Mech_Generic64MAC_IV() {
    const UNINIT: ::core::mem::MaybeUninit<M_Mech_Generic64MAC_IV> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Mech_Generic64MAC_IV>(),
        8usize,
        concat!("Size of: ", stringify!(M_Mech_Generic64MAC_IV))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Mech_Generic64MAC_IV>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Mech_Generic64MAC_IV))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iv) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech_Generic64MAC_IV),
            "::",
            stringify!(iv)
        )
    );
}
impl Default for M_Mech_Generic64MAC_IV {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Mech_Generic64MAC_IV {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Mech_Generic64MAC_IV {{ iv: {:?} }}", self.iv)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Mech_GenericGCM128_IV {
    pub iv: M_ByteBlock,
    pub header: M_ByteBlock,
    pub taglen: M_Word,
}
#[test]
fn bindgen_test_layout_M_Mech_GenericGCM128_IV() {
    const UNINIT: ::core::mem::MaybeUninit<M_Mech_GenericGCM128_IV> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Mech_GenericGCM128_IV>(),
        40usize,
        concat!("Size of: ", stringify!(M_Mech_GenericGCM128_IV))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Mech_GenericGCM128_IV>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Mech_GenericGCM128_IV))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iv) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech_GenericGCM128_IV),
            "::",
            stringify!(iv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech_GenericGCM128_IV),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).taglen) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech_GenericGCM128_IV),
            "::",
            stringify!(taglen)
        )
    );
}
impl Default for M_Mech_GenericGCM128_IV {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Mech_RSApPKCS1OAEP_IV {
    pub p: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_Mech_RSApPKCS1OAEP_IV() {
    const UNINIT: ::core::mem::MaybeUninit<M_Mech_RSApPKCS1OAEP_IV> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Mech_RSApPKCS1OAEP_IV>(),
        16usize,
        concat!("Size of: ", stringify!(M_Mech_RSApPKCS1OAEP_IV))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Mech_RSApPKCS1OAEP_IV>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Mech_RSApPKCS1OAEP_IV))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech_RSApPKCS1OAEP_IV),
            "::",
            stringify!(p)
        )
    );
}
impl Default for M_Mech_RSApPKCS1OAEP_IV {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_Mech__IV {
    pub aesmgcm: M_Mech_AESmGCM_IV,
    pub generic128: M_Mech_Generic128_IV,
    pub generic128mac: M_Mech_Generic128MAC_IV,
    pub generic192: M_Mech_Generic192_IV,
    pub generic256: M_Mech_Generic256_IV,
    pub generic64: M_Mech_Generic64_IV,
    pub generic64mac: M_Mech_Generic64MAC_IV,
    pub genericgcm128: M_Mech_GenericGCM128_IV,
    pub rsappkcs1oaep: M_Mech_RSApPKCS1OAEP_IV,
}
#[test]
fn bindgen_test_layout_M_Mech__IV() {
    const UNINIT: ::core::mem::MaybeUninit<M_Mech__IV> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Mech__IV>(),
        40usize,
        concat!("Size of: ", stringify!(M_Mech__IV))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Mech__IV>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Mech__IV))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).aesmgcm) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech__IV),
            "::",
            stringify!(aesmgcm)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).generic128) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech__IV),
            "::",
            stringify!(generic128)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).generic128mac) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech__IV),
            "::",
            stringify!(generic128mac)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).generic192) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech__IV),
            "::",
            stringify!(generic192)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).generic256) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech__IV),
            "::",
            stringify!(generic256)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).generic64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech__IV),
            "::",
            stringify!(generic64)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).generic64mac) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech__IV),
            "::",
            stringify!(generic64mac)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).genericgcm128) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech__IV),
            "::",
            stringify!(genericgcm128)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rsappkcs1oaep) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Mech__IV),
            "::",
            stringify!(rsappkcs1oaep)
        )
    );
}
impl Default for M_Mech__IV {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Mech__IV {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Mech__IV {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_CipherText {
    pub mech: M_Mech,
    pub data: M_Mech__Cipher,
    pub iv: M_Mech__IV,
}
#[test]
fn bindgen_test_layout_M_CipherText() {
    const UNINIT: ::core::mem::MaybeUninit<M_CipherText> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_CipherText>(),
        112usize,
        concat!("Size of: ", stringify!(M_CipherText))
    );
    assert_eq!(
        ::core::mem::align_of::<M_CipherText>(),
        8usize,
        concat!("Alignment of ", stringify!(M_CipherText))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mech) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_CipherText),
            "::",
            stringify!(mech)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_CipherText),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iv) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(M_CipherText),
            "::",
            stringify!(iv)
        )
    );
}
impl Default for M_CipherText {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_CipherText {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_CipherText {{ mech: {:?}, data: {:?}, iv: {:?} }}",
            self.mech, self.data, self.iv
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_CertType_SingleCert_CertBody {
    pub pubkeydata: M_KeyData,
    pub signature: M_CipherText,
    pub certsignmsg: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_CertType_SingleCert_CertBody() {
    const UNINIT: ::core::mem::MaybeUninit<M_CertType_SingleCert_CertBody> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_CertType_SingleCert_CertBody>(),
        256usize,
        concat!("Size of: ", stringify!(M_CertType_SingleCert_CertBody))
    );
    assert_eq!(
        ::core::mem::align_of::<M_CertType_SingleCert_CertBody>(),
        8usize,
        concat!("Alignment of ", stringify!(M_CertType_SingleCert_CertBody))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pubkeydata) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_CertType_SingleCert_CertBody),
            "::",
            stringify!(pubkeydata)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).signature) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(M_CertType_SingleCert_CertBody),
            "::",
            stringify!(signature)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).certsignmsg) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(M_CertType_SingleCert_CertBody),
            "::",
            stringify!(certsignmsg)
        )
    );
}
impl Default for M_CertType_SingleCert_CertBody {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_CertType_SingleCert_CertBody {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_CertType_SingleCert_CertBody {{ pubkeydata: {:?}, signature: {:?}, certsignmsg: {:?} }}" , self . pubkeydata , self . signature , self . certsignmsg)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_CertType__CertBody {
    pub signingkey: M_CertType_SigningKey_CertBody,
    pub singlecert: M_CertType_SingleCert_CertBody,
}
#[test]
fn bindgen_test_layout_M_CertType__CertBody() {
    const UNINIT: ::core::mem::MaybeUninit<M_CertType__CertBody> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_CertType__CertBody>(),
        256usize,
        concat!("Size of: ", stringify!(M_CertType__CertBody))
    );
    assert_eq!(
        ::core::mem::align_of::<M_CertType__CertBody>(),
        8usize,
        concat!("Alignment of ", stringify!(M_CertType__CertBody))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).signingkey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_CertType__CertBody),
            "::",
            stringify!(signingkey)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).singlecert) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_CertType__CertBody),
            "::",
            stringify!(singlecert)
        )
    );
}
impl Default for M_CertType__CertBody {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_CertType__CertBody {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_CertType__CertBody {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Certificate {
    pub keyhash: M_KeyHash,
    pub type_: M_CertType,
    pub body: M_CertType__CertBody,
}
#[test]
fn bindgen_test_layout_M_Certificate() {
    const UNINIT: ::core::mem::MaybeUninit<M_Certificate> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Certificate>(),
        280usize,
        concat!("Size of: ", stringify!(M_Certificate))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Certificate>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Certificate))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).keyhash) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Certificate),
            "::",
            stringify!(keyhash)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Certificate),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Certificate),
            "::",
            stringify!(body)
        )
    );
}
impl Default for M_Certificate {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Certificate {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Certificate {{ keyhash: {:?}, type: {:?}, body: {:?} }}",
            self.keyhash, self.type_, self.body
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_DSAGenerationHash {
    pub hash: M_Mech,
}
#[test]
fn bindgen_test_layout_M_DSAGenerationHash() {
    const UNINIT: ::core::mem::MaybeUninit<M_DSAGenerationHash> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_DSAGenerationHash>(),
        4usize,
        concat!("Size of: ", stringify!(M_DSAGenerationHash))
    );
    assert_eq!(
        ::core::mem::align_of::<M_DSAGenerationHash>(),
        4usize,
        concat!("Alignment of ", stringify!(M_DSAGenerationHash))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hash) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DSAGenerationHash),
            "::",
            stringify!(hash)
        )
    );
}
impl Default for M_DSAGenerationHash {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Nonce = M_Hash;
pub type M_FileSpec_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_FileDevice_NVMem_Details {
    pub module: M_ModuleID,
}
#[test]
fn bindgen_test_layout_M_FileDevice_NVMem_Details() {
    const UNINIT: ::core::mem::MaybeUninit<M_FileDevice_NVMem_Details> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_FileDevice_NVMem_Details>(),
        4usize,
        concat!("Size of: ", stringify!(M_FileDevice_NVMem_Details))
    );
    assert_eq!(
        ::core::mem::align_of::<M_FileDevice_NVMem_Details>(),
        4usize,
        concat!("Alignment of ", stringify!(M_FileDevice_NVMem_Details))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_FileDevice_NVMem_Details),
            "::",
            stringify!(module)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_FileDevice_NVMemPersist_Details {
    pub module: M_ModuleID,
}
#[test]
fn bindgen_test_layout_M_FileDevice_NVMemPersist_Details() {
    const UNINIT: ::core::mem::MaybeUninit<M_FileDevice_NVMemPersist_Details> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_FileDevice_NVMemPersist_Details>(),
        4usize,
        concat!("Size of: ", stringify!(M_FileDevice_NVMemPersist_Details))
    );
    assert_eq!(
        ::core::mem::align_of::<M_FileDevice_NVMemPersist_Details>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(M_FileDevice_NVMemPersist_Details)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_FileDevice_NVMemPersist_Details),
            "::",
            stringify!(module)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_FileDevice_PhysToken_Details {
    pub token: M_PhysToken,
}
#[test]
fn bindgen_test_layout_M_FileDevice_PhysToken_Details() {
    const UNINIT: ::core::mem::MaybeUninit<M_FileDevice_PhysToken_Details> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_FileDevice_PhysToken_Details>(),
        12usize,
        concat!("Size of: ", stringify!(M_FileDevice_PhysToken_Details))
    );
    assert_eq!(
        ::core::mem::align_of::<M_FileDevice_PhysToken_Details>(),
        4usize,
        concat!("Alignment of ", stringify!(M_FileDevice_PhysToken_Details))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).token) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_FileDevice_PhysToken_Details),
            "::",
            stringify!(token)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_FileDevice__Details {
    pub nvmem: M_FileDevice_NVMem_Details,
    pub nvmempersist: M_FileDevice_NVMemPersist_Details,
    pub phystoken: M_FileDevice_PhysToken_Details,
}
#[test]
fn bindgen_test_layout_M_FileDevice__Details() {
    const UNINIT: ::core::mem::MaybeUninit<M_FileDevice__Details> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_FileDevice__Details>(),
        12usize,
        concat!("Size of: ", stringify!(M_FileDevice__Details))
    );
    assert_eq!(
        ::core::mem::align_of::<M_FileDevice__Details>(),
        4usize,
        concat!("Alignment of ", stringify!(M_FileDevice__Details))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nvmem) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_FileDevice__Details),
            "::",
            stringify!(nvmem)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nvmempersist) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_FileDevice__Details),
            "::",
            stringify!(nvmempersist)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).phystoken) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_FileDevice__Details),
            "::",
            stringify!(phystoken)
        )
    );
}
impl Default for M_FileDevice__Details {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_FileDevice__Details {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_FileDevice__Details {{ union }}")
    }
}
pub type M_FileInfo_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_FileID {
    pub bytes: [::core::ffi::c_uchar; 11usize],
}
#[test]
fn bindgen_test_layout_M_FileID() {
    const UNINIT: ::core::mem::MaybeUninit<M_FileID> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_FileID>(),
        11usize,
        concat!("Size of: ", stringify!(M_FileID))
    );
    assert_eq!(
        ::core::mem::align_of::<M_FileID>(),
        1usize,
        concat!("Alignment of ", stringify!(M_FileID))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_FileID),
            "::",
            stringify!(bytes)
        )
    );
}
impl Default for M_FileID {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_FileID {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_FileID {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_FileInfo {
    pub flags: M_FileInfo_flags,
    pub length: M_Word,
    pub id: M_FileID,
}
#[test]
fn bindgen_test_layout_M_FileInfo() {
    const UNINIT: ::core::mem::MaybeUninit<M_FileInfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_FileInfo>(),
        20usize,
        concat!("Size of: ", stringify!(M_FileInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<M_FileInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(M_FileInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_FileInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_FileInfo),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_FileInfo),
            "::",
            stringify!(id)
        )
    );
}
impl Default for M_FileInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_FileInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_FileInfo {{ flags: {:?}, length: {:?}, id: {:?} }}",
            self.flags, self.length, self.id
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_FileSpec {
    pub flags: M_FileSpec_flags,
    pub dev: M_FileDevice,
    pub details: M_FileDevice__Details,
    pub file: M_FileInfo,
}
#[test]
fn bindgen_test_layout_M_FileSpec() {
    const UNINIT: ::core::mem::MaybeUninit<M_FileSpec> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_FileSpec>(),
        40usize,
        concat!("Size of: ", stringify!(M_FileSpec))
    );
    assert_eq!(
        ::core::mem::align_of::<M_FileSpec>(),
        4usize,
        concat!("Alignment of ", stringify!(M_FileSpec))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_FileSpec),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dev) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_FileSpec),
            "::",
            stringify!(dev)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).details) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_FileSpec),
            "::",
            stringify!(details)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).file) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(M_FileSpec),
            "::",
            stringify!(file)
        )
    );
}
impl Default for M_FileSpec {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_FileSpec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_FileSpec {{ flags: {:?}, dev: {:?}, details: {:?}, file: {:?} }}",
            self.flags, self.dev, self.details, self.file
        )
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_BlobFormat_Direct_MkBlobParams {
    pub idki: M_KeyID,
}
#[test]
fn bindgen_test_layout_M_BlobFormat_Direct_MkBlobParams() {
    const UNINIT: ::core::mem::MaybeUninit<M_BlobFormat_Direct_MkBlobParams> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_BlobFormat_Direct_MkBlobParams>(),
        4usize,
        concat!("Size of: ", stringify!(M_BlobFormat_Direct_MkBlobParams))
    );
    assert_eq!(
        ::core::mem::align_of::<M_BlobFormat_Direct_MkBlobParams>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(M_BlobFormat_Direct_MkBlobParams)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).idki) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_BlobFormat_Direct_MkBlobParams),
            "::",
            stringify!(idki)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_BlobFormat_Indirect_MkBlobParams {
    pub idkr: M_KeyID,
    pub mech: M_Mech,
}
#[test]
fn bindgen_test_layout_M_BlobFormat_Indirect_MkBlobParams() {
    const UNINIT: ::core::mem::MaybeUninit<M_BlobFormat_Indirect_MkBlobParams> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_BlobFormat_Indirect_MkBlobParams>(),
        8usize,
        concat!("Size of: ", stringify!(M_BlobFormat_Indirect_MkBlobParams))
    );
    assert_eq!(
        ::core::mem::align_of::<M_BlobFormat_Indirect_MkBlobParams>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(M_BlobFormat_Indirect_MkBlobParams)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).idkr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_BlobFormat_Indirect_MkBlobParams),
            "::",
            stringify!(idkr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mech) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_BlobFormat_Indirect_MkBlobParams),
            "::",
            stringify!(mech)
        )
    );
}
impl Default for M_BlobFormat_Indirect_MkBlobParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_BlobFormat_Module_MkBlobParams {
    pub hkm: M_KMHash,
}
#[test]
fn bindgen_test_layout_M_BlobFormat_Module_MkBlobParams() {
    const UNINIT: ::core::mem::MaybeUninit<M_BlobFormat_Module_MkBlobParams> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_BlobFormat_Module_MkBlobParams>(),
        20usize,
        concat!("Size of: ", stringify!(M_BlobFormat_Module_MkBlobParams))
    );
    assert_eq!(
        ::core::mem::align_of::<M_BlobFormat_Module_MkBlobParams>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(M_BlobFormat_Module_MkBlobParams)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hkm) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_BlobFormat_Module_MkBlobParams),
            "::",
            stringify!(hkm)
        )
    );
}
impl Default for M_BlobFormat_Module_MkBlobParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_BlobFormat_Module_MkBlobParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_BlobFormat_Module_MkBlobParams {{ hkm: {:?} }}",
            self.hkm
        )
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_BlobFormat_Token_MkBlobParams {
    pub idkt: M_KeyID,
}
#[test]
fn bindgen_test_layout_M_BlobFormat_Token_MkBlobParams() {
    const UNINIT: ::core::mem::MaybeUninit<M_BlobFormat_Token_MkBlobParams> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_BlobFormat_Token_MkBlobParams>(),
        4usize,
        concat!("Size of: ", stringify!(M_BlobFormat_Token_MkBlobParams))
    );
    assert_eq!(
        ::core::mem::align_of::<M_BlobFormat_Token_MkBlobParams>(),
        4usize,
        concat!("Alignment of ", stringify!(M_BlobFormat_Token_MkBlobParams))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).idkt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_BlobFormat_Token_MkBlobParams),
            "::",
            stringify!(idkt)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_BlobFormat_UserKey_MkBlobParams {
    pub idkr: M_KeyID,
    pub mech: M_Mech,
}
#[test]
fn bindgen_test_layout_M_BlobFormat_UserKey_MkBlobParams() {
    const UNINIT: ::core::mem::MaybeUninit<M_BlobFormat_UserKey_MkBlobParams> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_BlobFormat_UserKey_MkBlobParams>(),
        8usize,
        concat!("Size of: ", stringify!(M_BlobFormat_UserKey_MkBlobParams))
    );
    assert_eq!(
        ::core::mem::align_of::<M_BlobFormat_UserKey_MkBlobParams>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(M_BlobFormat_UserKey_MkBlobParams)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).idkr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_BlobFormat_UserKey_MkBlobParams),
            "::",
            stringify!(idkr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mech) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_BlobFormat_UserKey_MkBlobParams),
            "::",
            stringify!(mech)
        )
    );
}
impl Default for M_BlobFormat_UserKey_MkBlobParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_BlobFormat__MkBlobParams {
    pub direct: M_BlobFormat_Direct_MkBlobParams,
    pub indirect: M_BlobFormat_Indirect_MkBlobParams,
    pub module: M_BlobFormat_Module_MkBlobParams,
    pub token: M_BlobFormat_Token_MkBlobParams,
    pub userkey: M_BlobFormat_UserKey_MkBlobParams,
}
#[test]
fn bindgen_test_layout_M_BlobFormat__MkBlobParams() {
    const UNINIT: ::core::mem::MaybeUninit<M_BlobFormat__MkBlobParams> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_BlobFormat__MkBlobParams>(),
        20usize,
        concat!("Size of: ", stringify!(M_BlobFormat__MkBlobParams))
    );
    assert_eq!(
        ::core::mem::align_of::<M_BlobFormat__MkBlobParams>(),
        4usize,
        concat!("Alignment of ", stringify!(M_BlobFormat__MkBlobParams))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).direct) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_BlobFormat__MkBlobParams),
            "::",
            stringify!(direct)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).indirect) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_BlobFormat__MkBlobParams),
            "::",
            stringify!(indirect)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_BlobFormat__MkBlobParams),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).token) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_BlobFormat__MkBlobParams),
            "::",
            stringify!(token)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).userkey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_BlobFormat__MkBlobParams),
            "::",
            stringify!(userkey)
        )
    );
}
impl Default for M_BlobFormat__MkBlobParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_BlobFormat__MkBlobParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_BlobFormat__MkBlobParams {{ union }}")
    }
}
pub type M_DeriveMech_AESKeyUnwrap_DKParams_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_DeriveMech_AESKeyUnwrap_DKParams {
    pub flags: M_DeriveMech_AESKeyUnwrap_DKParams_flags,
    pub keytype: M_KeyType,
    pub iv: *mut M_Block64,
}
#[test]
fn bindgen_test_layout_M_DeriveMech_AESKeyUnwrap_DKParams() {
    const UNINIT: ::core::mem::MaybeUninit<M_DeriveMech_AESKeyUnwrap_DKParams> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_DeriveMech_AESKeyUnwrap_DKParams>(),
        16usize,
        concat!("Size of: ", stringify!(M_DeriveMech_AESKeyUnwrap_DKParams))
    );
    assert_eq!(
        ::core::mem::align_of::<M_DeriveMech_AESKeyUnwrap_DKParams>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(M_DeriveMech_AESKeyUnwrap_DKParams)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_AESKeyUnwrap_DKParams),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).keytype) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_AESKeyUnwrap_DKParams),
            "::",
            stringify!(keytype)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iv) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_AESKeyUnwrap_DKParams),
            "::",
            stringify!(iv)
        )
    );
}
impl Default for M_DeriveMech_AESKeyUnwrap_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_DeriveMech_AESKeyWrap_DKParams_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_DeriveMech_AESKeyWrap_DKParams {
    pub flags: M_DeriveMech_AESKeyWrap_DKParams_flags,
    pub iv: *mut M_Block64,
}
#[test]
fn bindgen_test_layout_M_DeriveMech_AESKeyWrap_DKParams() {
    const UNINIT: ::core::mem::MaybeUninit<M_DeriveMech_AESKeyWrap_DKParams> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_DeriveMech_AESKeyWrap_DKParams>(),
        16usize,
        concat!("Size of: ", stringify!(M_DeriveMech_AESKeyWrap_DKParams))
    );
    assert_eq!(
        ::core::mem::align_of::<M_DeriveMech_AESKeyWrap_DKParams>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(M_DeriveMech_AESKeyWrap_DKParams)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_AESKeyWrap_DKParams),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iv) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_AESKeyWrap_DKParams),
            "::",
            stringify!(iv)
        )
    );
}
impl Default for M_DeriveMech_AESKeyWrap_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_DeriveMech_CompositeARQCVerify_DKParams {
    pub scheme: M_ARQCScheme,
    pub mkdata: M_ByteBlock,
    pub skdata: M_ByteBlock,
    pub height: M_Word,
    pub branch: M_Word,
    pub atc: M_Word,
    pub iv: M_ByteBlock,
    pub iipb: M_ByteBlock,
    pub signature: M_ByteBlock,
    pub transdata: M_ByteBlock,
    pub data: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_DeriveMech_CompositeARQCVerify_DKParams() {
    const UNINIT: ::core::mem::MaybeUninit<M_DeriveMech_CompositeARQCVerify_DKParams> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_DeriveMech_CompositeARQCVerify_DKParams>(),
        136usize,
        concat!(
            "Size of: ",
            stringify!(M_DeriveMech_CompositeARQCVerify_DKParams)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<M_DeriveMech_CompositeARQCVerify_DKParams>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(M_DeriveMech_CompositeARQCVerify_DKParams)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).scheme) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_CompositeARQCVerify_DKParams),
            "::",
            stringify!(scheme)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mkdata) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_CompositeARQCVerify_DKParams),
            "::",
            stringify!(mkdata)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).skdata) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_CompositeARQCVerify_DKParams),
            "::",
            stringify!(skdata)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_CompositeARQCVerify_DKParams),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).branch) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_CompositeARQCVerify_DKParams),
            "::",
            stringify!(branch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).atc) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_CompositeARQCVerify_DKParams),
            "::",
            stringify!(atc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iv) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_CompositeARQCVerify_DKParams),
            "::",
            stringify!(iv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iipb) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_CompositeARQCVerify_DKParams),
            "::",
            stringify!(iipb)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).signature) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_CompositeARQCVerify_DKParams),
            "::",
            stringify!(signature)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).transdata) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_CompositeARQCVerify_DKParams),
            "::",
            stringify!(transdata)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_CompositeARQCVerify_DKParams),
            "::",
            stringify!(data)
        )
    );
}
impl Default for M_DeriveMech_CompositeARQCVerify_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_DeriveMech_CompositeWatchWordSign_DKParams {
    pub challenge: M_ByteBlock,
    pub version: M_Word,
}
#[test]
fn bindgen_test_layout_M_DeriveMech_CompositeWatchWordSign_DKParams() {
    const UNINIT: ::core::mem::MaybeUninit<M_DeriveMech_CompositeWatchWordSign_DKParams> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_DeriveMech_CompositeWatchWordSign_DKParams>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(M_DeriveMech_CompositeWatchWordSign_DKParams)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<M_DeriveMech_CompositeWatchWordSign_DKParams>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(M_DeriveMech_CompositeWatchWordSign_DKParams)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).challenge) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_CompositeWatchWordSign_DKParams),
            "::",
            stringify!(challenge)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_CompositeWatchWordSign_DKParams),
            "::",
            stringify!(version)
        )
    );
}
impl Default for M_DeriveMech_CompositeWatchWordSign_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_DeriveMech_CompositeWatchWordVerify_DKParams {
    pub challenge: M_ByteBlock,
    pub response: M_ByteBlock,
    pub version: M_Word,
}
#[test]
fn bindgen_test_layout_M_DeriveMech_CompositeWatchWordVerify_DKParams() {
    const UNINIT: ::core::mem::MaybeUninit<M_DeriveMech_CompositeWatchWordVerify_DKParams> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_DeriveMech_CompositeWatchWordVerify_DKParams>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(M_DeriveMech_CompositeWatchWordVerify_DKParams)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<M_DeriveMech_CompositeWatchWordVerify_DKParams>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(M_DeriveMech_CompositeWatchWordVerify_DKParams)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).challenge) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_CompositeWatchWordVerify_DKParams),
            "::",
            stringify!(challenge)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).response) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_CompositeWatchWordVerify_DKParams),
            "::",
            stringify!(response)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_CompositeWatchWordVerify_DKParams),
            "::",
            stringify!(version)
        )
    );
}
impl Default for M_DeriveMech_CompositeWatchWordVerify_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_DeriveMech_ConcatenateBytes_DKParams {
    pub dst_type: M_KeyType,
}
#[test]
fn bindgen_test_layout_M_DeriveMech_ConcatenateBytes_DKParams() {
    const UNINIT: ::core::mem::MaybeUninit<M_DeriveMech_ConcatenateBytes_DKParams> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_DeriveMech_ConcatenateBytes_DKParams>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(M_DeriveMech_ConcatenateBytes_DKParams)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<M_DeriveMech_ConcatenateBytes_DKParams>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(M_DeriveMech_ConcatenateBytes_DKParams)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dst_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_ConcatenateBytes_DKParams),
            "::",
            stringify!(dst_type)
        )
    );
}
impl Default for M_DeriveMech_ConcatenateBytes_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_DeriveMech_ConcatenationKDF_DKParams_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_DeriveMech_ConcatenationKDF_DKParams {
    pub flags: M_DeriveMech_ConcatenationKDF_DKParams_flags,
    pub keylen: M_Word,
    pub kdfhash: M_Mech,
    pub keytype: M_KeyType,
    pub sharedinfo: *mut M_ByteBlock,
    pub kx: *mut M_CipherText,
}
#[test]
fn bindgen_test_layout_M_DeriveMech_ConcatenationKDF_DKParams() {
    const UNINIT: ::core::mem::MaybeUninit<M_DeriveMech_ConcatenationKDF_DKParams> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_DeriveMech_ConcatenationKDF_DKParams>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(M_DeriveMech_ConcatenationKDF_DKParams)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<M_DeriveMech_ConcatenationKDF_DKParams>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(M_DeriveMech_ConcatenationKDF_DKParams)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_ConcatenationKDF_DKParams),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).keylen) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_ConcatenationKDF_DKParams),
            "::",
            stringify!(keylen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kdfhash) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_ConcatenationKDF_DKParams),
            "::",
            stringify!(kdfhash)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).keytype) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_ConcatenationKDF_DKParams),
            "::",
            stringify!(keytype)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sharedinfo) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_ConcatenationKDF_DKParams),
            "::",
            stringify!(sharedinfo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kx) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_ConcatenationKDF_DKParams),
            "::",
            stringify!(kx)
        )
    );
}
impl Default for M_DeriveMech_ConcatenationKDF_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_DeriveMech_ECCMQV_DKParams_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_DeriveMech_ECCMQV_DKParams {
    pub flags: M_DeriveMech_ECCMQV_DKParams_flags,
    pub keylen: M_Word,
    pub kdfhash: M_Mech,
    pub keytype: M_KeyType,
    pub sharedinfo: *mut M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_DeriveMech_ECCMQV_DKParams() {
    const UNINIT: ::core::mem::MaybeUninit<M_DeriveMech_ECCMQV_DKParams> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_DeriveMech_ECCMQV_DKParams>(),
        24usize,
        concat!("Size of: ", stringify!(M_DeriveMech_ECCMQV_DKParams))
    );
    assert_eq!(
        ::core::mem::align_of::<M_DeriveMech_ECCMQV_DKParams>(),
        8usize,
        concat!("Alignment of ", stringify!(M_DeriveMech_ECCMQV_DKParams))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_ECCMQV_DKParams),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).keylen) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_ECCMQV_DKParams),
            "::",
            stringify!(keylen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kdfhash) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_ECCMQV_DKParams),
            "::",
            stringify!(kdfhash)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).keytype) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_ECCMQV_DKParams),
            "::",
            stringify!(keytype)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sharedinfo) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_ECCMQV_DKParams),
            "::",
            stringify!(sharedinfo)
        )
    );
}
impl Default for M_DeriveMech_ECCMQV_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_DeriveMech_ECCMQVdNISTCKDF_DKParams_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_DeriveMech_ECCMQVdNISTCKDF_DKParams {
    pub flags: M_DeriveMech_ECCMQVdNISTCKDF_DKParams_flags,
    pub keylen: M_Word,
    pub kdfhash: M_Mech,
    pub keytype: M_KeyType,
    pub sharedinfo: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_DeriveMech_ECCMQVdNISTCKDF_DKParams() {
    const UNINIT: ::core::mem::MaybeUninit<M_DeriveMech_ECCMQVdNISTCKDF_DKParams> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_DeriveMech_ECCMQVdNISTCKDF_DKParams>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(M_DeriveMech_ECCMQVdNISTCKDF_DKParams)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<M_DeriveMech_ECCMQVdNISTCKDF_DKParams>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(M_DeriveMech_ECCMQVdNISTCKDF_DKParams)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_ECCMQVdNISTCKDF_DKParams),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).keylen) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_ECCMQVdNISTCKDF_DKParams),
            "::",
            stringify!(keylen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kdfhash) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_ECCMQVdNISTCKDF_DKParams),
            "::",
            stringify!(kdfhash)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).keytype) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_ECCMQVdNISTCKDF_DKParams),
            "::",
            stringify!(keytype)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sharedinfo) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_ECCMQVdNISTCKDF_DKParams),
            "::",
            stringify!(sharedinfo)
        )
    );
}
impl Default for M_DeriveMech_ECCMQVdNISTCKDF_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_KAPrimitive_ECDHdKDF2_KADetails {
    pub sharedInfo: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_KAPrimitive_ECDHdKDF2_KADetails() {
    const UNINIT: ::core::mem::MaybeUninit<M_KAPrimitive_ECDHdKDF2_KADetails> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_KAPrimitive_ECDHdKDF2_KADetails>(),
        16usize,
        concat!("Size of: ", stringify!(M_KAPrimitive_ECDHdKDF2_KADetails))
    );
    assert_eq!(
        ::core::mem::align_of::<M_KAPrimitive_ECDHdKDF2_KADetails>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(M_KAPrimitive_ECDHdKDF2_KADetails)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sharedInfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KAPrimitive_ECDHdKDF2_KADetails),
            "::",
            stringify!(sharedInfo)
        )
    );
}
impl Default for M_KAPrimitive_ECDHdKDF2_KADetails {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_KAPrimitive__KADetails {
    pub ecdhdkdf2: M_KAPrimitive_ECDHdKDF2_KADetails,
}
#[test]
fn bindgen_test_layout_M_KAPrimitive__KADetails() {
    const UNINIT: ::core::mem::MaybeUninit<M_KAPrimitive__KADetails> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_KAPrimitive__KADetails>(),
        16usize,
        concat!("Size of: ", stringify!(M_KAPrimitive__KADetails))
    );
    assert_eq!(
        ::core::mem::align_of::<M_KAPrimitive__KADetails>(),
        8usize,
        concat!("Alignment of ", stringify!(M_KAPrimitive__KADetails))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ecdhdkdf2) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KAPrimitive__KADetails),
            "::",
            stringify!(ecdhdkdf2)
        )
    );
}
impl Default for M_KAPrimitive__KADetails {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_KAPrimitive__KADetails {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_KAPrimitive__KADetails {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_KAParams {
    pub prim: M_KAPrimitive,
    pub kdfhash: M_Mech,
    pub details: M_KAPrimitive__KADetails,
}
#[test]
fn bindgen_test_layout_M_KAParams() {
    const UNINIT: ::core::mem::MaybeUninit<M_KAParams> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_KAParams>(),
        24usize,
        concat!("Size of: ", stringify!(M_KAParams))
    );
    assert_eq!(
        ::core::mem::align_of::<M_KAParams>(),
        8usize,
        concat!("Alignment of ", stringify!(M_KAParams))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prim) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KAParams),
            "::",
            stringify!(prim)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kdfhash) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KAParams),
            "::",
            stringify!(kdfhash)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).details) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KAParams),
            "::",
            stringify!(details)
        )
    );
}
impl Default for M_KAParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_KAParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_KAParams {{ prim: {:?}, kdfhash: {:?}, details: {:?} }}",
            self.prim, self.kdfhash, self.details
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_DeriveMech_ECDHKA_DKParams {
    pub kaparams: M_KAParams,
    pub keytype: M_KeyType,
    pub keylenbits: M_Word,
}
#[test]
fn bindgen_test_layout_M_DeriveMech_ECDHKA_DKParams() {
    const UNINIT: ::core::mem::MaybeUninit<M_DeriveMech_ECDHKA_DKParams> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_DeriveMech_ECDHKA_DKParams>(),
        32usize,
        concat!("Size of: ", stringify!(M_DeriveMech_ECDHKA_DKParams))
    );
    assert_eq!(
        ::core::mem::align_of::<M_DeriveMech_ECDHKA_DKParams>(),
        8usize,
        concat!("Alignment of ", stringify!(M_DeriveMech_ECDHKA_DKParams))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kaparams) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_ECDHKA_DKParams),
            "::",
            stringify!(kaparams)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).keytype) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_ECDHKA_DKParams),
            "::",
            stringify!(keytype)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).keylenbits) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_ECDHKA_DKParams),
            "::",
            stringify!(keylenbits)
        )
    );
}
impl Default for M_DeriveMech_ECDHKA_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_DeriveMech_ECDHKA_DKParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_DeriveMech_ECDHKA_DKParams {{ kaparams: {:?}, keytype: {:?}, keylenbits: {:?} }}",
            self.kaparams, self.keytype, self.keylenbits
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_IESCipherMode_XORwithHMAC_IESDetails {
    pub mackeylenbits: M_Word,
    pub mactaglenbits: M_Word,
    pub mac: M_Mech,
}
#[test]
fn bindgen_test_layout_M_IESCipherMode_XORwithHMAC_IESDetails() {
    const UNINIT: ::core::mem::MaybeUninit<M_IESCipherMode_XORwithHMAC_IESDetails> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_IESCipherMode_XORwithHMAC_IESDetails>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(M_IESCipherMode_XORwithHMAC_IESDetails)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<M_IESCipherMode_XORwithHMAC_IESDetails>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(M_IESCipherMode_XORwithHMAC_IESDetails)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mackeylenbits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_IESCipherMode_XORwithHMAC_IESDetails),
            "::",
            stringify!(mackeylenbits)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mactaglenbits) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_IESCipherMode_XORwithHMAC_IESDetails),
            "::",
            stringify!(mactaglenbits)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mac) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_IESCipherMode_XORwithHMAC_IESDetails),
            "::",
            stringify!(mac)
        )
    );
}
impl Default for M_IESCipherMode_XORwithHMAC_IESDetails {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_IESCipherMode__IESDetails {
    pub xorwithhmac: M_IESCipherMode_XORwithHMAC_IESDetails,
}
#[test]
fn bindgen_test_layout_M_IESCipherMode__IESDetails() {
    const UNINIT: ::core::mem::MaybeUninit<M_IESCipherMode__IESDetails> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_IESCipherMode__IESDetails>(),
        12usize,
        concat!("Size of: ", stringify!(M_IESCipherMode__IESDetails))
    );
    assert_eq!(
        ::core::mem::align_of::<M_IESCipherMode__IESDetails>(),
        4usize,
        concat!("Alignment of ", stringify!(M_IESCipherMode__IESDetails))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xorwithhmac) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_IESCipherMode__IESDetails),
            "::",
            stringify!(xorwithhmac)
        )
    );
}
impl Default for M_IESCipherMode__IESDetails {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_IESCipherMode__IESDetails {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_IESCipherMode__IESDetails {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_IESParams {
    pub mode: M_IESCipherMode,
    pub details: M_IESCipherMode__IESDetails,
}
#[test]
fn bindgen_test_layout_M_IESParams() {
    const UNINIT: ::core::mem::MaybeUninit<M_IESParams> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_IESParams>(),
        16usize,
        concat!("Size of: ", stringify!(M_IESParams))
    );
    assert_eq!(
        ::core::mem::align_of::<M_IESParams>(),
        4usize,
        concat!("Alignment of ", stringify!(M_IESParams))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_IESParams),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).details) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_IESParams),
            "::",
            stringify!(details)
        )
    );
}
impl Default for M_IESParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_IESParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_IESParams {{ mode: {:?}, details: {:?} }}",
            self.mode, self.details
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_DeriveMech_ECIESKeyUnwrap_DKParams {
    pub kaparams: M_KAParams,
    pub iesparams: M_IESParams,
    pub keytype: M_KeyType,
}
#[test]
fn bindgen_test_layout_M_DeriveMech_ECIESKeyUnwrap_DKParams() {
    const UNINIT: ::core::mem::MaybeUninit<M_DeriveMech_ECIESKeyUnwrap_DKParams> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_DeriveMech_ECIESKeyUnwrap_DKParams>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(M_DeriveMech_ECIESKeyUnwrap_DKParams)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<M_DeriveMech_ECIESKeyUnwrap_DKParams>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(M_DeriveMech_ECIESKeyUnwrap_DKParams)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kaparams) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_ECIESKeyUnwrap_DKParams),
            "::",
            stringify!(kaparams)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iesparams) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_ECIESKeyUnwrap_DKParams),
            "::",
            stringify!(iesparams)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).keytype) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_ECIESKeyUnwrap_DKParams),
            "::",
            stringify!(keytype)
        )
    );
}
impl Default for M_DeriveMech_ECIESKeyUnwrap_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_DeriveMech_ECIESKeyUnwrap_DKParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_DeriveMech_ECIESKeyUnwrap_DKParams {{ kaparams: {:?}, iesparams: {:?}, keytype: {:?} }}" , self . kaparams , self . iesparams , self . keytype)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_DeriveMech_ECIESKeyWrap_DKParams {
    pub kaparams: M_KAParams,
    pub iesparams: M_IESParams,
}
#[test]
fn bindgen_test_layout_M_DeriveMech_ECIESKeyWrap_DKParams() {
    const UNINIT: ::core::mem::MaybeUninit<M_DeriveMech_ECIESKeyWrap_DKParams> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_DeriveMech_ECIESKeyWrap_DKParams>(),
        40usize,
        concat!("Size of: ", stringify!(M_DeriveMech_ECIESKeyWrap_DKParams))
    );
    assert_eq!(
        ::core::mem::align_of::<M_DeriveMech_ECIESKeyWrap_DKParams>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(M_DeriveMech_ECIESKeyWrap_DKParams)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kaparams) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_ECIESKeyWrap_DKParams),
            "::",
            stringify!(kaparams)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iesparams) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_ECIESKeyWrap_DKParams),
            "::",
            stringify!(iesparams)
        )
    );
}
impl Default for M_DeriveMech_ECIESKeyWrap_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_DeriveMech_ECIESKeyWrap_DKParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_DeriveMech_ECIESKeyWrap_DKParams {{ kaparams: {:?}, iesparams: {:?} }}",
            self.kaparams, self.iesparams
        )
    }
}
pub type M_DeriveMech_GenerateRSAB36_DKParams_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_DeriveMech_GenerateRSAB36_DKParams {
    pub flags: M_DeriveMech_GenerateRSAB36_DKParams_flags,
    pub lenbits: M_Word,
    pub e: M_Bignum,
    pub xp1: M_Bignum,
    pub xp2: M_Bignum,
    pub xp: M_Bignum,
    pub xq1: M_Bignum,
    pub xq2: M_Bignum,
    pub xq: M_Bignum,
}
#[test]
fn bindgen_test_layout_M_DeriveMech_GenerateRSAB36_DKParams() {
    const UNINIT: ::core::mem::MaybeUninit<M_DeriveMech_GenerateRSAB36_DKParams> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_DeriveMech_GenerateRSAB36_DKParams>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(M_DeriveMech_GenerateRSAB36_DKParams)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<M_DeriveMech_GenerateRSAB36_DKParams>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(M_DeriveMech_GenerateRSAB36_DKParams)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_GenerateRSAB36_DKParams),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lenbits) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_GenerateRSAB36_DKParams),
            "::",
            stringify!(lenbits)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).e) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_GenerateRSAB36_DKParams),
            "::",
            stringify!(e)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xp1) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_GenerateRSAB36_DKParams),
            "::",
            stringify!(xp1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xp2) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_GenerateRSAB36_DKParams),
            "::",
            stringify!(xp2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xp) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_GenerateRSAB36_DKParams),
            "::",
            stringify!(xp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xq1) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_GenerateRSAB36_DKParams),
            "::",
            stringify!(xq1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xq2) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_GenerateRSAB36_DKParams),
            "::",
            stringify!(xq2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xq) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_GenerateRSAB36_DKParams),
            "::",
            stringify!(xq)
        )
    );
}
impl Default for M_DeriveMech_GenerateRSAB36_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_DeriveMech_HyperledgerClient_DKParams {
    pub hmac: M_Mech,
    pub decrypt: M_Mech,
    pub eksize: M_Word,
    pub evsize: M_Word,
    pub big_endian: M_Word,
}
#[test]
fn bindgen_test_layout_M_DeriveMech_HyperledgerClient_DKParams() {
    const UNINIT: ::core::mem::MaybeUninit<M_DeriveMech_HyperledgerClient_DKParams> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_DeriveMech_HyperledgerClient_DKParams>(),
        20usize,
        concat!(
            "Size of: ",
            stringify!(M_DeriveMech_HyperledgerClient_DKParams)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<M_DeriveMech_HyperledgerClient_DKParams>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(M_DeriveMech_HyperledgerClient_DKParams)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hmac) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_HyperledgerClient_DKParams),
            "::",
            stringify!(hmac)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).decrypt) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_HyperledgerClient_DKParams),
            "::",
            stringify!(decrypt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).eksize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_HyperledgerClient_DKParams),
            "::",
            stringify!(eksize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).evsize) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_HyperledgerClient_DKParams),
            "::",
            stringify!(evsize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).big_endian) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_HyperledgerClient_DKParams),
            "::",
            stringify!(big_endian)
        )
    );
}
impl Default for M_DeriveMech_HyperledgerClient_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_KDPEncoding_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_KDPEncoding {
    pub flags: M_KDPEncoding_flags,
    pub type_: M_Word,
    pub kind: M_Word,
    pub details: M_Word,
    pub duration: M_Word,
}
#[test]
fn bindgen_test_layout_M_KDPEncoding() {
    const UNINIT: ::core::mem::MaybeUninit<M_KDPEncoding> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_KDPEncoding>(),
        20usize,
        concat!("Size of: ", stringify!(M_KDPEncoding))
    );
    assert_eq!(
        ::core::mem::align_of::<M_KDPEncoding>(),
        4usize,
        concat!("Alignment of ", stringify!(M_KDPEncoding))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KDPEncoding),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KDPEncoding),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kind) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KDPEncoding),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).details) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KDPEncoding),
            "::",
            stringify!(details)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).duration) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KDPEncoding),
            "::",
            stringify!(duration)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_DeriveMech_KDPKeyWrapDES3_DKParams {
    pub policy: M_KDPEncoding,
}
#[test]
fn bindgen_test_layout_M_DeriveMech_KDPKeyWrapDES3_DKParams() {
    const UNINIT: ::core::mem::MaybeUninit<M_DeriveMech_KDPKeyWrapDES3_DKParams> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_DeriveMech_KDPKeyWrapDES3_DKParams>(),
        20usize,
        concat!(
            "Size of: ",
            stringify!(M_DeriveMech_KDPKeyWrapDES3_DKParams)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<M_DeriveMech_KDPKeyWrapDES3_DKParams>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(M_DeriveMech_KDPKeyWrapDES3_DKParams)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).policy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_KDPKeyWrapDES3_DKParams),
            "::",
            stringify!(policy)
        )
    );
}
pub type M_DeriveMech_NISTKDFmCTRpRijndaelCMACr32_DKParams_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_DeriveMech_NISTKDFmCTRpRijndaelCMACr32_DKParams {
    pub flags: M_DeriveMech_NISTKDFmCTRpRijndaelCMACr32_DKParams_flags,
    pub keylen: M_Word,
    pub keytype: M_KeyType,
    pub context: M_ByteBlock,
    pub label: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_DeriveMech_NISTKDFmCTRpRijndaelCMACr32_DKParams() {
    const UNINIT: ::core::mem::MaybeUninit<M_DeriveMech_NISTKDFmCTRpRijndaelCMACr32_DKParams> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_DeriveMech_NISTKDFmCTRpRijndaelCMACr32_DKParams>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(M_DeriveMech_NISTKDFmCTRpRijndaelCMACr32_DKParams)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<M_DeriveMech_NISTKDFmCTRpRijndaelCMACr32_DKParams>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(M_DeriveMech_NISTKDFmCTRpRijndaelCMACr32_DKParams)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_NISTKDFmCTRpRijndaelCMACr32_DKParams),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).keylen) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_NISTKDFmCTRpRijndaelCMACr32_DKParams),
            "::",
            stringify!(keylen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).keytype) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_NISTKDFmCTRpRijndaelCMACr32_DKParams),
            "::",
            stringify!(keytype)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).context) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_NISTKDFmCTRpRijndaelCMACr32_DKParams),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).label) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_NISTKDFmCTRpRijndaelCMACr32_DKParams),
            "::",
            stringify!(label)
        )
    );
}
impl Default for M_DeriveMech_NISTKDFmCTRpRijndaelCMACr32_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_DeriveMech_NISTKDFmCTRr8_DKParams_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_DeriveMech_NISTKDFmCTRr8_DKParams {
    pub flags: M_DeriveMech_NISTKDFmCTRr8_DKParams_flags,
    pub keylen: M_Word,
    pub keytype: M_KeyType,
    pub prf: M_Mech,
    pub context: M_ByteBlock,
    pub label: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_DeriveMech_NISTKDFmCTRr8_DKParams() {
    const UNINIT: ::core::mem::MaybeUninit<M_DeriveMech_NISTKDFmCTRr8_DKParams> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_DeriveMech_NISTKDFmCTRr8_DKParams>(),
        48usize,
        concat!("Size of: ", stringify!(M_DeriveMech_NISTKDFmCTRr8_DKParams))
    );
    assert_eq!(
        ::core::mem::align_of::<M_DeriveMech_NISTKDFmCTRr8_DKParams>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(M_DeriveMech_NISTKDFmCTRr8_DKParams)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_NISTKDFmCTRr8_DKParams),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).keylen) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_NISTKDFmCTRr8_DKParams),
            "::",
            stringify!(keylen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).keytype) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_NISTKDFmCTRr8_DKParams),
            "::",
            stringify!(keytype)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prf) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_NISTKDFmCTRr8_DKParams),
            "::",
            stringify!(prf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).context) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_NISTKDFmCTRr8_DKParams),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).label) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_NISTKDFmCTRr8_DKParams),
            "::",
            stringify!(label)
        )
    );
}
impl Default for M_DeriveMech_NISTKDFmCTRr8_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_IV {
    pub mech: M_Mech,
    pub iv: M_Mech__IV,
}
#[test]
fn bindgen_test_layout_M_IV() {
    const UNINIT: ::core::mem::MaybeUninit<M_IV> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_IV>(),
        48usize,
        concat!("Size of: ", stringify!(M_IV))
    );
    assert_eq!(
        ::core::mem::align_of::<M_IV>(),
        8usize,
        concat!("Alignment of ", stringify!(M_IV))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mech) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_IV),
            "::",
            stringify!(mech)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iv) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(M_IV), "::", stringify!(iv))
    );
}
impl Default for M_IV {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_IV {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_IV {{ mech: {:?}, iv: {:?} }}", self.mech, self.iv)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_DeriveMech_PKCS8Decrypt_DKParams {
    pub iv: M_IV,
}
#[test]
fn bindgen_test_layout_M_DeriveMech_PKCS8Decrypt_DKParams() {
    const UNINIT: ::core::mem::MaybeUninit<M_DeriveMech_PKCS8Decrypt_DKParams> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_DeriveMech_PKCS8Decrypt_DKParams>(),
        48usize,
        concat!("Size of: ", stringify!(M_DeriveMech_PKCS8Decrypt_DKParams))
    );
    assert_eq!(
        ::core::mem::align_of::<M_DeriveMech_PKCS8Decrypt_DKParams>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(M_DeriveMech_PKCS8Decrypt_DKParams)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iv) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_PKCS8Decrypt_DKParams),
            "::",
            stringify!(iv)
        )
    );
}
impl Default for M_DeriveMech_PKCS8Decrypt_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_DeriveMech_PKCS8Decrypt_DKParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_DeriveMech_PKCS8Decrypt_DKParams {{ iv: {:?} }}",
            self.iv
        )
    }
}
pub type M_DeriveMech_PKCS8DecryptEx_DKParams_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_DeriveMech_PKCS8DecryptEx_DKParams {
    pub flags: M_DeriveMech_PKCS8DecryptEx_DKParams_flags,
    pub iv: M_IV,
    pub keytype: *mut M_PKCS8PreferredKeyType,
}
#[test]
fn bindgen_test_layout_M_DeriveMech_PKCS8DecryptEx_DKParams() {
    const UNINIT: ::core::mem::MaybeUninit<M_DeriveMech_PKCS8DecryptEx_DKParams> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_DeriveMech_PKCS8DecryptEx_DKParams>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(M_DeriveMech_PKCS8DecryptEx_DKParams)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<M_DeriveMech_PKCS8DecryptEx_DKParams>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(M_DeriveMech_PKCS8DecryptEx_DKParams)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_PKCS8DecryptEx_DKParams),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iv) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_PKCS8DecryptEx_DKParams),
            "::",
            stringify!(iv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).keytype) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_PKCS8DecryptEx_DKParams),
            "::",
            stringify!(keytype)
        )
    );
}
impl Default for M_DeriveMech_PKCS8DecryptEx_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_DeriveMech_PKCS8DecryptEx_DKParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_DeriveMech_PKCS8DecryptEx_DKParams {{ flags: {:?}, iv: {:?}, keytype: {:?} }}",
            self.flags, self.iv, self.keytype
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_DeriveMech_PKCS8Encrypt_DKParams {
    pub iv: M_IV,
}
#[test]
fn bindgen_test_layout_M_DeriveMech_PKCS8Encrypt_DKParams() {
    const UNINIT: ::core::mem::MaybeUninit<M_DeriveMech_PKCS8Encrypt_DKParams> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_DeriveMech_PKCS8Encrypt_DKParams>(),
        48usize,
        concat!("Size of: ", stringify!(M_DeriveMech_PKCS8Encrypt_DKParams))
    );
    assert_eq!(
        ::core::mem::align_of::<M_DeriveMech_PKCS8Encrypt_DKParams>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(M_DeriveMech_PKCS8Encrypt_DKParams)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iv) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_PKCS8Encrypt_DKParams),
            "::",
            stringify!(iv)
        )
    );
}
impl Default for M_DeriveMech_PKCS8Encrypt_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_DeriveMech_PKCS8Encrypt_DKParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_DeriveMech_PKCS8Encrypt_DKParams {{ iv: {:?} }}",
            self.iv
        )
    }
}
pub type M_vec_IV = *mut M_IV;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_DeriveMech_RSAComponents_DKParams {
    pub n_ivs: ::core::ffi::c_int,
    pub ivs: M_vec_IV,
}
#[test]
fn bindgen_test_layout_M_DeriveMech_RSAComponents_DKParams() {
    const UNINIT: ::core::mem::MaybeUninit<M_DeriveMech_RSAComponents_DKParams> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_DeriveMech_RSAComponents_DKParams>(),
        16usize,
        concat!("Size of: ", stringify!(M_DeriveMech_RSAComponents_DKParams))
    );
    assert_eq!(
        ::core::mem::align_of::<M_DeriveMech_RSAComponents_DKParams>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(M_DeriveMech_RSAComponents_DKParams)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_ivs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_RSAComponents_DKParams),
            "::",
            stringify!(n_ivs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ivs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_RSAComponents_DKParams),
            "::",
            stringify!(ivs)
        )
    );
}
impl Default for M_DeriveMech_RSAComponents_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_DeriveMech_RawDecrypt_DKParams {
    pub iv: M_IV,
    pub dst_type: M_KeyType,
}
#[test]
fn bindgen_test_layout_M_DeriveMech_RawDecrypt_DKParams() {
    const UNINIT: ::core::mem::MaybeUninit<M_DeriveMech_RawDecrypt_DKParams> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_DeriveMech_RawDecrypt_DKParams>(),
        56usize,
        concat!("Size of: ", stringify!(M_DeriveMech_RawDecrypt_DKParams))
    );
    assert_eq!(
        ::core::mem::align_of::<M_DeriveMech_RawDecrypt_DKParams>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(M_DeriveMech_RawDecrypt_DKParams)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iv) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_RawDecrypt_DKParams),
            "::",
            stringify!(iv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dst_type) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_RawDecrypt_DKParams),
            "::",
            stringify!(dst_type)
        )
    );
}
impl Default for M_DeriveMech_RawDecrypt_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_DeriveMech_RawDecrypt_DKParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_DeriveMech_RawDecrypt_DKParams {{ iv: {:?}, dst_type: {:?} }}",
            self.iv, self.dst_type
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_DeriveMech_RawDecryptZeroPad_DKParams {
    pub iv: M_IV,
    pub dst_type: M_KeyType,
    pub padlen: M_Word,
}
#[test]
fn bindgen_test_layout_M_DeriveMech_RawDecryptZeroPad_DKParams() {
    const UNINIT: ::core::mem::MaybeUninit<M_DeriveMech_RawDecryptZeroPad_DKParams> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_DeriveMech_RawDecryptZeroPad_DKParams>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(M_DeriveMech_RawDecryptZeroPad_DKParams)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<M_DeriveMech_RawDecryptZeroPad_DKParams>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(M_DeriveMech_RawDecryptZeroPad_DKParams)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iv) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_RawDecryptZeroPad_DKParams),
            "::",
            stringify!(iv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dst_type) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_RawDecryptZeroPad_DKParams),
            "::",
            stringify!(dst_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padlen) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_RawDecryptZeroPad_DKParams),
            "::",
            stringify!(padlen)
        )
    );
}
impl Default for M_DeriveMech_RawDecryptZeroPad_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_DeriveMech_RawDecryptZeroPad_DKParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_DeriveMech_RawDecryptZeroPad_DKParams {{ iv: {:?}, dst_type: {:?}, padlen: {:?} }}",
            self.iv, self.dst_type, self.padlen
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_DeriveMech_RawEncrypt_DKParams {
    pub iv: M_IV,
}
#[test]
fn bindgen_test_layout_M_DeriveMech_RawEncrypt_DKParams() {
    const UNINIT: ::core::mem::MaybeUninit<M_DeriveMech_RawEncrypt_DKParams> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_DeriveMech_RawEncrypt_DKParams>(),
        48usize,
        concat!("Size of: ", stringify!(M_DeriveMech_RawEncrypt_DKParams))
    );
    assert_eq!(
        ::core::mem::align_of::<M_DeriveMech_RawEncrypt_DKParams>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(M_DeriveMech_RawEncrypt_DKParams)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iv) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_RawEncrypt_DKParams),
            "::",
            stringify!(iv)
        )
    );
}
impl Default for M_DeriveMech_RawEncrypt_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_DeriveMech_RawEncrypt_DKParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_DeriveMech_RawEncrypt_DKParams {{ iv: {:?} }}",
            self.iv
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_DeriveMech_RawEncryptZeroPad_DKParams {
    pub iv: M_IV,
    pub padlen: M_Word,
}
#[test]
fn bindgen_test_layout_M_DeriveMech_RawEncryptZeroPad_DKParams() {
    const UNINIT: ::core::mem::MaybeUninit<M_DeriveMech_RawEncryptZeroPad_DKParams> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_DeriveMech_RawEncryptZeroPad_DKParams>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(M_DeriveMech_RawEncryptZeroPad_DKParams)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<M_DeriveMech_RawEncryptZeroPad_DKParams>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(M_DeriveMech_RawEncryptZeroPad_DKParams)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iv) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_RawEncryptZeroPad_DKParams),
            "::",
            stringify!(iv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padlen) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_RawEncryptZeroPad_DKParams),
            "::",
            stringify!(padlen)
        )
    );
}
impl Default for M_DeriveMech_RawEncryptZeroPad_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_DeriveMech_RawEncryptZeroPad_DKParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_DeriveMech_RawEncryptZeroPad_DKParams {{ iv: {:?}, padlen: {:?} }}",
            self.iv, self.padlen
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_SSLClientRandom {
    pub bytes: [::core::ffi::c_uchar; 32usize],
    pub words: [M_Word; 8usize],
}
#[test]
fn bindgen_test_layout_M_SSLClientRandom() {
    const UNINIT: ::core::mem::MaybeUninit<M_SSLClientRandom> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_SSLClientRandom>(),
        32usize,
        concat!("Size of: ", stringify!(M_SSLClientRandom))
    );
    assert_eq!(
        ::core::mem::align_of::<M_SSLClientRandom>(),
        4usize,
        concat!("Alignment of ", stringify!(M_SSLClientRandom))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_SSLClientRandom),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).words) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_SSLClientRandom),
            "::",
            stringify!(words)
        )
    );
}
impl Default for M_SSLClientRandom {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_SSLClientRandom {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_SSLClientRandom {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_SSLServerRandom {
    pub bytes: [::core::ffi::c_uchar; 32usize],
    pub words: [M_Word; 8usize],
}
#[test]
fn bindgen_test_layout_M_SSLServerRandom() {
    const UNINIT: ::core::mem::MaybeUninit<M_SSLServerRandom> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_SSLServerRandom>(),
        32usize,
        concat!("Size of: ", stringify!(M_SSLServerRandom))
    );
    assert_eq!(
        ::core::mem::align_of::<M_SSLServerRandom>(),
        4usize,
        concat!("Alignment of ", stringify!(M_SSLServerRandom))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_SSLServerRandom),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).words) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_SSLServerRandom),
            "::",
            stringify!(words)
        )
    );
}
impl Default for M_SSLServerRandom {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_SSLServerRandom {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_SSLServerRandom {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_DeriveMech_SSL3withDH_DKParams {
    pub y: M_Bignum,
    pub crnd: M_SSLClientRandom,
    pub srnd: M_SSLServerRandom,
}
#[test]
fn bindgen_test_layout_M_DeriveMech_SSL3withDH_DKParams() {
    const UNINIT: ::core::mem::MaybeUninit<M_DeriveMech_SSL3withDH_DKParams> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_DeriveMech_SSL3withDH_DKParams>(),
        72usize,
        concat!("Size of: ", stringify!(M_DeriveMech_SSL3withDH_DKParams))
    );
    assert_eq!(
        ::core::mem::align_of::<M_DeriveMech_SSL3withDH_DKParams>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(M_DeriveMech_SSL3withDH_DKParams)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_SSL3withDH_DKParams),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).crnd) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_SSL3withDH_DKParams),
            "::",
            stringify!(crnd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).srnd) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_SSL3withDH_DKParams),
            "::",
            stringify!(srnd)
        )
    );
}
impl Default for M_DeriveMech_SSL3withDH_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_DeriveMech_SSL3withDH_DKParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_DeriveMech_SSL3withDH_DKParams {{ y: {:?}, crnd: {:?}, srnd: {:?} }}",
            self.y, self.crnd, self.srnd
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_DeriveMech_SSL3withRSA_DKParams {
    pub ct: M_Bignum,
    pub crnd: M_SSLClientRandom,
    pub srnd: M_SSLServerRandom,
}
#[test]
fn bindgen_test_layout_M_DeriveMech_SSL3withRSA_DKParams() {
    const UNINIT: ::core::mem::MaybeUninit<M_DeriveMech_SSL3withRSA_DKParams> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_DeriveMech_SSL3withRSA_DKParams>(),
        72usize,
        concat!("Size of: ", stringify!(M_DeriveMech_SSL3withRSA_DKParams))
    );
    assert_eq!(
        ::core::mem::align_of::<M_DeriveMech_SSL3withRSA_DKParams>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(M_DeriveMech_SSL3withRSA_DKParams)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ct) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_SSL3withRSA_DKParams),
            "::",
            stringify!(ct)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).crnd) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_SSL3withRSA_DKParams),
            "::",
            stringify!(crnd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).srnd) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_SSL3withRSA_DKParams),
            "::",
            stringify!(srnd)
        )
    );
}
impl Default for M_DeriveMech_SSL3withRSA_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_DeriveMech_SSL3withRSA_DKParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_DeriveMech_SSL3withRSA_DKParams {{ ct: {:?}, crnd: {:?}, srnd: {:?} }}",
            self.ct, self.crnd, self.srnd
        )
    }
}
pub type M_DeriveMech_SignedKDPKeyWrapDES3_DKParams_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_DeriveMech_SignedKDPKeyWrapDES3_DKParams {
    pub flags: M_DeriveMech_SignedKDPKeyWrapDES3_DKParams_flags,
    pub mech: M_Mech,
    pub beginauth: M_ByteBlock,
    pub sig: M_CipherText,
}
#[test]
fn bindgen_test_layout_M_DeriveMech_SignedKDPKeyWrapDES3_DKParams() {
    const UNINIT: ::core::mem::MaybeUninit<M_DeriveMech_SignedKDPKeyWrapDES3_DKParams> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_DeriveMech_SignedKDPKeyWrapDES3_DKParams>(),
        136usize,
        concat!(
            "Size of: ",
            stringify!(M_DeriveMech_SignedKDPKeyWrapDES3_DKParams)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<M_DeriveMech_SignedKDPKeyWrapDES3_DKParams>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(M_DeriveMech_SignedKDPKeyWrapDES3_DKParams)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_SignedKDPKeyWrapDES3_DKParams),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mech) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_SignedKDPKeyWrapDES3_DKParams),
            "::",
            stringify!(mech)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).beginauth) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_SignedKDPKeyWrapDES3_DKParams),
            "::",
            stringify!(beginauth)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sig) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_SignedKDPKeyWrapDES3_DKParams),
            "::",
            stringify!(sig)
        )
    );
}
impl Default for M_DeriveMech_SignedKDPKeyWrapDES3_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_DeriveMech_SignedKDPKeyWrapDES3_DKParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_DeriveMech_SignedKDPKeyWrapDES3_DKParams {{ flags: {:?}, mech: {:?}, beginauth: {:?}, sig: {:?} }}" , self . flags , self . mech , self . beginauth , self . sig)
    }
}
pub type M_DeriveMech_TUAKTOPC_DKParams_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_DeriveMech_TUAKTOPC_DKParams {
    pub flags: M_DeriveMech_TUAKTOPC_DKParams_flags,
    pub iterations: M_Word,
}
#[test]
fn bindgen_test_layout_M_DeriveMech_TUAKTOPC_DKParams() {
    const UNINIT: ::core::mem::MaybeUninit<M_DeriveMech_TUAKTOPC_DKParams> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_DeriveMech_TUAKTOPC_DKParams>(),
        8usize,
        concat!("Size of: ", stringify!(M_DeriveMech_TUAKTOPC_DKParams))
    );
    assert_eq!(
        ::core::mem::align_of::<M_DeriveMech_TUAKTOPC_DKParams>(),
        4usize,
        concat!("Alignment of ", stringify!(M_DeriveMech_TUAKTOPC_DKParams))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_TUAKTOPC_DKParams),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iterations) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_TUAKTOPC_DKParams),
            "::",
            stringify!(iterations)
        )
    );
}
pub type M_DeriveMech_TUAKf1_DKParams_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_TUAKRandom {
    pub bytes: [::core::ffi::c_uchar; 16usize],
    pub words: [M_Word; 4usize],
}
#[test]
fn bindgen_test_layout_M_TUAKRandom() {
    const UNINIT: ::core::mem::MaybeUninit<M_TUAKRandom> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_TUAKRandom>(),
        16usize,
        concat!("Size of: ", stringify!(M_TUAKRandom))
    );
    assert_eq!(
        ::core::mem::align_of::<M_TUAKRandom>(),
        4usize,
        concat!("Alignment of ", stringify!(M_TUAKRandom))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_TUAKRandom),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).words) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_TUAKRandom),
            "::",
            stringify!(words)
        )
    );
}
impl Default for M_TUAKRandom {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_TUAKRandom {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_TUAKRandom {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_TUAKSequence {
    pub bytes: [::core::ffi::c_uchar; 6usize],
}
#[test]
fn bindgen_test_layout_M_TUAKSequence() {
    const UNINIT: ::core::mem::MaybeUninit<M_TUAKSequence> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_TUAKSequence>(),
        6usize,
        concat!("Size of: ", stringify!(M_TUAKSequence))
    );
    assert_eq!(
        ::core::mem::align_of::<M_TUAKSequence>(),
        1usize,
        concat!("Alignment of ", stringify!(M_TUAKSequence))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_TUAKSequence),
            "::",
            stringify!(bytes)
        )
    );
}
impl Default for M_TUAKSequence {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_TUAKSequence {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_TUAKSequence {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_TUAKAMF {
    pub bytes: [::core::ffi::c_uchar; 2usize],
}
#[test]
fn bindgen_test_layout_M_TUAKAMF() {
    const UNINIT: ::core::mem::MaybeUninit<M_TUAKAMF> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_TUAKAMF>(),
        2usize,
        concat!("Size of: ", stringify!(M_TUAKAMF))
    );
    assert_eq!(
        ::core::mem::align_of::<M_TUAKAMF>(),
        1usize,
        concat!("Alignment of ", stringify!(M_TUAKAMF))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_TUAKAMF),
            "::",
            stringify!(bytes)
        )
    );
}
impl Default for M_TUAKAMF {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_TUAKAMF {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_TUAKAMF {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_DeriveMech_TUAKf1_DKParams {
    pub flags: M_DeriveMech_TUAKf1_DKParams_flags,
    pub maclen: M_Word,
    pub keytype: M_KeyType,
    pub rand: M_TUAKRandom,
    pub sqn: M_TUAKSequence,
    pub amf: M_TUAKAMF,
    pub iterations: M_Word,
}
#[test]
fn bindgen_test_layout_M_DeriveMech_TUAKf1_DKParams() {
    const UNINIT: ::core::mem::MaybeUninit<M_DeriveMech_TUAKf1_DKParams> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_DeriveMech_TUAKf1_DKParams>(),
        40usize,
        concat!("Size of: ", stringify!(M_DeriveMech_TUAKf1_DKParams))
    );
    assert_eq!(
        ::core::mem::align_of::<M_DeriveMech_TUAKf1_DKParams>(),
        4usize,
        concat!("Alignment of ", stringify!(M_DeriveMech_TUAKf1_DKParams))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_TUAKf1_DKParams),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).maclen) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_TUAKf1_DKParams),
            "::",
            stringify!(maclen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).keytype) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_TUAKf1_DKParams),
            "::",
            stringify!(keytype)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rand) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_TUAKf1_DKParams),
            "::",
            stringify!(rand)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sqn) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_TUAKf1_DKParams),
            "::",
            stringify!(sqn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).amf) as usize - ptr as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_TUAKf1_DKParams),
            "::",
            stringify!(amf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iterations) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_TUAKf1_DKParams),
            "::",
            stringify!(iterations)
        )
    );
}
impl Default for M_DeriveMech_TUAKf1_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_DeriveMech_TUAKf1_DKParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_DeriveMech_TUAKf1_DKParams {{ flags: {:?}, maclen: {:?}, keytype: {:?}, rand: {:?}, sqn: {:?}, amf: {:?}, iterations: {:?} }}" , self . flags , self . maclen , self . keytype , self . rand , self . sqn , self . amf , self . iterations)
    }
}
pub type M_DeriveMech_TUAKf2345_DKParams_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_DeriveMech_TUAKf2345_DKParams {
    pub flags: M_DeriveMech_TUAKf2345_DKParams_flags,
    pub keytype: M_KeyType,
    pub rand: M_TUAKRandom,
    pub iterations: M_Word,
    pub reslen: M_Word,
    pub cklen: M_Word,
    pub iklen: M_Word,
}
#[test]
fn bindgen_test_layout_M_DeriveMech_TUAKf2345_DKParams() {
    const UNINIT: ::core::mem::MaybeUninit<M_DeriveMech_TUAKf2345_DKParams> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_DeriveMech_TUAKf2345_DKParams>(),
        40usize,
        concat!("Size of: ", stringify!(M_DeriveMech_TUAKf2345_DKParams))
    );
    assert_eq!(
        ::core::mem::align_of::<M_DeriveMech_TUAKf2345_DKParams>(),
        4usize,
        concat!("Alignment of ", stringify!(M_DeriveMech_TUAKf2345_DKParams))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_TUAKf2345_DKParams),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).keytype) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_TUAKf2345_DKParams),
            "::",
            stringify!(keytype)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rand) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_TUAKf2345_DKParams),
            "::",
            stringify!(rand)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iterations) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_TUAKf2345_DKParams),
            "::",
            stringify!(iterations)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reslen) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_TUAKf2345_DKParams),
            "::",
            stringify!(reslen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cklen) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_TUAKf2345_DKParams),
            "::",
            stringify!(cklen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iklen) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_TUAKf2345_DKParams),
            "::",
            stringify!(iklen)
        )
    );
}
impl Default for M_DeriveMech_TUAKf2345_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_DeriveMech_TUAKf2345_DKParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_DeriveMech_TUAKf2345_DKParams {{ flags: {:?}, keytype: {:?}, rand: {:?}, iterations: {:?}, reslen: {:?}, cklen: {:?}, iklen: {:?} }}" , self . flags , self . keytype , self . rand , self . iterations , self . reslen , self . cklen , self . iklen)
    }
}
pub type M_DeriveMech_TUAKf5s_DKParams_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_DeriveMech_TUAKf5s_DKParams {
    pub flags: M_DeriveMech_TUAKf5s_DKParams_flags,
    pub keytype: M_KeyType,
    pub rand: M_TUAKRandom,
    pub iterations: M_Word,
}
#[test]
fn bindgen_test_layout_M_DeriveMech_TUAKf5s_DKParams() {
    const UNINIT: ::core::mem::MaybeUninit<M_DeriveMech_TUAKf5s_DKParams> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_DeriveMech_TUAKf5s_DKParams>(),
        28usize,
        concat!("Size of: ", stringify!(M_DeriveMech_TUAKf5s_DKParams))
    );
    assert_eq!(
        ::core::mem::align_of::<M_DeriveMech_TUAKf5s_DKParams>(),
        4usize,
        concat!("Alignment of ", stringify!(M_DeriveMech_TUAKf5s_DKParams))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_TUAKf5s_DKParams),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).keytype) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_TUAKf5s_DKParams),
            "::",
            stringify!(keytype)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rand) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_TUAKf5s_DKParams),
            "::",
            stringify!(rand)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iterations) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_TUAKf5s_DKParams),
            "::",
            stringify!(iterations)
        )
    );
}
impl Default for M_DeriveMech_TUAKf5s_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_DeriveMech_TUAKf5s_DKParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_DeriveMech_TUAKf5s_DKParams {{ flags: {:?}, keytype: {:?}, rand: {:?}, iterations: {:?} }}" , self . flags , self . keytype , self . rand , self . iterations)
    }
}
pub type M_DeriveMech_TestKX_DKParams_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_DeriveMech_TestKX_DKParams {
    pub flags: M_DeriveMech_TestKX_DKParams_flags,
    pub group: M_TestKXGroup,
    pub sessionkey: M_TestKXSessionKey,
    pub localnonce: M_ByteBlock,
    pub localname: M_ByteBlock,
    pub remotenonce: M_ByteBlock,
    pub remotename: M_ByteBlock,
    pub remotekey: M_KeyData,
}
#[test]
fn bindgen_test_layout_M_DeriveMech_TestKX_DKParams() {
    const UNINIT: ::core::mem::MaybeUninit<M_DeriveMech_TestKX_DKParams> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_DeriveMech_TestKX_DKParams>(),
        208usize,
        concat!("Size of: ", stringify!(M_DeriveMech_TestKX_DKParams))
    );
    assert_eq!(
        ::core::mem::align_of::<M_DeriveMech_TestKX_DKParams>(),
        8usize,
        concat!("Alignment of ", stringify!(M_DeriveMech_TestKX_DKParams))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_TestKX_DKParams),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).group) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_TestKX_DKParams),
            "::",
            stringify!(group)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sessionkey) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_TestKX_DKParams),
            "::",
            stringify!(sessionkey)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).localnonce) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_TestKX_DKParams),
            "::",
            stringify!(localnonce)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).localname) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_TestKX_DKParams),
            "::",
            stringify!(localname)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).remotenonce) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_TestKX_DKParams),
            "::",
            stringify!(remotenonce)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).remotename) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_TestKX_DKParams),
            "::",
            stringify!(remotename)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).remotekey) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech_TestKX_DKParams),
            "::",
            stringify!(remotekey)
        )
    );
}
impl Default for M_DeriveMech_TestKX_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_DeriveMech_TestKX_DKParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_DeriveMech_TestKX_DKParams {{ flags: {:?}, group: {:?}, sessionkey: {:?}, localnonce: {:?}, localname: {:?}, remotenonce: {:?}, remotename: {:?}, remotekey: {:?} }}" , self . flags , self . group , self . sessionkey , self . localnonce , self . localname , self . remotenonce , self . remotename , self . remotekey)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_DeriveMech__DKParams {
    pub aeskeyunwrap: M_DeriveMech_AESKeyUnwrap_DKParams,
    pub aeskeywrap: M_DeriveMech_AESKeyWrap_DKParams,
    pub compositearqcverify: M_DeriveMech_CompositeARQCVerify_DKParams,
    pub compositewatchwordsign: M_DeriveMech_CompositeWatchWordSign_DKParams,
    pub compositewatchwordverify: M_DeriveMech_CompositeWatchWordVerify_DKParams,
    pub concatenatebytes: M_DeriveMech_ConcatenateBytes_DKParams,
    pub concatenationkdf: M_DeriveMech_ConcatenationKDF_DKParams,
    pub eccmqv: M_DeriveMech_ECCMQV_DKParams,
    pub eccmqvdnistckdf: M_DeriveMech_ECCMQVdNISTCKDF_DKParams,
    pub ecdhka: M_DeriveMech_ECDHKA_DKParams,
    pub ecieskeyunwrap: M_DeriveMech_ECIESKeyUnwrap_DKParams,
    pub ecieskeywrap: M_DeriveMech_ECIESKeyWrap_DKParams,
    pub generatersab36: M_DeriveMech_GenerateRSAB36_DKParams,
    pub hyperledgerclient: M_DeriveMech_HyperledgerClient_DKParams,
    pub kdpkeywrapdes3: M_DeriveMech_KDPKeyWrapDES3_DKParams,
    pub nistkdfmctrprijndaelcmacr32: M_DeriveMech_NISTKDFmCTRpRijndaelCMACr32_DKParams,
    pub nistkdfmctrr8: M_DeriveMech_NISTKDFmCTRr8_DKParams,
    pub pkcs8decrypt: M_DeriveMech_PKCS8Decrypt_DKParams,
    pub pkcs8decryptex: M_DeriveMech_PKCS8DecryptEx_DKParams,
    pub pkcs8encrypt: M_DeriveMech_PKCS8Encrypt_DKParams,
    pub rsacomponents: M_DeriveMech_RSAComponents_DKParams,
    pub rawdecrypt: M_DeriveMech_RawDecrypt_DKParams,
    pub rawdecryptzeropad: M_DeriveMech_RawDecryptZeroPad_DKParams,
    pub rawencrypt: M_DeriveMech_RawEncrypt_DKParams,
    pub rawencryptzeropad: M_DeriveMech_RawEncryptZeroPad_DKParams,
    pub ssl3withdh: M_DeriveMech_SSL3withDH_DKParams,
    pub ssl3withrsa: M_DeriveMech_SSL3withRSA_DKParams,
    pub signedkdpkeywrapdes3: M_DeriveMech_SignedKDPKeyWrapDES3_DKParams,
    pub tuaktopc: M_DeriveMech_TUAKTOPC_DKParams,
    pub tuakf1: M_DeriveMech_TUAKf1_DKParams,
    pub tuakf2345: M_DeriveMech_TUAKf2345_DKParams,
    pub tuakf5s: M_DeriveMech_TUAKf5s_DKParams,
    pub testkx: M_DeriveMech_TestKX_DKParams,
}
#[test]
fn bindgen_test_layout_M_DeriveMech__DKParams() {
    const UNINIT: ::core::mem::MaybeUninit<M_DeriveMech__DKParams> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_DeriveMech__DKParams>(),
        208usize,
        concat!("Size of: ", stringify!(M_DeriveMech__DKParams))
    );
    assert_eq!(
        ::core::mem::align_of::<M_DeriveMech__DKParams>(),
        8usize,
        concat!("Alignment of ", stringify!(M_DeriveMech__DKParams))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).aeskeyunwrap) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech__DKParams),
            "::",
            stringify!(aeskeyunwrap)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).aeskeywrap) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech__DKParams),
            "::",
            stringify!(aeskeywrap)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).compositearqcverify) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech__DKParams),
            "::",
            stringify!(compositearqcverify)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).compositewatchwordsign) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech__DKParams),
            "::",
            stringify!(compositewatchwordsign)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).compositewatchwordverify) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech__DKParams),
            "::",
            stringify!(compositewatchwordverify)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).concatenatebytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech__DKParams),
            "::",
            stringify!(concatenatebytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).concatenationkdf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech__DKParams),
            "::",
            stringify!(concatenationkdf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).eccmqv) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech__DKParams),
            "::",
            stringify!(eccmqv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).eccmqvdnistckdf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech__DKParams),
            "::",
            stringify!(eccmqvdnistckdf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ecdhka) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech__DKParams),
            "::",
            stringify!(ecdhka)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ecieskeyunwrap) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech__DKParams),
            "::",
            stringify!(ecieskeyunwrap)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ecieskeywrap) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech__DKParams),
            "::",
            stringify!(ecieskeywrap)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).generatersab36) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech__DKParams),
            "::",
            stringify!(generatersab36)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hyperledgerclient) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech__DKParams),
            "::",
            stringify!(hyperledgerclient)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kdpkeywrapdes3) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech__DKParams),
            "::",
            stringify!(kdpkeywrapdes3)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).nistkdfmctrprijndaelcmacr32) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech__DKParams),
            "::",
            stringify!(nistkdfmctrprijndaelcmacr32)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nistkdfmctrr8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech__DKParams),
            "::",
            stringify!(nistkdfmctrr8)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pkcs8decrypt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech__DKParams),
            "::",
            stringify!(pkcs8decrypt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pkcs8decryptex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech__DKParams),
            "::",
            stringify!(pkcs8decryptex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pkcs8encrypt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech__DKParams),
            "::",
            stringify!(pkcs8encrypt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rsacomponents) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech__DKParams),
            "::",
            stringify!(rsacomponents)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rawdecrypt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech__DKParams),
            "::",
            stringify!(rawdecrypt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rawdecryptzeropad) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech__DKParams),
            "::",
            stringify!(rawdecryptzeropad)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rawencrypt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech__DKParams),
            "::",
            stringify!(rawencrypt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rawencryptzeropad) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech__DKParams),
            "::",
            stringify!(rawencryptzeropad)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ssl3withdh) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech__DKParams),
            "::",
            stringify!(ssl3withdh)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ssl3withrsa) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech__DKParams),
            "::",
            stringify!(ssl3withrsa)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).signedkdpkeywrapdes3) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech__DKParams),
            "::",
            stringify!(signedkdpkeywrapdes3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tuaktopc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech__DKParams),
            "::",
            stringify!(tuaktopc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tuakf1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech__DKParams),
            "::",
            stringify!(tuakf1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tuakf2345) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech__DKParams),
            "::",
            stringify!(tuakf2345)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tuakf5s) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech__DKParams),
            "::",
            stringify!(tuakf5s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).testkx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeriveMech__DKParams),
            "::",
            stringify!(testkx)
        )
    );
}
impl Default for M_DeriveMech__DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_DeriveMech__DKParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_DeriveMech__DKParams {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_DKMechParams {
    pub mech: M_DeriveMech,
    pub params: M_DeriveMech__DKParams,
}
#[test]
fn bindgen_test_layout_M_DKMechParams() {
    const UNINIT: ::core::mem::MaybeUninit<M_DKMechParams> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_DKMechParams>(),
        216usize,
        concat!("Size of: ", stringify!(M_DKMechParams))
    );
    assert_eq!(
        ::core::mem::align_of::<M_DKMechParams>(),
        8usize,
        concat!("Alignment of ", stringify!(M_DKMechParams))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mech) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DKMechParams),
            "::",
            stringify!(mech)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).params) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DKMechParams),
            "::",
            stringify!(params)
        )
    );
}
impl Default for M_DKMechParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_DKMechParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_DKMechParams {{ mech: {:?}, params: {:?} }}",
            self.mech, self.params
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_PKCS8PreferredKeyType {
    pub keytype: M_KeyType,
}
#[test]
fn bindgen_test_layout_M_PKCS8PreferredKeyType() {
    const UNINIT: ::core::mem::MaybeUninit<M_PKCS8PreferredKeyType> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_PKCS8PreferredKeyType>(),
        4usize,
        concat!("Size of: ", stringify!(M_PKCS8PreferredKeyType))
    );
    assert_eq!(
        ::core::mem::align_of::<M_PKCS8PreferredKeyType>(),
        4usize,
        concat!("Alignment of ", stringify!(M_PKCS8PreferredKeyType))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).keytype) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_PKCS8PreferredKeyType),
            "::",
            stringify!(keytype)
        )
    );
}
impl Default for M_PKCS8PreferredKeyType {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_RemoteServerPermission_flags = M_Word;
pub type M_vec_HostVolumeDesc = *mut M_HostVolumeDesc;
pub type M_RemoteServerOp_AccessFiles_Details_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_RemoteServerOp_AccessFiles_Details {
    pub n_volumes: ::core::ffi::c_int,
    pub volumes: M_vec_HostVolumeDesc,
    pub flags: M_RemoteServerOp_AccessFiles_Details_flags,
}
#[test]
fn bindgen_test_layout_M_RemoteServerOp_AccessFiles_Details() {
    const UNINIT: ::core::mem::MaybeUninit<M_RemoteServerOp_AccessFiles_Details> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_RemoteServerOp_AccessFiles_Details>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(M_RemoteServerOp_AccessFiles_Details)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<M_RemoteServerOp_AccessFiles_Details>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(M_RemoteServerOp_AccessFiles_Details)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_volumes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_RemoteServerOp_AccessFiles_Details),
            "::",
            stringify!(n_volumes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).volumes) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_RemoteServerOp_AccessFiles_Details),
            "::",
            stringify!(volumes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_RemoteServerOp_AccessFiles_Details),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for M_RemoteServerOp_AccessFiles_Details {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_RemoteServerOp_ExportModule_Details {
    pub perm: M_ClientPermission,
}
#[test]
fn bindgen_test_layout_M_RemoteServerOp_ExportModule_Details() {
    const UNINIT: ::core::mem::MaybeUninit<M_RemoteServerOp_ExportModule_Details> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_RemoteServerOp_ExportModule_Details>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(M_RemoteServerOp_ExportModule_Details)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<M_RemoteServerOp_ExportModule_Details>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(M_RemoteServerOp_ExportModule_Details)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).perm) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_RemoteServerOp_ExportModule_Details),
            "::",
            stringify!(perm)
        )
    );
}
impl Default for M_RemoteServerOp_ExportModule_Details {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_RemoteServerOp_ExportSlot_Details {
    pub slot: M_SlotID,
}
#[test]
fn bindgen_test_layout_M_RemoteServerOp_ExportSlot_Details() {
    const UNINIT: ::core::mem::MaybeUninit<M_RemoteServerOp_ExportSlot_Details> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_RemoteServerOp_ExportSlot_Details>(),
        4usize,
        concat!("Size of: ", stringify!(M_RemoteServerOp_ExportSlot_Details))
    );
    assert_eq!(
        ::core::mem::align_of::<M_RemoteServerOp_ExportSlot_Details>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(M_RemoteServerOp_ExportSlot_Details)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).slot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_RemoteServerOp_ExportSlot_Details),
            "::",
            stringify!(slot)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_RemoteServerOp__Details {
    pub accessfiles: M_RemoteServerOp_AccessFiles_Details,
    pub exportmodule: M_RemoteServerOp_ExportModule_Details,
    pub exportslot: M_RemoteServerOp_ExportSlot_Details,
}
#[test]
fn bindgen_test_layout_M_RemoteServerOp__Details() {
    const UNINIT: ::core::mem::MaybeUninit<M_RemoteServerOp__Details> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_RemoteServerOp__Details>(),
        24usize,
        concat!("Size of: ", stringify!(M_RemoteServerOp__Details))
    );
    assert_eq!(
        ::core::mem::align_of::<M_RemoteServerOp__Details>(),
        8usize,
        concat!("Alignment of ", stringify!(M_RemoteServerOp__Details))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).accessfiles) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_RemoteServerOp__Details),
            "::",
            stringify!(accessfiles)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).exportmodule) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_RemoteServerOp__Details),
            "::",
            stringify!(exportmodule)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).exportslot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_RemoteServerOp__Details),
            "::",
            stringify!(exportslot)
        )
    );
}
impl Default for M_RemoteServerOp__Details {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_RemoteServerOp__Details {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_RemoteServerOp__Details {{ union }}")
    }
}
pub type M_RemoteModule_flags = M_Word;
pub type M_vec_KeyHashAndMech = *mut M_KeyHashAndMech;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_wrap_vec_KeyHashAndMech {
    pub n: ::core::ffi::c_int,
    pub v: M_vec_KeyHashAndMech,
}
#[test]
fn bindgen_test_layout_M_wrap_vec_KeyHashAndMech() {
    const UNINIT: ::core::mem::MaybeUninit<M_wrap_vec_KeyHashAndMech> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_wrap_vec_KeyHashAndMech>(),
        16usize,
        concat!("Size of: ", stringify!(M_wrap_vec_KeyHashAndMech))
    );
    assert_eq!(
        ::core::mem::align_of::<M_wrap_vec_KeyHashAndMech>(),
        8usize,
        concat!("Alignment of ", stringify!(M_wrap_vec_KeyHashAndMech))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_wrap_vec_KeyHashAndMech),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).v) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_wrap_vec_KeyHashAndMech),
            "::",
            stringify!(v)
        )
    );
}
impl Default for M_wrap_vec_KeyHashAndMech {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_wrap_vec_Word {
    pub n: ::core::ffi::c_int,
    pub v: M_vec_Word,
}
#[test]
fn bindgen_test_layout_M_wrap_vec_Word() {
    const UNINIT: ::core::mem::MaybeUninit<M_wrap_vec_Word> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_wrap_vec_Word>(),
        16usize,
        concat!("Size of: ", stringify!(M_wrap_vec_Word))
    );
    assert_eq!(
        ::core::mem::align_of::<M_wrap_vec_Word>(),
        8usize,
        concat!("Alignment of ", stringify!(M_wrap_vec_Word))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_wrap_vec_Word),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).v) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_wrap_vec_Word),
            "::",
            stringify!(v)
        )
    );
}
impl Default for M_wrap_vec_Word {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_ImpathKXGroupSelection = M_wrap_vec_Word;
pub type M_vec_KeyHashEx = *mut M_KeyHashEx;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_wrap_vec_KeyHashEx {
    pub n: ::core::ffi::c_int,
    pub v: M_vec_KeyHashEx,
}
#[test]
fn bindgen_test_layout_M_wrap_vec_KeyHashEx() {
    const UNINIT: ::core::mem::MaybeUninit<M_wrap_vec_KeyHashEx> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_wrap_vec_KeyHashEx>(),
        16usize,
        concat!("Size of: ", stringify!(M_wrap_vec_KeyHashEx))
    );
    assert_eq!(
        ::core::mem::align_of::<M_wrap_vec_KeyHashEx>(),
        8usize,
        concat!("Alignment of ", stringify!(M_wrap_vec_KeyHashEx))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_wrap_vec_KeyHashEx),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).v) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_wrap_vec_KeyHashEx),
            "::",
            stringify!(v)
        )
    );
}
impl Default for M_wrap_vec_KeyHashEx {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_RemoteModule {
    pub flags: M_RemoteModule_flags,
    pub ma: *mut M_ModuleAttribList,
    pub addr: *mut M_NetworkAddress,
    pub hks: *mut M_wrap_vec_KeyHashAndMech,
    pub groups: *mut M_ImpathKXGroupSelection,
    pub agelimit: *mut M_Word,
    pub datalimit: *mut M_Word,
    pub warrantroots: *mut M_wrap_vec_KeyHashEx,
}
#[test]
fn bindgen_test_layout_M_RemoteModule() {
    const UNINIT: ::core::mem::MaybeUninit<M_RemoteModule> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_RemoteModule>(),
        64usize,
        concat!("Size of: ", stringify!(M_RemoteModule))
    );
    assert_eq!(
        ::core::mem::align_of::<M_RemoteModule>(),
        8usize,
        concat!("Alignment of ", stringify!(M_RemoteModule))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_RemoteModule),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ma) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_RemoteModule),
            "::",
            stringify!(ma)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).addr) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_RemoteModule),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hks) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_RemoteModule),
            "::",
            stringify!(hks)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).groups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(M_RemoteModule),
            "::",
            stringify!(groups)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).agelimit) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(M_RemoteModule),
            "::",
            stringify!(agelimit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).datalimit) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(M_RemoteModule),
            "::",
            stringify!(datalimit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).warrantroots) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(M_RemoteModule),
            "::",
            stringify!(warrantroots)
        )
    );
}
impl Default for M_RemoteModule {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_RemoteServerPermission {
    pub flags: M_RemoteServerPermission_flags,
    pub permid: M_Word,
    pub module: M_ModuleID,
    pub op: M_RemoteServerOp,
    pub details: M_RemoteServerOp__Details,
    pub rm: M_RemoteModule,
}
#[test]
fn bindgen_test_layout_M_RemoteServerPermission() {
    const UNINIT: ::core::mem::MaybeUninit<M_RemoteServerPermission> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_RemoteServerPermission>(),
        104usize,
        concat!("Size of: ", stringify!(M_RemoteServerPermission))
    );
    assert_eq!(
        ::core::mem::align_of::<M_RemoteServerPermission>(),
        8usize,
        concat!("Alignment of ", stringify!(M_RemoteServerPermission))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_RemoteServerPermission),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).permid) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_RemoteServerPermission),
            "::",
            stringify!(permid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_RemoteServerPermission),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).op) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(M_RemoteServerPermission),
            "::",
            stringify!(op)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).details) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_RemoteServerPermission),
            "::",
            stringify!(details)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rm) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(M_RemoteServerPermission),
            "::",
            stringify!(rm)
        )
    );
}
impl Default for M_RemoteServerPermission {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_RemoteServerPermission {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_RemoteServerPermission {{ flags: {:?}, permid: {:?}, module: {:?}, op: {:?}, details: {:?}, rm: {:?} }}" , self . flags , self . permid , self . module , self . op , self . details , self . rm)
    }
}
pub type M_FileName = M_ASCIIString;
pub type M_HostFileFlags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_HostVolumeDesc {
    pub nativepath: M_ASCIIString,
    pub volume: M_FileName,
    pub flags: M_HostFileFlags,
}
#[test]
fn bindgen_test_layout_M_HostVolumeDesc() {
    const UNINIT: ::core::mem::MaybeUninit<M_HostVolumeDesc> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_HostVolumeDesc>(),
        24usize,
        concat!("Size of: ", stringify!(M_HostVolumeDesc))
    );
    assert_eq!(
        ::core::mem::align_of::<M_HostVolumeDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(M_HostVolumeDesc))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nativepath) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_HostVolumeDesc),
            "::",
            stringify!(nativepath)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).volume) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_HostVolumeDesc),
            "::",
            stringify!(volume)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_HostVolumeDesc),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for M_HostVolumeDesc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_vec_ModuleAttrib = *mut M_ModuleAttrib;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_ModuleAttribList {
    pub n_attribs: ::core::ffi::c_int,
    pub attribs: M_vec_ModuleAttrib,
}
#[test]
fn bindgen_test_layout_M_ModuleAttribList() {
    const UNINIT: ::core::mem::MaybeUninit<M_ModuleAttribList> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_ModuleAttribList>(),
        16usize,
        concat!("Size of: ", stringify!(M_ModuleAttribList))
    );
    assert_eq!(
        ::core::mem::align_of::<M_ModuleAttribList>(),
        8usize,
        concat!("Alignment of ", stringify!(M_ModuleAttribList))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_attribs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ModuleAttribList),
            "::",
            stringify!(n_attribs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).attribs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ModuleAttribList),
            "::",
            stringify!(attribs)
        )
    );
}
impl Default for M_ModuleAttribList {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_KeyHashAndMech {
    pub hash: M_KeyHash,
    pub mech: M_Mech,
}
#[test]
fn bindgen_test_layout_M_KeyHashAndMech() {
    const UNINIT: ::core::mem::MaybeUninit<M_KeyHashAndMech> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_KeyHashAndMech>(),
        24usize,
        concat!("Size of: ", stringify!(M_KeyHashAndMech))
    );
    assert_eq!(
        ::core::mem::align_of::<M_KeyHashAndMech>(),
        4usize,
        concat!("Alignment of ", stringify!(M_KeyHashAndMech))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hash) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyHashAndMech),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mech) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyHashAndMech),
            "::",
            stringify!(mech)
        )
    );
}
impl Default for M_KeyHashAndMech {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_KeyHashAndMech {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_KeyHashAndMech {{ hash: {:?}, mech: {:?} }}",
            self.hash, self.mech
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_ModuleAttribTag_AdditionalInfo_Value {
    pub v: M_Word,
    pub username: M_ASCIIString,
}
#[test]
fn bindgen_test_layout_M_ModuleAttribTag_AdditionalInfo_Value() {
    const UNINIT: ::core::mem::MaybeUninit<M_ModuleAttribTag_AdditionalInfo_Value> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_ModuleAttribTag_AdditionalInfo_Value>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(M_ModuleAttribTag_AdditionalInfo_Value)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<M_ModuleAttribTag_AdditionalInfo_Value>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(M_ModuleAttribTag_AdditionalInfo_Value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).v) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ModuleAttribTag_AdditionalInfo_Value),
            "::",
            stringify!(v)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).username) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ModuleAttribTag_AdditionalInfo_Value),
            "::",
            stringify!(username)
        )
    );
}
impl Default for M_ModuleAttribTag_AdditionalInfo_Value {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_ModuleAttribTag_Challenge_Value {
    pub nonce: M_Nonce,
}
#[test]
fn bindgen_test_layout_M_ModuleAttribTag_Challenge_Value() {
    const UNINIT: ::core::mem::MaybeUninit<M_ModuleAttribTag_Challenge_Value> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_ModuleAttribTag_Challenge_Value>(),
        20usize,
        concat!("Size of: ", stringify!(M_ModuleAttribTag_Challenge_Value))
    );
    assert_eq!(
        ::core::mem::align_of::<M_ModuleAttribTag_Challenge_Value>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(M_ModuleAttribTag_Challenge_Value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nonce) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ModuleAttribTag_Challenge_Value),
            "::",
            stringify!(nonce)
        )
    );
}
impl Default for M_ModuleAttribTag_Challenge_Value {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_ModuleAttribTag_Challenge_Value {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_ModuleAttribTag_Challenge_Value {{ nonce: {:?} }}",
            self.nonce
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_ModuleAttribTag_ESN_Value {
    pub esn: M_ASCIIString,
}
#[test]
fn bindgen_test_layout_M_ModuleAttribTag_ESN_Value() {
    const UNINIT: ::core::mem::MaybeUninit<M_ModuleAttribTag_ESN_Value> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_ModuleAttribTag_ESN_Value>(),
        8usize,
        concat!("Size of: ", stringify!(M_ModuleAttribTag_ESN_Value))
    );
    assert_eq!(
        ::core::mem::align_of::<M_ModuleAttribTag_ESN_Value>(),
        8usize,
        concat!("Alignment of ", stringify!(M_ModuleAttribTag_ESN_Value))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).esn) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ModuleAttribTag_ESN_Value),
            "::",
            stringify!(esn)
        )
    );
}
impl Default for M_ModuleAttribTag_ESN_Value {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_EnquiryDataOne_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_EnquiryDataOne {
    pub releasemajor: M_Word,
    pub releaseminor: M_Word,
    pub releasepatch: M_Word,
    pub checkintimehigh: M_Word,
    pub checkintimelow: M_Word,
    pub flags: M_EnquiryDataOne_flags,
    pub speedindex: M_Word,
    pub recommendedminq: M_Word,
    pub recommendedmaxq: M_Word,
    pub hardwareserial: M_ASCIIString,
    pub softwaredetails: M_ASCIIString,
}
#[test]
fn bindgen_test_layout_M_EnquiryDataOne() {
    const UNINIT: ::core::mem::MaybeUninit<M_EnquiryDataOne> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_EnquiryDataOne>(),
        56usize,
        concat!("Size of: ", stringify!(M_EnquiryDataOne))
    );
    assert_eq!(
        ::core::mem::align_of::<M_EnquiryDataOne>(),
        8usize,
        concat!("Alignment of ", stringify!(M_EnquiryDataOne))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).releasemajor) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnquiryDataOne),
            "::",
            stringify!(releasemajor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).releaseminor) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnquiryDataOne),
            "::",
            stringify!(releaseminor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).releasepatch) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnquiryDataOne),
            "::",
            stringify!(releasepatch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).checkintimehigh) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnquiryDataOne),
            "::",
            stringify!(checkintimehigh)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).checkintimelow) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnquiryDataOne),
            "::",
            stringify!(checkintimelow)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnquiryDataOne),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).speedindex) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnquiryDataOne),
            "::",
            stringify!(speedindex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).recommendedminq) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnquiryDataOne),
            "::",
            stringify!(recommendedminq)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).recommendedmaxq) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnquiryDataOne),
            "::",
            stringify!(recommendedmaxq)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hardwareserial) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnquiryDataOne),
            "::",
            stringify!(hardwareserial)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).softwaredetails) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnquiryDataOne),
            "::",
            stringify!(softwaredetails)
        )
    );
}
impl Default for M_EnquiryDataOne {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_EnquiryDataTwo_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_EnquiryDataTwo {
    pub flags: M_EnquiryDataTwo_flags,
    pub maxwrite: M_Word,
}
#[test]
fn bindgen_test_layout_M_EnquiryDataTwo() {
    const UNINIT: ::core::mem::MaybeUninit<M_EnquiryDataTwo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_EnquiryDataTwo>(),
        8usize,
        concat!("Size of: ", stringify!(M_EnquiryDataTwo))
    );
    assert_eq!(
        ::core::mem::align_of::<M_EnquiryDataTwo>(),
        4usize,
        concat!("Alignment of ", stringify!(M_EnquiryDataTwo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnquiryDataTwo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).maxwrite) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnquiryDataTwo),
            "::",
            stringify!(maxwrite)
        )
    );
}
pub type M_EnquiryDataThree_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_EnquiryDataThree {
    pub flags: M_EnquiryDataThree_flags,
}
#[test]
fn bindgen_test_layout_M_EnquiryDataThree() {
    const UNINIT: ::core::mem::MaybeUninit<M_EnquiryDataThree> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_EnquiryDataThree>(),
        4usize,
        concat!("Size of: ", stringify!(M_EnquiryDataThree))
    );
    assert_eq!(
        ::core::mem::align_of::<M_EnquiryDataThree>(),
        4usize,
        concat!("Alignment of ", stringify!(M_EnquiryDataThree))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnquiryDataThree),
            "::",
            stringify!(flags)
        )
    );
}
pub type M_EnquiryDataFour_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_EnquiryDataFour {
    pub flags: M_EnquiryDataFour_flags,
}
#[test]
fn bindgen_test_layout_M_EnquiryDataFour() {
    const UNINIT: ::core::mem::MaybeUninit<M_EnquiryDataFour> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_EnquiryDataFour>(),
        4usize,
        concat!("Size of: ", stringify!(M_EnquiryDataFour))
    );
    assert_eq!(
        ::core::mem::align_of::<M_EnquiryDataFour>(),
        4usize,
        concat!("Alignment of ", stringify!(M_EnquiryDataFour))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnquiryDataFour),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_EnquiryDataFive {
    pub moduletype: M_ModuleType,
    pub productname: M_ASCIIString,
    pub devicename: M_ASCIIString,
}
#[test]
fn bindgen_test_layout_M_EnquiryDataFive() {
    const UNINIT: ::core::mem::MaybeUninit<M_EnquiryDataFive> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_EnquiryDataFive>(),
        24usize,
        concat!("Size of: ", stringify!(M_EnquiryDataFive))
    );
    assert_eq!(
        ::core::mem::align_of::<M_EnquiryDataFive>(),
        8usize,
        concat!("Alignment of ", stringify!(M_EnquiryDataFive))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).moduletype) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnquiryDataFive),
            "::",
            stringify!(moduletype)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).productname) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnquiryDataFive),
            "::",
            stringify!(productname)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).devicename) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnquiryDataFive),
            "::",
            stringify!(devicename)
        )
    );
}
impl Default for M_EnquiryDataFive {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_FeatureInfo_ctrl = M_Word;
pub type M_FeatureInfo_features = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_FeatureInfo {
    pub ver: M_Word,
    pub ctrl: M_FeatureInfo_ctrl,
    pub features: M_FeatureInfo_features,
}
#[test]
fn bindgen_test_layout_M_FeatureInfo() {
    const UNINIT: ::core::mem::MaybeUninit<M_FeatureInfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_FeatureInfo>(),
        12usize,
        concat!("Size of: ", stringify!(M_FeatureInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<M_FeatureInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(M_FeatureInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ver) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_FeatureInfo),
            "::",
            stringify!(ver)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ctrl) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_FeatureInfo),
            "::",
            stringify!(ctrl)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).features) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_FeatureInfo),
            "::",
            stringify!(features)
        )
    );
}
pub type M_EnquiryDataSix_flags = M_Word;
pub type M_SupportedKMLTypes = M_wrap_vec_Word;
pub type M_NSOPermsModeFlags = M_Word;
pub type M_InitModeFlags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_EnquiryDataSix {
    pub v: M_Word,
    pub supportedgroups: M_ImpathKXGroupSelection,
    pub features: M_FeatureInfo,
    pub vsn: M_Word,
    pub flags: M_EnquiryDataSix_flags,
    pub rmdata: *mut M_EnquiryRMData,
    pub impathport: M_Word,
    pub maxnumclients: M_Word,
    pub kneti: *mut M_KeyHash,
    pub reclongqueue: M_Word,
    pub seemachtype: M_SEEMachineType,
    pub kmltypes: M_SupportedKMLTypes,
    pub usedkxgroup: M_Word,
    pub supportednsopermsmodes: M_Word,
    pub supportedinitmodes: M_Word,
    pub activensopermsmodes: M_NSOPermsModeFlags,
    pub activeinitmodes: M_InitModeFlags,
    pub impathportv6: M_Word,
}
#[test]
fn bindgen_test_layout_M_EnquiryDataSix() {
    const UNINIT: ::core::mem::MaybeUninit<M_EnquiryDataSix> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_EnquiryDataSix>(),
        120usize,
        concat!("Size of: ", stringify!(M_EnquiryDataSix))
    );
    assert_eq!(
        ::core::mem::align_of::<M_EnquiryDataSix>(),
        8usize,
        concat!("Alignment of ", stringify!(M_EnquiryDataSix))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).v) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnquiryDataSix),
            "::",
            stringify!(v)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).supportedgroups) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnquiryDataSix),
            "::",
            stringify!(supportedgroups)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).features) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnquiryDataSix),
            "::",
            stringify!(features)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vsn) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnquiryDataSix),
            "::",
            stringify!(vsn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnquiryDataSix),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rmdata) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnquiryDataSix),
            "::",
            stringify!(rmdata)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).impathport) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnquiryDataSix),
            "::",
            stringify!(impathport)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).maxnumclients) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnquiryDataSix),
            "::",
            stringify!(maxnumclients)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kneti) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnquiryDataSix),
            "::",
            stringify!(kneti)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reclongqueue) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnquiryDataSix),
            "::",
            stringify!(reclongqueue)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).seemachtype) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnquiryDataSix),
            "::",
            stringify!(seemachtype)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kmltypes) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnquiryDataSix),
            "::",
            stringify!(kmltypes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).usedkxgroup) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnquiryDataSix),
            "::",
            stringify!(usedkxgroup)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).supportednsopermsmodes) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnquiryDataSix),
            "::",
            stringify!(supportednsopermsmodes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).supportedinitmodes) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnquiryDataSix),
            "::",
            stringify!(supportedinitmodes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).activensopermsmodes) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnquiryDataSix),
            "::",
            stringify!(activensopermsmodes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).activeinitmodes) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnquiryDataSix),
            "::",
            stringify!(activeinitmodes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).impathportv6) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnquiryDataSix),
            "::",
            stringify!(impathportv6)
        )
    );
}
impl Default for M_EnquiryDataSix {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_ModuleAttribTag_Enquiry_Value {
    pub one: M_EnquiryDataOne,
    pub two: M_EnquiryDataTwo,
    pub three: M_EnquiryDataThree,
    pub four: M_EnquiryDataFour,
    pub five: M_EnquiryDataFive,
    pub six: M_EnquiryDataSix,
}
#[test]
fn bindgen_test_layout_M_ModuleAttribTag_Enquiry_Value() {
    const UNINIT: ::core::mem::MaybeUninit<M_ModuleAttribTag_Enquiry_Value> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_ModuleAttribTag_Enquiry_Value>(),
        216usize,
        concat!("Size of: ", stringify!(M_ModuleAttribTag_Enquiry_Value))
    );
    assert_eq!(
        ::core::mem::align_of::<M_ModuleAttribTag_Enquiry_Value>(),
        8usize,
        concat!("Alignment of ", stringify!(M_ModuleAttribTag_Enquiry_Value))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).one) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ModuleAttribTag_Enquiry_Value),
            "::",
            stringify!(one)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).two) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ModuleAttribTag_Enquiry_Value),
            "::",
            stringify!(two)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).three) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ModuleAttribTag_Enquiry_Value),
            "::",
            stringify!(three)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).four) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ModuleAttribTag_Enquiry_Value),
            "::",
            stringify!(four)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).five) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ModuleAttribTag_Enquiry_Value),
            "::",
            stringify!(five)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).six) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ModuleAttribTag_Enquiry_Value),
            "::",
            stringify!(six)
        )
    );
}
impl Default for M_ModuleAttribTag_Enquiry_Value {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_ModuleAttribTag_FeatureGoldCert_Value {
    pub vendor: M_FeatureGoldCertVendor,
}
#[test]
fn bindgen_test_layout_M_ModuleAttribTag_FeatureGoldCert_Value() {
    const UNINIT: ::core::mem::MaybeUninit<M_ModuleAttribTag_FeatureGoldCert_Value> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_ModuleAttribTag_FeatureGoldCert_Value>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(M_ModuleAttribTag_FeatureGoldCert_Value)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<M_ModuleAttribTag_FeatureGoldCert_Value>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(M_ModuleAttribTag_FeatureGoldCert_Value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vendor) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ModuleAttribTag_FeatureGoldCert_Value),
            "::",
            stringify!(vendor)
        )
    );
}
impl Default for M_ModuleAttribTag_FeatureGoldCert_Value {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_ModuleAttribTag_KAL_Value {
    pub hkal: M_KeyHash,
    pub kalpub: M_KeyData,
    pub mech_i: M_Mech,
}
#[test]
fn bindgen_test_layout_M_ModuleAttribTag_KAL_Value() {
    const UNINIT: ::core::mem::MaybeUninit<M_ModuleAttribTag_KAL_Value> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_ModuleAttribTag_KAL_Value>(),
        160usize,
        concat!("Size of: ", stringify!(M_ModuleAttribTag_KAL_Value))
    );
    assert_eq!(
        ::core::mem::align_of::<M_ModuleAttribTag_KAL_Value>(),
        8usize,
        concat!("Alignment of ", stringify!(M_ModuleAttribTag_KAL_Value))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hkal) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ModuleAttribTag_KAL_Value),
            "::",
            stringify!(hkal)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kalpub) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ModuleAttribTag_KAL_Value),
            "::",
            stringify!(kalpub)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mech_i) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ModuleAttribTag_KAL_Value),
            "::",
            stringify!(mech_i)
        )
    );
}
impl Default for M_ModuleAttribTag_KAL_Value {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_ModuleAttribTag_KAL_Value {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_ModuleAttribTag_KAL_Value {{ hkal: {:?}, kalpub: {:?}, mech_i: {:?} }}",
            self.hkal, self.kalpub, self.mech_i
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_ModuleAttribTag_KLF_Value {
    pub hklf: M_KeyHash,
    pub klfpub: M_KeyData,
    pub mech_i: M_Mech,
}
#[test]
fn bindgen_test_layout_M_ModuleAttribTag_KLF_Value() {
    const UNINIT: ::core::mem::MaybeUninit<M_ModuleAttribTag_KLF_Value> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_ModuleAttribTag_KLF_Value>(),
        160usize,
        concat!("Size of: ", stringify!(M_ModuleAttribTag_KLF_Value))
    );
    assert_eq!(
        ::core::mem::align_of::<M_ModuleAttribTag_KLF_Value>(),
        8usize,
        concat!("Alignment of ", stringify!(M_ModuleAttribTag_KLF_Value))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hklf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ModuleAttribTag_KLF_Value),
            "::",
            stringify!(hklf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).klfpub) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ModuleAttribTag_KLF_Value),
            "::",
            stringify!(klfpub)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mech_i) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ModuleAttribTag_KLF_Value),
            "::",
            stringify!(mech_i)
        )
    );
}
impl Default for M_ModuleAttribTag_KLF_Value {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_ModuleAttribTag_KLF_Value {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_ModuleAttribTag_KLF_Value {{ hklf: {:?}, klfpub: {:?}, mech_i: {:?} }}",
            self.hklf, self.klfpub, self.mech_i
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_ModuleAttribTag_KLF2_Value {
    pub hklf2: M_KeyHash,
    pub klf2pub: M_KeyData,
    pub mech_i: M_Mech,
}
#[test]
fn bindgen_test_layout_M_ModuleAttribTag_KLF2_Value() {
    const UNINIT: ::core::mem::MaybeUninit<M_ModuleAttribTag_KLF2_Value> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_ModuleAttribTag_KLF2_Value>(),
        160usize,
        concat!("Size of: ", stringify!(M_ModuleAttribTag_KLF2_Value))
    );
    assert_eq!(
        ::core::mem::align_of::<M_ModuleAttribTag_KLF2_Value>(),
        8usize,
        concat!("Alignment of ", stringify!(M_ModuleAttribTag_KLF2_Value))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hklf2) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ModuleAttribTag_KLF2_Value),
            "::",
            stringify!(hklf2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).klf2pub) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ModuleAttribTag_KLF2_Value),
            "::",
            stringify!(klf2pub)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mech_i) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ModuleAttribTag_KLF2_Value),
            "::",
            stringify!(mech_i)
        )
    );
}
impl Default for M_ModuleAttribTag_KLF2_Value {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_ModuleAttribTag_KLF2_Value {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_ModuleAttribTag_KLF2_Value {{ hklf2: {:?}, klf2pub: {:?}, mech_i: {:?} }}",
            self.hklf2, self.klf2pub, self.mech_i
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_ModuleAttribTag_KLF3_Value {
    pub hklf3: M_KeyHashEx,
    pub klf3pub: M_KeyData,
    pub mech_i: M_Mech,
}
#[test]
fn bindgen_test_layout_M_ModuleAttribTag_KLF3_Value() {
    const UNINIT: ::core::mem::MaybeUninit<M_ModuleAttribTag_KLF3_Value> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_ModuleAttribTag_KLF3_Value>(),
        208usize,
        concat!("Size of: ", stringify!(M_ModuleAttribTag_KLF3_Value))
    );
    assert_eq!(
        ::core::mem::align_of::<M_ModuleAttribTag_KLF3_Value>(),
        8usize,
        concat!("Alignment of ", stringify!(M_ModuleAttribTag_KLF3_Value))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hklf3) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ModuleAttribTag_KLF3_Value),
            "::",
            stringify!(hklf3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).klf3pub) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ModuleAttribTag_KLF3_Value),
            "::",
            stringify!(klf3pub)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mech_i) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ModuleAttribTag_KLF3_Value),
            "::",
            stringify!(mech_i)
        )
    );
}
impl Default for M_ModuleAttribTag_KLF3_Value {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_ModuleAttribTag_KLF3_Value {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_ModuleAttribTag_KLF3_Value {{ hklf3: {:?}, klf3pub: {:?}, mech_i: {:?} }}",
            self.hklf3, self.klf3pub, self.mech_i
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_ModuleAttribTag_KML_Value {
    pub hkml: M_KeyHash,
    pub kmlpub: M_KeyData,
    pub mech_i: M_Mech,
}
#[test]
fn bindgen_test_layout_M_ModuleAttribTag_KML_Value() {
    const UNINIT: ::core::mem::MaybeUninit<M_ModuleAttribTag_KML_Value> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_ModuleAttribTag_KML_Value>(),
        160usize,
        concat!("Size of: ", stringify!(M_ModuleAttribTag_KML_Value))
    );
    assert_eq!(
        ::core::mem::align_of::<M_ModuleAttribTag_KML_Value>(),
        8usize,
        concat!("Alignment of ", stringify!(M_ModuleAttribTag_KML_Value))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hkml) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ModuleAttribTag_KML_Value),
            "::",
            stringify!(hkml)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kmlpub) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ModuleAttribTag_KML_Value),
            "::",
            stringify!(kmlpub)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mech_i) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ModuleAttribTag_KML_Value),
            "::",
            stringify!(mech_i)
        )
    );
}
impl Default for M_ModuleAttribTag_KML_Value {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_ModuleAttribTag_KML_Value {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_ModuleAttribTag_KML_Value {{ hkml: {:?}, kmlpub: {:?}, mech_i: {:?} }}",
            self.hkml, self.kmlpub, self.mech_i
        )
    }
}
pub type M_vec_KeyHashAttrib = *mut M_KeyHashAttrib;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_ModuleAttribTag_KMList_Value {
    pub n_hkms: ::core::ffi::c_int,
    pub hkms: M_vec_KeyHashAttrib,
}
#[test]
fn bindgen_test_layout_M_ModuleAttribTag_KMList_Value() {
    const UNINIT: ::core::mem::MaybeUninit<M_ModuleAttribTag_KMList_Value> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_ModuleAttribTag_KMList_Value>(),
        16usize,
        concat!("Size of: ", stringify!(M_ModuleAttribTag_KMList_Value))
    );
    assert_eq!(
        ::core::mem::align_of::<M_ModuleAttribTag_KMList_Value>(),
        8usize,
        concat!("Alignment of ", stringify!(M_ModuleAttribTag_KMList_Value))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_hkms) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ModuleAttribTag_KMList_Value),
            "::",
            stringify!(n_hkms)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hkms) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ModuleAttribTag_KMList_Value),
            "::",
            stringify!(hkms)
        )
    );
}
impl Default for M_ModuleAttribTag_KMList_Value {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_NSOPerms_ops = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_NSOPerms {
    pub ops: M_NSOPerms_ops,
}
#[test]
fn bindgen_test_layout_M_NSOPerms() {
    const UNINIT: ::core::mem::MaybeUninit<M_NSOPerms> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_NSOPerms>(),
        4usize,
        concat!("Size of: ", stringify!(M_NSOPerms))
    );
    assert_eq!(
        ::core::mem::align_of::<M_NSOPerms>(),
        4usize,
        concat!("Alignment of ", stringify!(M_NSOPerms))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ops) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_NSOPerms),
            "::",
            stringify!(ops)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_ModuleAttribTag_KNSO_Value {
    pub hknso: M_KeyHash,
    pub publicperms: M_NSOPerms,
}
#[test]
fn bindgen_test_layout_M_ModuleAttribTag_KNSO_Value() {
    const UNINIT: ::core::mem::MaybeUninit<M_ModuleAttribTag_KNSO_Value> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_ModuleAttribTag_KNSO_Value>(),
        24usize,
        concat!("Size of: ", stringify!(M_ModuleAttribTag_KNSO_Value))
    );
    assert_eq!(
        ::core::mem::align_of::<M_ModuleAttribTag_KNSO_Value>(),
        4usize,
        concat!("Alignment of ", stringify!(M_ModuleAttribTag_KNSO_Value))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hknso) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ModuleAttribTag_KNSO_Value),
            "::",
            stringify!(hknso)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).publicperms) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ModuleAttribTag_KNSO_Value),
            "::",
            stringify!(publicperms)
        )
    );
}
impl Default for M_ModuleAttribTag_KNSO_Value {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_ModuleAttribTag_KNSO_Value {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_ModuleAttribTag_KNSO_Value {{ hknso: {:?}, publicperms: {:?} }}",
            self.hknso, self.publicperms
        )
    }
}
pub type M_vec_ModKeyInfo = *mut M_ModKeyInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_ModuleAttribTag_ModKeyInfo_Value {
    pub n_kms: ::core::ffi::c_int,
    pub kms: M_vec_ModKeyInfo,
}
#[test]
fn bindgen_test_layout_M_ModuleAttribTag_ModKeyInfo_Value() {
    const UNINIT: ::core::mem::MaybeUninit<M_ModuleAttribTag_ModKeyInfo_Value> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_ModuleAttribTag_ModKeyInfo_Value>(),
        16usize,
        concat!("Size of: ", stringify!(M_ModuleAttribTag_ModKeyInfo_Value))
    );
    assert_eq!(
        ::core::mem::align_of::<M_ModuleAttribTag_ModKeyInfo_Value>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(M_ModuleAttribTag_ModKeyInfo_Value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_kms) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ModuleAttribTag_ModKeyInfo_Value),
            "::",
            stringify!(n_kms)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kms) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ModuleAttribTag_ModKeyInfo_Value),
            "::",
            stringify!(kms)
        )
    );
}
impl Default for M_ModuleAttribTag_ModKeyInfo_Value {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_ModuleAttribTag_PhysSerial_Value {
    pub physserial: M_ASCIIString,
}
#[test]
fn bindgen_test_layout_M_ModuleAttribTag_PhysSerial_Value() {
    const UNINIT: ::core::mem::MaybeUninit<M_ModuleAttribTag_PhysSerial_Value> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_ModuleAttribTag_PhysSerial_Value>(),
        8usize,
        concat!("Size of: ", stringify!(M_ModuleAttribTag_PhysSerial_Value))
    );
    assert_eq!(
        ::core::mem::align_of::<M_ModuleAttribTag_PhysSerial_Value>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(M_ModuleAttribTag_PhysSerial_Value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).physserial) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ModuleAttribTag_PhysSerial_Value),
            "::",
            stringify!(physserial)
        )
    );
}
impl Default for M_ModuleAttribTag_PhysSerial_Value {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_ModuleAttribTag_WarrantKLF2_Value {
    pub warrant: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_ModuleAttribTag_WarrantKLF2_Value() {
    const UNINIT: ::core::mem::MaybeUninit<M_ModuleAttribTag_WarrantKLF2_Value> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_ModuleAttribTag_WarrantKLF2_Value>(),
        16usize,
        concat!("Size of: ", stringify!(M_ModuleAttribTag_WarrantKLF2_Value))
    );
    assert_eq!(
        ::core::mem::align_of::<M_ModuleAttribTag_WarrantKLF2_Value>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(M_ModuleAttribTag_WarrantKLF2_Value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).warrant) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ModuleAttribTag_WarrantKLF2_Value),
            "::",
            stringify!(warrant)
        )
    );
}
impl Default for M_ModuleAttribTag_WarrantKLF2_Value {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_ModuleAttribTag__Value {
    pub additionalinfo: M_ModuleAttribTag_AdditionalInfo_Value,
    pub challenge: M_ModuleAttribTag_Challenge_Value,
    pub esn: M_ModuleAttribTag_ESN_Value,
    pub enquiry: M_ModuleAttribTag_Enquiry_Value,
    pub featuregoldcert: M_ModuleAttribTag_FeatureGoldCert_Value,
    pub kal: M_ModuleAttribTag_KAL_Value,
    pub klf: M_ModuleAttribTag_KLF_Value,
    pub klf2: M_ModuleAttribTag_KLF2_Value,
    pub klf3: M_ModuleAttribTag_KLF3_Value,
    pub kml: M_ModuleAttribTag_KML_Value,
    pub kmlist: M_ModuleAttribTag_KMList_Value,
    pub knso: M_ModuleAttribTag_KNSO_Value,
    pub modkeyinfo: M_ModuleAttribTag_ModKeyInfo_Value,
    pub physserial: M_ModuleAttribTag_PhysSerial_Value,
    pub warrantklf2: M_ModuleAttribTag_WarrantKLF2_Value,
}
#[test]
fn bindgen_test_layout_M_ModuleAttribTag__Value() {
    const UNINIT: ::core::mem::MaybeUninit<M_ModuleAttribTag__Value> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_ModuleAttribTag__Value>(),
        216usize,
        concat!("Size of: ", stringify!(M_ModuleAttribTag__Value))
    );
    assert_eq!(
        ::core::mem::align_of::<M_ModuleAttribTag__Value>(),
        8usize,
        concat!("Alignment of ", stringify!(M_ModuleAttribTag__Value))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).additionalinfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ModuleAttribTag__Value),
            "::",
            stringify!(additionalinfo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).challenge) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ModuleAttribTag__Value),
            "::",
            stringify!(challenge)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).esn) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ModuleAttribTag__Value),
            "::",
            stringify!(esn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).enquiry) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ModuleAttribTag__Value),
            "::",
            stringify!(enquiry)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).featuregoldcert) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ModuleAttribTag__Value),
            "::",
            stringify!(featuregoldcert)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kal) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ModuleAttribTag__Value),
            "::",
            stringify!(kal)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).klf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ModuleAttribTag__Value),
            "::",
            stringify!(klf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).klf2) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ModuleAttribTag__Value),
            "::",
            stringify!(klf2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).klf3) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ModuleAttribTag__Value),
            "::",
            stringify!(klf3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kml) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ModuleAttribTag__Value),
            "::",
            stringify!(kml)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kmlist) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ModuleAttribTag__Value),
            "::",
            stringify!(kmlist)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).knso) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ModuleAttribTag__Value),
            "::",
            stringify!(knso)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).modkeyinfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ModuleAttribTag__Value),
            "::",
            stringify!(modkeyinfo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).physserial) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ModuleAttribTag__Value),
            "::",
            stringify!(physserial)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).warrantklf2) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ModuleAttribTag__Value),
            "::",
            stringify!(warrantklf2)
        )
    );
}
impl Default for M_ModuleAttribTag__Value {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_ModuleAttribTag__Value {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_ModuleAttribTag__Value {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_ModuleAttrib {
    pub tag: M_ModuleAttribTag,
    pub value: M_ModuleAttribTag__Value,
}
#[test]
fn bindgen_test_layout_M_ModuleAttrib() {
    const UNINIT: ::core::mem::MaybeUninit<M_ModuleAttrib> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_ModuleAttrib>(),
        224usize,
        concat!("Size of: ", stringify!(M_ModuleAttrib))
    );
    assert_eq!(
        ::core::mem::align_of::<M_ModuleAttrib>(),
        8usize,
        concat!("Alignment of ", stringify!(M_ModuleAttrib))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tag) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ModuleAttrib),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ModuleAttrib),
            "::",
            stringify!(value)
        )
    );
}
impl Default for M_ModuleAttrib {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_ModuleAttrib {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_ModuleAttrib {{ tag: {:?}, value: {:?} }}",
            self.tag, self.value
        )
    }
}
pub type M_EnquiryRMData_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_EnquiryRMData {
    pub flags: M_EnquiryRMData_flags,
    pub stinfo: M_StatusErrorInfo,
    pub rm: M_RemoteModule,
}
#[test]
fn bindgen_test_layout_M_EnquiryRMData() {
    const UNINIT: ::core::mem::MaybeUninit<M_EnquiryRMData> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_EnquiryRMData>(),
        104usize,
        concat!("Size of: ", stringify!(M_EnquiryRMData))
    );
    assert_eq!(
        ::core::mem::align_of::<M_EnquiryRMData>(),
        8usize,
        concat!("Alignment of ", stringify!(M_EnquiryRMData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnquiryRMData),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stinfo) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnquiryRMData),
            "::",
            stringify!(stinfo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rm) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnquiryRMData),
            "::",
            stringify!(rm)
        )
    );
}
impl Default for M_EnquiryRMData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_EnquiryRMData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_EnquiryRMData {{ flags: {:?}, stinfo: {:?}, rm: {:?} }}",
            self.flags, self.stinfo, self.rm
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_KeyHashAttrib {
    pub hk: M_KeyHash,
    pub mech_i: M_Mech,
    pub mech_c: M_Mech,
}
#[test]
fn bindgen_test_layout_M_KeyHashAttrib() {
    const UNINIT: ::core::mem::MaybeUninit<M_KeyHashAttrib> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_KeyHashAttrib>(),
        28usize,
        concat!("Size of: ", stringify!(M_KeyHashAttrib))
    );
    assert_eq!(
        ::core::mem::align_of::<M_KeyHashAttrib>(),
        4usize,
        concat!("Alignment of ", stringify!(M_KeyHashAttrib))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hk) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyHashAttrib),
            "::",
            stringify!(hk)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mech_i) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyHashAttrib),
            "::",
            stringify!(mech_i)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mech_c) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyHashAttrib),
            "::",
            stringify!(mech_c)
        )
    );
}
impl Default for M_KeyHashAttrib {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_KeyHashAttrib {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_KeyHashAttrib {{ hk: {:?}, mech_i: {:?}, mech_c: {:?} }}",
            self.hk, self.mech_i, self.mech_c
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_ModKeyInfo {
    pub v: M_Word,
    pub hk: M_KeyHash,
    pub type_: M_KeyType,
    pub mech_i: M_Mech,
    pub mech_c: M_Mech,
}
#[test]
fn bindgen_test_layout_M_ModKeyInfo() {
    const UNINIT: ::core::mem::MaybeUninit<M_ModKeyInfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_ModKeyInfo>(),
        36usize,
        concat!("Size of: ", stringify!(M_ModKeyInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<M_ModKeyInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(M_ModKeyInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).v) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ModKeyInfo),
            "::",
            stringify!(v)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hk) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ModKeyInfo),
            "::",
            stringify!(hk)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ModKeyInfo),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mech_i) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ModKeyInfo),
            "::",
            stringify!(mech_i)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mech_c) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ModKeyInfo),
            "::",
            stringify!(mech_c)
        )
    );
}
impl Default for M_ModKeyInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_ModKeyInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_ModKeyInfo {{ v: {:?}, hk: {:?}, type: {:?}, mech_i: {:?}, mech_c: {:?} }}",
            self.v, self.hk, self.type_, self.mech_i, self.mech_c
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_PlainText {
    pub type_: M_PlainTextType,
    pub data: M_PlainTextType__Data,
}
#[test]
fn bindgen_test_layout_M_PlainText() {
    const UNINIT: ::core::mem::MaybeUninit<M_PlainText> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_PlainText>(),
        72usize,
        concat!("Size of: ", stringify!(M_PlainText))
    );
    assert_eq!(
        ::core::mem::align_of::<M_PlainText>(),
        8usize,
        concat!("Alignment of ", stringify!(M_PlainText))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_PlainText),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_PlainText),
            "::",
            stringify!(data)
        )
    );
}
impl Default for M_PlainText {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_PlainText {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_PlainText {{ type: {:?}, data: {:?} }}",
            self.type_, self.data
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_KeyGenParams {
    pub type_: M_KeyType,
    pub params: M_KeyType__GenParams,
}
#[test]
fn bindgen_test_layout_M_KeyGenParams() {
    const UNINIT: ::core::mem::MaybeUninit<M_KeyGenParams> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_KeyGenParams>(),
        104usize,
        concat!("Size of: ", stringify!(M_KeyGenParams))
    );
    assert_eq!(
        ::core::mem::align_of::<M_KeyGenParams>(),
        8usize,
        concat!("Alignment of ", stringify!(M_KeyGenParams))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyGenParams),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).params) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyGenParams),
            "::",
            stringify!(params)
        )
    );
}
impl Default for M_KeyGenParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_KeyGenParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_KeyGenParams {{ type: {:?}, params: {:?} }}",
            self.type_, self.params
        )
    }
}
pub type M_Command_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_AddRemoteServerPermission_Args {
    pub permission: M_RemoteServerPermission,
}
#[test]
fn bindgen_test_layout_M_Cmd_AddRemoteServerPermission_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_AddRemoteServerPermission_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_AddRemoteServerPermission_Args>(),
        104usize,
        concat!(
            "Size of: ",
            stringify!(M_Cmd_AddRemoteServerPermission_Args)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_AddRemoteServerPermission_Args>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(M_Cmd_AddRemoteServerPermission_Args)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).permission) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_AddRemoteServerPermission_Args),
            "::",
            stringify!(permission)
        )
    );
}
impl Default for M_Cmd_AddRemoteServerPermission_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_AddRemoteServerPermission_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_AddRemoteServerPermission_Args {{ permission: {:?} }}",
            self.permission
        )
    }
}
pub type M_Cmd_AnonymousKnetiHash_Args_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_AnonymousKnetiHash_Args {
    pub flags: M_Cmd_AnonymousKnetiHash_Args_flags,
    pub rmodule: M_Word,
    pub addr: M_NetworkAddress,
}
#[test]
fn bindgen_test_layout_M_Cmd_AnonymousKnetiHash_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_AnonymousKnetiHash_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_AnonymousKnetiHash_Args>(),
        40usize,
        concat!("Size of: ", stringify!(M_Cmd_AnonymousKnetiHash_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_AnonymousKnetiHash_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_AnonymousKnetiHash_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_AnonymousKnetiHash_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rmodule) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_AnonymousKnetiHash_Args),
            "::",
            stringify!(rmodule)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).addr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_AnonymousKnetiHash_Args),
            "::",
            stringify!(addr)
        )
    );
}
impl Default for M_Cmd_AnonymousKnetiHash_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_AnonymousKnetiHash_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_AnonymousKnetiHash_Args {{ flags: {:?}, rmodule: {:?}, addr: {:?} }}",
            self.flags, self.rmodule, self.addr
        )
    }
}
pub type M_PathName = M_ASCIIString;
pub type M_Cmd_ApplyFeatureFile_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ApplyFeatureFile_Args {
    pub module: M_ModuleID,
    pub file: M_PathName,
    pub flags: M_Cmd_ApplyFeatureFile_Args_flags,
}
#[test]
fn bindgen_test_layout_M_Cmd_ApplyFeatureFile_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ApplyFeatureFile_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ApplyFeatureFile_Args>(),
        24usize,
        concat!("Size of: ", stringify!(M_Cmd_ApplyFeatureFile_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ApplyFeatureFile_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_ApplyFeatureFile_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ApplyFeatureFile_Args),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).file) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ApplyFeatureFile_Args),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ApplyFeatureFile_Args),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for M_Cmd_ApplyFeatureFile_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_BignumOp_Args_flags = M_Word;
pub type M_vec_Bignum = *mut M_Bignum;
pub type M_vec_StackOpVal = *mut M_StackOpVal;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_BignumOp_Args {
    pub flags: M_Cmd_BignumOp_Args_flags,
    pub n_stackin: ::core::ffi::c_int,
    pub stackin: M_vec_Bignum,
    pub n_ops: ::core::ffi::c_int,
    pub ops: M_vec_StackOpVal,
}
#[test]
fn bindgen_test_layout_M_Cmd_BignumOp_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_BignumOp_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_BignumOp_Args>(),
        32usize,
        concat!("Size of: ", stringify!(M_Cmd_BignumOp_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_BignumOp_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_BignumOp_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_BignumOp_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_stackin) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_BignumOp_Args),
            "::",
            stringify!(n_stackin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stackin) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_BignumOp_Args),
            "::",
            stringify!(stackin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_ops) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_BignumOp_Args),
            "::",
            stringify!(n_ops)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ops) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_BignumOp_Args),
            "::",
            stringify!(ops)
        )
    );
}
impl Default for M_Cmd_BignumOp_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_ChangeShareGroupPIN_Args_flags = M_Word;
pub type M_vec_ShareInfo = *mut M_ShareInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_PIN {
    pub bytes: [::core::ffi::c_uchar; 20usize],
    pub words: [M_Word; 5usize],
}
#[test]
fn bindgen_test_layout_M_PIN() {
    const UNINIT: ::core::mem::MaybeUninit<M_PIN> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_PIN>(),
        20usize,
        concat!("Size of: ", stringify!(M_PIN))
    );
    assert_eq!(
        ::core::mem::align_of::<M_PIN>(),
        4usize,
        concat!("Alignment of ", stringify!(M_PIN))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_PIN),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).words) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_PIN),
            "::",
            stringify!(words)
        )
    );
}
impl Default for M_PIN {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_PIN {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_PIN {{ union }}")
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ChangeShareGroupPIN_Args {
    pub flags: M_Cmd_ChangeShareGroupPIN_Args_flags,
    pub token: M_PhysToken,
    pub n_shares: ::core::ffi::c_int,
    pub shares: M_vec_ShareInfo,
    pub oldpin: *mut M_PIN,
    pub newpin: *mut M_PIN,
}
#[test]
fn bindgen_test_layout_M_Cmd_ChangeShareGroupPIN_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ChangeShareGroupPIN_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ChangeShareGroupPIN_Args>(),
        48usize,
        concat!("Size of: ", stringify!(M_Cmd_ChangeShareGroupPIN_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ChangeShareGroupPIN_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_ChangeShareGroupPIN_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ChangeShareGroupPIN_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).token) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ChangeShareGroupPIN_Args),
            "::",
            stringify!(token)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_shares) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ChangeShareGroupPIN_Args),
            "::",
            stringify!(n_shares)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).shares) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ChangeShareGroupPIN_Args),
            "::",
            stringify!(shares)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).oldpin) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ChangeShareGroupPIN_Args),
            "::",
            stringify!(oldpin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).newpin) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ChangeShareGroupPIN_Args),
            "::",
            stringify!(newpin)
        )
    );
}
impl Default for M_Cmd_ChangeShareGroupPIN_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_ChangeSharePIN_Args_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_ShortHash {
    pub bytes: [::core::ffi::c_uchar; 10usize],
}
#[test]
fn bindgen_test_layout_M_ShortHash() {
    const UNINIT: ::core::mem::MaybeUninit<M_ShortHash> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_ShortHash>(),
        10usize,
        concat!("Size of: ", stringify!(M_ShortHash))
    );
    assert_eq!(
        ::core::mem::align_of::<M_ShortHash>(),
        1usize,
        concat!("Alignment of ", stringify!(M_ShortHash))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ShortHash),
            "::",
            stringify!(bytes)
        )
    );
}
impl Default for M_ShortHash {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_ShortHash {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_ShortHash {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_ChangeSharePIN_Args {
    pub flags: M_Cmd_ChangeSharePIN_Args_flags,
    pub token: M_PhysToken,
    pub hkm: M_KMHash,
    pub hkt: M_ShortHash,
    pub i: M_Word,
    pub oldpin: *mut M_PIN,
    pub newpin: *mut M_PIN,
}
#[test]
fn bindgen_test_layout_M_Cmd_ChangeSharePIN_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ChangeSharePIN_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ChangeSharePIN_Args>(),
        72usize,
        concat!("Size of: ", stringify!(M_Cmd_ChangeSharePIN_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ChangeSharePIN_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_ChangeSharePIN_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ChangeSharePIN_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).token) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ChangeSharePIN_Args),
            "::",
            stringify!(token)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hkm) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ChangeSharePIN_Args),
            "::",
            stringify!(hkm)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hkt) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ChangeSharePIN_Args),
            "::",
            stringify!(hkt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).i) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ChangeSharePIN_Args),
            "::",
            stringify!(i)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).oldpin) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ChangeSharePIN_Args),
            "::",
            stringify!(oldpin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).newpin) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ChangeSharePIN_Args),
            "::",
            stringify!(newpin)
        )
    );
}
impl Default for M_Cmd_ChangeSharePIN_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_ChangeSharePIN_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_Cmd_ChangeSharePIN_Args {{ flags: {:?}, token: {:?}, hkm: {:?}, hkt: {:?}, i: {:?}, oldpin: {:?}, newpin: {:?} }}" , self . flags , self . token , self . hkm , self . hkt , self . i , self . oldpin , self . newpin)
    }
}
pub type M_Cmd_ChannelOpen_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ChannelOpen_Args {
    pub module: M_ModuleID,
    pub type_: M_ChannelType,
    pub flags: M_Cmd_ChannelOpen_Args_flags,
    pub mode: M_ChannelMode,
    pub mech: M_Mech,
    pub key: *mut M_KeyID,
    pub given_iv: *mut M_IV,
}
#[test]
fn bindgen_test_layout_M_Cmd_ChannelOpen_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ChannelOpen_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ChannelOpen_Args>(),
        40usize,
        concat!("Size of: ", stringify!(M_Cmd_ChannelOpen_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ChannelOpen_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_ChannelOpen_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ChannelOpen_Args),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ChannelOpen_Args),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ChannelOpen_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ChannelOpen_Args),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mech) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ChannelOpen_Args),
            "::",
            stringify!(mech)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ChannelOpen_Args),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).given_iv) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ChannelOpen_Args),
            "::",
            stringify!(given_iv)
        )
    );
}
impl Default for M_Cmd_ChannelOpen_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_ChannelUpdate_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ChannelUpdate_Args {
    pub flags: M_Cmd_ChannelUpdate_Args_flags,
    pub idch: M_KeyID,
    pub input: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_Cmd_ChannelUpdate_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ChannelUpdate_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ChannelUpdate_Args>(),
        24usize,
        concat!("Size of: ", stringify!(M_Cmd_ChannelUpdate_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ChannelUpdate_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_ChannelUpdate_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ChannelUpdate_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).idch) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ChannelUpdate_Args),
            "::",
            stringify!(idch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).input) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ChannelUpdate_Args),
            "::",
            stringify!(input)
        )
    );
}
impl Default for M_Cmd_ChannelUpdate_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_CheckUserAction_Args_flags = M_Word;
pub type M_UserActionID = M_Hash;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_UserActionInfo {
    pub id: M_UserActionID,
    pub perms: M_Word,
    pub restriction: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_UserActionInfo() {
    const UNINIT: ::core::mem::MaybeUninit<M_UserActionInfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_UserActionInfo>(),
        40usize,
        concat!("Size of: ", stringify!(M_UserActionInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<M_UserActionInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(M_UserActionInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_UserActionInfo),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).perms) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(M_UserActionInfo),
            "::",
            stringify!(perms)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).restriction) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_UserActionInfo),
            "::",
            stringify!(restriction)
        )
    );
}
impl Default for M_UserActionInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_UserActionInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_UserActionInfo {{ id: {:?}, perms: {:?}, restriction: {:?} }}",
            self.id, self.perms, self.restriction
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_CheckUserAction_Args {
    pub flags: M_Cmd_CheckUserAction_Args_flags,
    pub key: M_KeyID,
    pub request: M_UserActionInfo,
}
#[test]
fn bindgen_test_layout_M_Cmd_CheckUserAction_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_CheckUserAction_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_CheckUserAction_Args>(),
        48usize,
        concat!("Size of: ", stringify!(M_Cmd_CheckUserAction_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_CheckUserAction_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_CheckUserAction_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_CheckUserAction_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_CheckUserAction_Args),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).request) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_CheckUserAction_Args),
            "::",
            stringify!(request)
        )
    );
}
impl Default for M_Cmd_CheckUserAction_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_CheckUserAction_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_CheckUserAction_Args {{ flags: {:?}, key: {:?}, request: {:?} }}",
            self.flags, self.key, self.request
        )
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_CheckWorld_Args {
    pub module: M_ModuleID,
}
#[test]
fn bindgen_test_layout_M_Cmd_CheckWorld_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_CheckWorld_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_CheckWorld_Args>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_CheckWorld_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_CheckWorld_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_CheckWorld_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_CheckWorld_Args),
            "::",
            stringify!(module)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_ClearUnit_Args {
    pub module: M_ModuleID,
}
#[test]
fn bindgen_test_layout_M_Cmd_ClearUnit_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ClearUnit_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ClearUnit_Args>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_ClearUnit_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ClearUnit_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_ClearUnit_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ClearUnit_Args),
            "::",
            stringify!(module)
        )
    );
}
pub type M_Cmd_ClearUnitEx_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ClearUnitEx_Args {
    pub flags: M_Cmd_ClearUnitEx_Args_flags,
    pub module: M_ModuleID,
    pub mode: M_ModuleMode,
}
#[test]
fn bindgen_test_layout_M_Cmd_ClearUnitEx_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ClearUnitEx_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ClearUnitEx_Args>(),
        12usize,
        concat!("Size of: ", stringify!(M_Cmd_ClearUnitEx_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ClearUnitEx_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_ClearUnitEx_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ClearUnitEx_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ClearUnitEx_Args),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ClearUnitEx_Args),
            "::",
            stringify!(mode)
        )
    );
}
impl Default for M_Cmd_ClearUnitEx_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_ConfigurePoolModule_Args_flags = M_Word;
pub type M_vec_ModuleID = *mut M_ModuleID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ConfigurePoolModule_Args {
    pub flags: M_Cmd_ConfigurePoolModule_Args_flags,
    pub n_addmodules: ::core::ffi::c_int,
    pub addmodules: M_vec_ModuleID,
}
#[test]
fn bindgen_test_layout_M_Cmd_ConfigurePoolModule_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ConfigurePoolModule_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ConfigurePoolModule_Args>(),
        16usize,
        concat!("Size of: ", stringify!(M_Cmd_ConfigurePoolModule_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ConfigurePoolModule_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_ConfigurePoolModule_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ConfigurePoolModule_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_addmodules) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ConfigurePoolModule_Args),
            "::",
            stringify!(n_addmodules)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).addmodules) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ConfigurePoolModule_Args),
            "::",
            stringify!(addmodules)
        )
    );
}
impl Default for M_Cmd_ConfigurePoolModule_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_CreateBuffer_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_CreateBuffer_Args {
    pub module: M_ModuleID,
    pub flags: M_Cmd_CreateBuffer_Args_flags,
    pub size: M_Word,
    pub params: *mut M_EncryptionParams,
}
#[test]
fn bindgen_test_layout_M_Cmd_CreateBuffer_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_CreateBuffer_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_CreateBuffer_Args>(),
        24usize,
        concat!("Size of: ", stringify!(M_Cmd_CreateBuffer_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_CreateBuffer_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_CreateBuffer_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_CreateBuffer_Args),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_CreateBuffer_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_CreateBuffer_Args),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).params) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_CreateBuffer_Args),
            "::",
            stringify!(params)
        )
    );
}
impl Default for M_Cmd_CreateBuffer_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_CreateClient_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_CreateClientOne {
    pub pid: M_Word,
    pub name: M_StringUTF8,
}
#[test]
fn bindgen_test_layout_M_CreateClientOne() {
    const UNINIT: ::core::mem::MaybeUninit<M_CreateClientOne> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_CreateClientOne>(),
        16usize,
        concat!("Size of: ", stringify!(M_CreateClientOne))
    );
    assert_eq!(
        ::core::mem::align_of::<M_CreateClientOne>(),
        8usize,
        concat!("Alignment of ", stringify!(M_CreateClientOne))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_CreateClientOne),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_CreateClientOne),
            "::",
            stringify!(name)
        )
    );
}
impl Default for M_CreateClientOne {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_CreateClientVer_One_Data {
    pub one: M_CreateClientOne,
}
#[test]
fn bindgen_test_layout_M_CreateClientVer_One_Data() {
    const UNINIT: ::core::mem::MaybeUninit<M_CreateClientVer_One_Data> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_CreateClientVer_One_Data>(),
        16usize,
        concat!("Size of: ", stringify!(M_CreateClientVer_One_Data))
    );
    assert_eq!(
        ::core::mem::align_of::<M_CreateClientVer_One_Data>(),
        8usize,
        concat!("Alignment of ", stringify!(M_CreateClientVer_One_Data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).one) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_CreateClientVer_One_Data),
            "::",
            stringify!(one)
        )
    );
}
impl Default for M_CreateClientVer_One_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_CreateClientVer__Data {
    pub one: M_CreateClientVer_One_Data,
}
#[test]
fn bindgen_test_layout_M_CreateClientVer__Data() {
    const UNINIT: ::core::mem::MaybeUninit<M_CreateClientVer__Data> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_CreateClientVer__Data>(),
        16usize,
        concat!("Size of: ", stringify!(M_CreateClientVer__Data))
    );
    assert_eq!(
        ::core::mem::align_of::<M_CreateClientVer__Data>(),
        8usize,
        concat!("Alignment of ", stringify!(M_CreateClientVer__Data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).one) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_CreateClientVer__Data),
            "::",
            stringify!(one)
        )
    );
}
impl Default for M_CreateClientVer__Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_CreateClientVer__Data {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_CreateClientVer__Data {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_CreateClient_Args {
    pub flags: M_Cmd_CreateClient_Args_flags,
    pub version: M_CreateClientVer,
    pub data: M_CreateClientVer__Data,
}
#[test]
fn bindgen_test_layout_M_Cmd_CreateClient_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_CreateClient_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_CreateClient_Args>(),
        24usize,
        concat!("Size of: ", stringify!(M_Cmd_CreateClient_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_CreateClient_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_CreateClient_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_CreateClient_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_CreateClient_Args),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_CreateClient_Args),
            "::",
            stringify!(data)
        )
    );
}
impl Default for M_Cmd_CreateClient_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_CreateClient_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_CreateClient_Args {{ flags: {:?}, version: {:?}, data: {:?} }}",
            self.flags, self.version, self.data
        )
    }
}
pub type M_Cmd_CreateSEEWorld_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_CreateSEEWorld_Args {
    pub flags: M_Cmd_CreateSEEWorld_Args_flags,
    pub buffer: M_KeyID,
}
#[test]
fn bindgen_test_layout_M_Cmd_CreateSEEWorld_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_CreateSEEWorld_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_CreateSEEWorld_Args>(),
        8usize,
        concat!("Size of: ", stringify!(M_Cmd_CreateSEEWorld_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_CreateSEEWorld_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_CreateSEEWorld_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_CreateSEEWorld_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_CreateSEEWorld_Args),
            "::",
            stringify!(buffer)
        )
    );
}
pub type M_Cmd_Decrypt_Args_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_Decrypt_Args {
    pub flags: M_Cmd_Decrypt_Args_flags,
    pub key: M_KeyID,
    pub mech: M_Mech,
    pub cipher: M_CipherText,
    pub reply_type: M_PlainTextType,
}
#[test]
fn bindgen_test_layout_M_Cmd_Decrypt_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_Decrypt_Args> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_Decrypt_Args>(),
        136usize,
        concat!("Size of: ", stringify!(M_Cmd_Decrypt_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_Decrypt_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_Decrypt_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_Decrypt_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_Decrypt_Args),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mech) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_Decrypt_Args),
            "::",
            stringify!(mech)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cipher) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_Decrypt_Args),
            "::",
            stringify!(cipher)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reply_type) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_Decrypt_Args),
            "::",
            stringify!(reply_type)
        )
    );
}
impl Default for M_Cmd_Decrypt_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_Decrypt_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_Cmd_Decrypt_Args {{ flags: {:?}, key: {:?}, mech: {:?}, cipher: {:?}, reply_type: {:?} }}" , self . flags , self . key , self . mech , self . cipher , self . reply_type)
    }
}
pub type M_Cmd_DeriveKey_Args_flags = M_Word;
pub type M_vec_KeyID = *mut M_KeyID;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_DeriveKey_Args {
    pub flags: M_Cmd_DeriveKey_Args_flags,
    pub mech: M_DeriveMech,
    pub n_keys: ::core::ffi::c_int,
    pub keys: M_vec_KeyID,
    pub params: M_DeriveMech__DKParams,
}
#[test]
fn bindgen_test_layout_M_Cmd_DeriveKey_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_DeriveKey_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_DeriveKey_Args>(),
        232usize,
        concat!("Size of: ", stringify!(M_Cmd_DeriveKey_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_DeriveKey_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_DeriveKey_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_DeriveKey_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mech) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_DeriveKey_Args),
            "::",
            stringify!(mech)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_keys) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_DeriveKey_Args),
            "::",
            stringify!(n_keys)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).keys) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_DeriveKey_Args),
            "::",
            stringify!(keys)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).params) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_DeriveKey_Args),
            "::",
            stringify!(params)
        )
    );
}
impl Default for M_Cmd_DeriveKey_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_DeriveKey_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_Cmd_DeriveKey_Args {{ flags: {:?}, mech: {:?}, n_keys: {:?}, keys: {:?}, params: {:?} }}" , self . flags , self . mech , self . n_keys , self . keys , self . params)
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_Destroy_Args {
    pub key: M_KeyID,
}
#[test]
fn bindgen_test_layout_M_Cmd_Destroy_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_Destroy_Args> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_Destroy_Args>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_Destroy_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_Destroy_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_Destroy_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_Destroy_Args),
            "::",
            stringify!(key)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_DevTest_Args {
    pub option: M_DevTestOp,
    pub size: M_Word,
    pub data: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_Cmd_DevTest_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_DevTest_Args> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_DevTest_Args>(),
        24usize,
        concat!("Size of: ", stringify!(M_Cmd_DevTest_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_DevTest_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_DevTest_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).option) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_DevTest_Args),
            "::",
            stringify!(option)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_DevTest_Args),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_DevTest_Args),
            "::",
            stringify!(data)
        )
    );
}
impl Default for M_Cmd_DevTest_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_Duplicate_Args {
    pub key: M_KeyID,
}
#[test]
fn bindgen_test_layout_M_Cmd_Duplicate_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_Duplicate_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_Duplicate_Args>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_Duplicate_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_Duplicate_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_Duplicate_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_Duplicate_Args),
            "::",
            stringify!(key)
        )
    );
}
pub type M_Cmd_DynamicSlotCreateAssociation_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_DynamicSlotCreateAssociation_Args {
    pub flags: M_Cmd_DynamicSlotCreateAssociation_Args_flags,
    pub module: M_ModuleID,
    pub slot: M_SlotID,
}
#[test]
fn bindgen_test_layout_M_Cmd_DynamicSlotCreateAssociation_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_DynamicSlotCreateAssociation_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_DynamicSlotCreateAssociation_Args>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(M_Cmd_DynamicSlotCreateAssociation_Args)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_DynamicSlotCreateAssociation_Args>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(M_Cmd_DynamicSlotCreateAssociation_Args)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_DynamicSlotCreateAssociation_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_DynamicSlotCreateAssociation_Args),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).slot) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_DynamicSlotCreateAssociation_Args),
            "::",
            stringify!(slot)
        )
    );
}
pub type M_Cmd_DynamicSlotExchangeAPDUs_Args_flags = M_Word;
pub type M_SlotAssociationID = M_KeyID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_DynamicSlotExchangeAPDUs_Args {
    pub flags: M_Cmd_DynamicSlotExchangeAPDUs_Args_flags,
    pub payload: *mut M_ByteBlock,
    pub association: M_SlotAssociationID,
}
#[test]
fn bindgen_test_layout_M_Cmd_DynamicSlotExchangeAPDUs_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_DynamicSlotExchangeAPDUs_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_DynamicSlotExchangeAPDUs_Args>(),
        24usize,
        concat!("Size of: ", stringify!(M_Cmd_DynamicSlotExchangeAPDUs_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_DynamicSlotExchangeAPDUs_Args>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(M_Cmd_DynamicSlotExchangeAPDUs_Args)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_DynamicSlotExchangeAPDUs_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).payload) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_DynamicSlotExchangeAPDUs_Args),
            "::",
            stringify!(payload)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).association) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_DynamicSlotExchangeAPDUs_Args),
            "::",
            stringify!(association)
        )
    );
}
impl Default for M_Cmd_DynamicSlotExchangeAPDUs_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_DynamicSlotsConfigure_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_DynamicSlotsConfigure_Args {
    pub flags: M_Cmd_DynamicSlotsConfigure_Args_flags,
    pub slotcount: M_Word,
    pub module: M_ModuleID,
    pub maxcardidle: M_Word,
    pub maxroundtrip: M_Word,
}
#[test]
fn bindgen_test_layout_M_Cmd_DynamicSlotsConfigure_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_DynamicSlotsConfigure_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_DynamicSlotsConfigure_Args>(),
        20usize,
        concat!("Size of: ", stringify!(M_Cmd_DynamicSlotsConfigure_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_DynamicSlotsConfigure_Args>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(M_Cmd_DynamicSlotsConfigure_Args)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_DynamicSlotsConfigure_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).slotcount) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_DynamicSlotsConfigure_Args),
            "::",
            stringify!(slotcount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_DynamicSlotsConfigure_Args),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).maxcardidle) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_DynamicSlotsConfigure_Args),
            "::",
            stringify!(maxcardidle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).maxroundtrip) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_DynamicSlotsConfigure_Args),
            "::",
            stringify!(maxroundtrip)
        )
    );
}
pub type M_Cmd_DynamicSlotsConfigureQuery_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_DynamicSlotsConfigureQuery_Args {
    pub flags: M_Cmd_DynamicSlotsConfigureQuery_Args_flags,
    pub module: M_ModuleID,
    pub waittime: M_Word,
}
#[test]
fn bindgen_test_layout_M_Cmd_DynamicSlotsConfigureQuery_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_DynamicSlotsConfigureQuery_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_DynamicSlotsConfigureQuery_Args>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(M_Cmd_DynamicSlotsConfigureQuery_Args)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_DynamicSlotsConfigureQuery_Args>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(M_Cmd_DynamicSlotsConfigureQuery_Args)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_DynamicSlotsConfigureQuery_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_DynamicSlotsConfigureQuery_Args),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).waittime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_DynamicSlotsConfigureQuery_Args),
            "::",
            stringify!(waittime)
        )
    );
}
pub type M_Cmd_Encrypt_Args_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_Encrypt_Args {
    pub flags: M_Cmd_Encrypt_Args_flags,
    pub key: M_KeyID,
    pub mech: M_Mech,
    pub plain: M_PlainText,
    pub given_iv: *mut M_IV,
}
#[test]
fn bindgen_test_layout_M_Cmd_Encrypt_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_Encrypt_Args> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_Encrypt_Args>(),
        96usize,
        concat!("Size of: ", stringify!(M_Cmd_Encrypt_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_Encrypt_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_Encrypt_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_Encrypt_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_Encrypt_Args),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mech) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_Encrypt_Args),
            "::",
            stringify!(mech)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).plain) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_Encrypt_Args),
            "::",
            stringify!(plain)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).given_iv) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_Encrypt_Args),
            "::",
            stringify!(given_iv)
        )
    );
}
impl Default for M_Cmd_Encrypt_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_Encrypt_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_Cmd_Encrypt_Args {{ flags: {:?}, key: {:?}, mech: {:?}, plain: {:?}, given_iv: {:?} }}" , self . flags , self . key , self . mech , self . plain , self . given_iv)
    }
}
pub type M_Cmd_EraseFile_Args_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_EraseFile_Args {
    pub flags: M_Cmd_EraseFile_Args_flags,
    pub token: M_PhysToken,
    pub file: M_FileInfo,
}
#[test]
fn bindgen_test_layout_M_Cmd_EraseFile_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_EraseFile_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_EraseFile_Args>(),
        36usize,
        concat!("Size of: ", stringify!(M_Cmd_EraseFile_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_EraseFile_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_EraseFile_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_EraseFile_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).token) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_EraseFile_Args),
            "::",
            stringify!(token)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).file) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_EraseFile_Args),
            "::",
            stringify!(file)
        )
    );
}
impl Default for M_Cmd_EraseFile_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_EraseFile_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_EraseFile_Args {{ flags: {:?}, token: {:?}, file: {:?} }}",
            self.flags, self.token, self.file
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_EraseShare_Args {
    pub token: M_PhysToken,
    pub hkt: M_ShortHash,
    pub i: M_Word,
}
#[test]
fn bindgen_test_layout_M_Cmd_EraseShare_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_EraseShare_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_EraseShare_Args>(),
        28usize,
        concat!("Size of: ", stringify!(M_Cmd_EraseShare_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_EraseShare_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_EraseShare_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).token) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_EraseShare_Args),
            "::",
            stringify!(token)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hkt) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_EraseShare_Args),
            "::",
            stringify!(hkt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).i) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_EraseShare_Args),
            "::",
            stringify!(i)
        )
    );
}
impl Default for M_Cmd_EraseShare_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_EraseShare_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_EraseShare_Args {{ token: {:?}, hkt: {:?}, i: {:?} }}",
            self.token, self.hkt, self.i
        )
    }
}
pub type M_Cmd_EraseWorld_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_EraseWorld_Args {
    pub module: M_ModuleID,
    pub flags: M_Cmd_EraseWorld_Args_flags,
}
#[test]
fn bindgen_test_layout_M_Cmd_EraseWorld_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_EraseWorld_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_EraseWorld_Args>(),
        8usize,
        concat!("Size of: ", stringify!(M_Cmd_EraseWorld_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_EraseWorld_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_EraseWorld_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_EraseWorld_Args),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_EraseWorld_Args),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_ExecuteSEEWill_Args {
    pub willid: M_Hash,
}
#[test]
fn bindgen_test_layout_M_Cmd_ExecuteSEEWill_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ExecuteSEEWill_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ExecuteSEEWill_Args>(),
        20usize,
        concat!("Size of: ", stringify!(M_Cmd_ExecuteSEEWill_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ExecuteSEEWill_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_ExecuteSEEWill_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).willid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ExecuteSEEWill_Args),
            "::",
            stringify!(willid)
        )
    );
}
impl Default for M_Cmd_ExecuteSEEWill_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_ExecuteSEEWill_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_ExecuteSEEWill_Args {{ willid: {:?} }}",
            self.willid
        )
    }
}
pub type M_Cmd_ExistingClient_Args_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_ExistingClient_Args {
    pub flags: M_Cmd_ExistingClient_Args_flags,
    pub client: M_ClientID,
}
#[test]
fn bindgen_test_layout_M_Cmd_ExistingClient_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ExistingClient_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ExistingClient_Args>(),
        24usize,
        concat!("Size of: ", stringify!(M_Cmd_ExistingClient_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ExistingClient_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_ExistingClient_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ExistingClient_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).client) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ExistingClient_Args),
            "::",
            stringify!(client)
        )
    );
}
impl Default for M_Cmd_ExistingClient_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_ExistingClient_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_ExistingClient_Args {{ flags: {:?}, client: {:?} }}",
            self.flags, self.client
        )
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_Export_Args {
    pub key: M_KeyID,
}
#[test]
fn bindgen_test_layout_M_Cmd_Export_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_Export_Args> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_Export_Args>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_Export_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_Export_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_Export_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_Export_Args),
            "::",
            stringify!(key)
        )
    );
}
pub type M_Cmd_ExportModule_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_ExportModule_Args {
    pub flags: M_Cmd_ExportModule_Args_flags,
    pub module: M_ModuleID,
}
#[test]
fn bindgen_test_layout_M_Cmd_ExportModule_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ExportModule_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ExportModule_Args>(),
        8usize,
        concat!("Size of: ", stringify!(M_Cmd_ExportModule_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ExportModule_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_ExportModule_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ExportModule_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ExportModule_Args),
            "::",
            stringify!(module)
        )
    );
}
pub type M_Cmd_ExportSlot_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_ExportSlot_Args {
    pub flags: M_Cmd_ExportSlot_Args_flags,
    pub module: M_ModuleID,
    pub slot: M_SlotID,
}
#[test]
fn bindgen_test_layout_M_Cmd_ExportSlot_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ExportSlot_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ExportSlot_Args>(),
        12usize,
        concat!("Size of: ", stringify!(M_Cmd_ExportSlot_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ExportSlot_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_ExportSlot_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ExportSlot_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ExportSlot_Args),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).slot) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ExportSlot_Args),
            "::",
            stringify!(slot)
        )
    );
}
pub type M_LocalKeyID = M_KeyID;
pub type M_FTSessionID = M_LocalKeyID;
pub type M_Cmd_FTChecksum_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_FTChecksum_Args {
    pub id: M_FTSessionID,
    pub file: M_PathName,
    pub mech: M_Mech,
    pub flags: M_Cmd_FTChecksum_Args_flags,
}
#[test]
fn bindgen_test_layout_M_Cmd_FTChecksum_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_FTChecksum_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_FTChecksum_Args>(),
        24usize,
        concat!("Size of: ", stringify!(M_Cmd_FTChecksum_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_FTChecksum_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_FTChecksum_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FTChecksum_Args),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).file) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FTChecksum_Args),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mech) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FTChecksum_Args),
            "::",
            stringify!(mech)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FTChecksum_Args),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for M_Cmd_FTChecksum_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_FTDelete_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_FTDelete_Args {
    pub id: M_FTSessionID,
    pub file: M_PathName,
    pub flags: M_Cmd_FTDelete_Args_flags,
}
#[test]
fn bindgen_test_layout_M_Cmd_FTDelete_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_FTDelete_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_FTDelete_Args>(),
        24usize,
        concat!("Size of: ", stringify!(M_Cmd_FTDelete_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_FTDelete_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_FTDelete_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FTDelete_Args),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).file) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FTDelete_Args),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FTDelete_Args),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for M_Cmd_FTDelete_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_FileTransferID = M_KeyID;
pub type M_Cmd_FTListDir_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_FTListDir_Args {
    pub id: M_FileTransferID,
    pub flags: M_Cmd_FTListDir_Args_flags,
}
#[test]
fn bindgen_test_layout_M_Cmd_FTListDir_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_FTListDir_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_FTListDir_Args>(),
        8usize,
        concat!("Size of: ", stringify!(M_Cmd_FTListDir_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_FTListDir_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_FTListDir_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FTListDir_Args),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FTListDir_Args),
            "::",
            stringify!(flags)
        )
    );
}
pub type M_Cmd_FTRead_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_FTRead_Args {
    pub id: M_FileTransferID,
    pub flags: M_Cmd_FTRead_Args_flags,
}
#[test]
fn bindgen_test_layout_M_Cmd_FTRead_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_FTRead_Args> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_FTRead_Args>(),
        8usize,
        concat!("Size of: ", stringify!(M_Cmd_FTRead_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_FTRead_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_FTRead_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FTRead_Args),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FTRead_Args),
            "::",
            stringify!(flags)
        )
    );
}
pub type M_Cmd_FTSessionOpen_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_FTSessionOpen_Args {
    pub flags: M_Cmd_FTSessionOpen_Args_flags,
    pub remote: M_RemoteModule,
    pub local: *mut M_RemoteModule,
    pub n_keys: ::core::ffi::c_int,
    pub keys: M_vec_KeyID,
}
#[test]
fn bindgen_test_layout_M_Cmd_FTSessionOpen_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_FTSessionOpen_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_FTSessionOpen_Args>(),
        96usize,
        concat!("Size of: ", stringify!(M_Cmd_FTSessionOpen_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_FTSessionOpen_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_FTSessionOpen_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FTSessionOpen_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).remote) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FTSessionOpen_Args),
            "::",
            stringify!(remote)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).local) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FTSessionOpen_Args),
            "::",
            stringify!(local)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_keys) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FTSessionOpen_Args),
            "::",
            stringify!(n_keys)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).keys) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FTSessionOpen_Args),
            "::",
            stringify!(keys)
        )
    );
}
impl Default for M_Cmd_FTSessionOpen_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_FTStartListDir_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_FTStartListDir_Args {
    pub id: M_FTSessionID,
    pub dirname: M_PathName,
    pub flags: M_Cmd_FTStartListDir_Args_flags,
}
#[test]
fn bindgen_test_layout_M_Cmd_FTStartListDir_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_FTStartListDir_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_FTStartListDir_Args>(),
        24usize,
        concat!("Size of: ", stringify!(M_Cmd_FTStartListDir_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_FTStartListDir_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_FTStartListDir_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FTStartListDir_Args),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dirname) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FTStartListDir_Args),
            "::",
            stringify!(dirname)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FTStartListDir_Args),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for M_Cmd_FTStartListDir_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_FTStartRead_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_FTStartRead_Args {
    pub id: M_FTSessionID,
    pub file: M_PathName,
    pub flags: M_Cmd_FTStartRead_Args_flags,
}
#[test]
fn bindgen_test_layout_M_Cmd_FTStartRead_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_FTStartRead_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_FTStartRead_Args>(),
        24usize,
        concat!("Size of: ", stringify!(M_Cmd_FTStartRead_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_FTStartRead_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_FTStartRead_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FTStartRead_Args),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).file) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FTStartRead_Args),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FTStartRead_Args),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for M_Cmd_FTStartRead_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_FTStartWrite_Args_flags = M_Word;
pub type M_FTWriteParams_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_FTWriteParams {
    pub flags: M_FTWriteParams_flags,
    pub chunk: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_FTWriteParams() {
    const UNINIT: ::core::mem::MaybeUninit<M_FTWriteParams> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_FTWriteParams>(),
        24usize,
        concat!("Size of: ", stringify!(M_FTWriteParams))
    );
    assert_eq!(
        ::core::mem::align_of::<M_FTWriteParams>(),
        8usize,
        concat!("Alignment of ", stringify!(M_FTWriteParams))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_FTWriteParams),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chunk) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_FTWriteParams),
            "::",
            stringify!(chunk)
        )
    );
}
impl Default for M_FTWriteParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_FTStartWrite_Args {
    pub id: M_FTSessionID,
    pub file: M_PathName,
    pub flags: M_Cmd_FTStartWrite_Args_flags,
    pub writeparams: M_FTWriteParams,
}
#[test]
fn bindgen_test_layout_M_Cmd_FTStartWrite_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_FTStartWrite_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_FTStartWrite_Args>(),
        48usize,
        concat!("Size of: ", stringify!(M_Cmd_FTStartWrite_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_FTStartWrite_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_FTStartWrite_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FTStartWrite_Args),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).file) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FTStartWrite_Args),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FTStartWrite_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).writeparams) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FTStartWrite_Args),
            "::",
            stringify!(writeparams)
        )
    );
}
impl Default for M_Cmd_FTStartWrite_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_FTStat_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_FTStat_Args {
    pub id: M_FTSessionID,
    pub file: M_PathName,
    pub flags: M_Cmd_FTStat_Args_flags,
}
#[test]
fn bindgen_test_layout_M_Cmd_FTStat_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_FTStat_Args> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_FTStat_Args>(),
        24usize,
        concat!("Size of: ", stringify!(M_Cmd_FTStat_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_FTStat_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_FTStat_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FTStat_Args),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).file) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FTStat_Args),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FTStat_Args),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for M_Cmd_FTStat_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_FTWrite_Args {
    pub id: M_FileTransferID,
    pub writeparams: M_FTWriteParams,
}
#[test]
fn bindgen_test_layout_M_Cmd_FTWrite_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_FTWrite_Args> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_FTWrite_Args>(),
        32usize,
        concat!("Size of: ", stringify!(M_Cmd_FTWrite_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_FTWrite_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_FTWrite_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FTWrite_Args),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).writeparams) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FTWrite_Args),
            "::",
            stringify!(writeparams)
        )
    );
}
impl Default for M_Cmd_FTWrite_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_Fail_Args {
    pub module: M_ModuleID,
}
#[test]
fn bindgen_test_layout_M_Cmd_Fail_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_Fail_Args> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_Fail_Args>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_Fail_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_Fail_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_Fail_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_Fail_Args),
            "::",
            stringify!(module)
        )
    );
}
pub type M_Cmd_FailDriver_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_FailDriver_Args {
    pub flags: M_Cmd_FailDriver_Args_flags,
    pub module: M_ModuleID,
}
#[test]
fn bindgen_test_layout_M_Cmd_FailDriver_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_FailDriver_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_FailDriver_Args>(),
        8usize,
        concat!("Size of: ", stringify!(M_Cmd_FailDriver_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_FailDriver_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_FailDriver_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FailDriver_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FailDriver_Args),
            "::",
            stringify!(module)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_FastSEEJob_Args {
    pub worldid: M_KeyID,
    pub seeargs: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_Cmd_FastSEEJob_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_FastSEEJob_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_FastSEEJob_Args>(),
        24usize,
        concat!("Size of: ", stringify!(M_Cmd_FastSEEJob_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_FastSEEJob_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_FastSEEJob_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).worldid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FastSEEJob_Args),
            "::",
            stringify!(worldid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).seeargs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FastSEEJob_Args),
            "::",
            stringify!(seeargs)
        )
    );
}
impl Default for M_Cmd_FastSEEJob_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_FileCopy_Args_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_FileCopy_Args {
    pub flags: M_Cmd_FileCopy_Args_flags,
    pub from: M_FileSpec,
    pub to: M_FileSpec,
}
#[test]
fn bindgen_test_layout_M_Cmd_FileCopy_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_FileCopy_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_FileCopy_Args>(),
        84usize,
        concat!("Size of: ", stringify!(M_Cmd_FileCopy_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_FileCopy_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_FileCopy_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FileCopy_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).from) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FileCopy_Args),
            "::",
            stringify!(from)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).to) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FileCopy_Args),
            "::",
            stringify!(to)
        )
    );
}
impl Default for M_Cmd_FileCopy_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_FileCopy_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_FileCopy_Args {{ flags: {:?}, from: {:?}, to: {:?} }}",
            self.flags, self.from, self.to
        )
    }
}
pub type M_Cmd_FileCreate_Args_flags = M_Word;
pub type M_vec_PermissionGroup = *mut M_PermissionGroup;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_ACL {
    pub n_groups: ::core::ffi::c_int,
    pub groups: M_vec_PermissionGroup,
}
#[test]
fn bindgen_test_layout_M_ACL() {
    const UNINIT: ::core::mem::MaybeUninit<M_ACL> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_ACL>(),
        16usize,
        concat!("Size of: ", stringify!(M_ACL))
    );
    assert_eq!(
        ::core::mem::align_of::<M_ACL>(),
        8usize,
        concat!("Alignment of ", stringify!(M_ACL))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_groups) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ACL),
            "::",
            stringify!(n_groups)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).groups) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ACL),
            "::",
            stringify!(groups)
        )
    );
}
impl Default for M_ACL {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_FileCreate_Args {
    pub flags: M_Cmd_FileCreate_Args_flags,
    pub file: M_FileSpec,
    pub acl: M_ACL,
}
#[test]
fn bindgen_test_layout_M_Cmd_FileCreate_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_FileCreate_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_FileCreate_Args>(),
        64usize,
        concat!("Size of: ", stringify!(M_Cmd_FileCreate_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_FileCreate_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_FileCreate_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FileCreate_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).file) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FileCreate_Args),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).acl) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FileCreate_Args),
            "::",
            stringify!(acl)
        )
    );
}
impl Default for M_Cmd_FileCreate_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_FileCreate_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_FileCreate_Args {{ flags: {:?}, file: {:?}, acl: {:?} }}",
            self.flags, self.file, self.acl
        )
    }
}
pub type M_Cmd_FileErase_Args_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_FileErase_Args {
    pub flags: M_Cmd_FileErase_Args_flags,
    pub file: M_FileSpec,
}
#[test]
fn bindgen_test_layout_M_Cmd_FileErase_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_FileErase_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_FileErase_Args>(),
        44usize,
        concat!("Size of: ", stringify!(M_Cmd_FileErase_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_FileErase_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_FileErase_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FileErase_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).file) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FileErase_Args),
            "::",
            stringify!(file)
        )
    );
}
impl Default for M_Cmd_FileErase_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_FileErase_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_FileErase_Args {{ flags: {:?}, file: {:?} }}",
            self.flags, self.file
        )
    }
}
pub type M_Cmd_FileOp_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_NVMemRange {
    pub first: M_Word,
    pub last: M_Word,
}
#[test]
fn bindgen_test_layout_M_NVMemRange() {
    const UNINIT: ::core::mem::MaybeUninit<M_NVMemRange> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_NVMemRange>(),
        8usize,
        concat!("Size of: ", stringify!(M_NVMemRange))
    );
    assert_eq!(
        ::core::mem::align_of::<M_NVMemRange>(),
        4usize,
        concat!("Alignment of ", stringify!(M_NVMemRange))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).first) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_NVMemRange),
            "::",
            stringify!(first)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).last) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_NVMemRange),
            "::",
            stringify!(last)
        )
    );
}
pub type M_FileRange = M_NVMemRange;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_NVMemOpType_BitClear_OpVal {
    pub data: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_NVMemOpType_BitClear_OpVal() {
    const UNINIT: ::core::mem::MaybeUninit<M_NVMemOpType_BitClear_OpVal> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_NVMemOpType_BitClear_OpVal>(),
        16usize,
        concat!("Size of: ", stringify!(M_NVMemOpType_BitClear_OpVal))
    );
    assert_eq!(
        ::core::mem::align_of::<M_NVMemOpType_BitClear_OpVal>(),
        8usize,
        concat!("Alignment of ", stringify!(M_NVMemOpType_BitClear_OpVal))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_NVMemOpType_BitClear_OpVal),
            "::",
            stringify!(data)
        )
    );
}
impl Default for M_NVMemOpType_BitClear_OpVal {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_NVMemOpType_BitSet_OpVal {
    pub data: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_NVMemOpType_BitSet_OpVal() {
    const UNINIT: ::core::mem::MaybeUninit<M_NVMemOpType_BitSet_OpVal> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_NVMemOpType_BitSet_OpVal>(),
        16usize,
        concat!("Size of: ", stringify!(M_NVMemOpType_BitSet_OpVal))
    );
    assert_eq!(
        ::core::mem::align_of::<M_NVMemOpType_BitSet_OpVal>(),
        8usize,
        concat!("Alignment of ", stringify!(M_NVMemOpType_BitSet_OpVal))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_NVMemOpType_BitSet_OpVal),
            "::",
            stringify!(data)
        )
    );
}
impl Default for M_NVMemOpType_BitSet_OpVal {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_NVMemOpType_Decr_OpVal {
    pub count: M_Word,
}
#[test]
fn bindgen_test_layout_M_NVMemOpType_Decr_OpVal() {
    const UNINIT: ::core::mem::MaybeUninit<M_NVMemOpType_Decr_OpVal> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_NVMemOpType_Decr_OpVal>(),
        4usize,
        concat!("Size of: ", stringify!(M_NVMemOpType_Decr_OpVal))
    );
    assert_eq!(
        ::core::mem::align_of::<M_NVMemOpType_Decr_OpVal>(),
        4usize,
        concat!("Alignment of ", stringify!(M_NVMemOpType_Decr_OpVal))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_NVMemOpType_Decr_OpVal),
            "::",
            stringify!(count)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_NVMemOpType_Incr_OpVal {
    pub count: M_Word,
}
#[test]
fn bindgen_test_layout_M_NVMemOpType_Incr_OpVal() {
    const UNINIT: ::core::mem::MaybeUninit<M_NVMemOpType_Incr_OpVal> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_NVMemOpType_Incr_OpVal>(),
        4usize,
        concat!("Size of: ", stringify!(M_NVMemOpType_Incr_OpVal))
    );
    assert_eq!(
        ::core::mem::align_of::<M_NVMemOpType_Incr_OpVal>(),
        4usize,
        concat!("Alignment of ", stringify!(M_NVMemOpType_Incr_OpVal))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_NVMemOpType_Incr_OpVal),
            "::",
            stringify!(count)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_NVMemOpType_Resize_OpVal {
    pub size: M_Word,
}
#[test]
fn bindgen_test_layout_M_NVMemOpType_Resize_OpVal() {
    const UNINIT: ::core::mem::MaybeUninit<M_NVMemOpType_Resize_OpVal> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_NVMemOpType_Resize_OpVal>(),
        4usize,
        concat!("Size of: ", stringify!(M_NVMemOpType_Resize_OpVal))
    );
    assert_eq!(
        ::core::mem::align_of::<M_NVMemOpType_Resize_OpVal>(),
        4usize,
        concat!("Alignment of ", stringify!(M_NVMemOpType_Resize_OpVal))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_NVMemOpType_Resize_OpVal),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_NVMemOpType_Write_OpVal {
    pub data: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_NVMemOpType_Write_OpVal() {
    const UNINIT: ::core::mem::MaybeUninit<M_NVMemOpType_Write_OpVal> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_NVMemOpType_Write_OpVal>(),
        16usize,
        concat!("Size of: ", stringify!(M_NVMemOpType_Write_OpVal))
    );
    assert_eq!(
        ::core::mem::align_of::<M_NVMemOpType_Write_OpVal>(),
        8usize,
        concat!("Alignment of ", stringify!(M_NVMemOpType_Write_OpVal))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_NVMemOpType_Write_OpVal),
            "::",
            stringify!(data)
        )
    );
}
impl Default for M_NVMemOpType_Write_OpVal {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_NVMemOpType__OpVal {
    pub bitclear: M_NVMemOpType_BitClear_OpVal,
    pub bitset: M_NVMemOpType_BitSet_OpVal,
    pub decr: M_NVMemOpType_Decr_OpVal,
    pub incr: M_NVMemOpType_Incr_OpVal,
    pub resize: M_NVMemOpType_Resize_OpVal,
    pub write: M_NVMemOpType_Write_OpVal,
}
#[test]
fn bindgen_test_layout_M_NVMemOpType__OpVal() {
    const UNINIT: ::core::mem::MaybeUninit<M_NVMemOpType__OpVal> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_NVMemOpType__OpVal>(),
        16usize,
        concat!("Size of: ", stringify!(M_NVMemOpType__OpVal))
    );
    assert_eq!(
        ::core::mem::align_of::<M_NVMemOpType__OpVal>(),
        8usize,
        concat!("Alignment of ", stringify!(M_NVMemOpType__OpVal))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bitclear) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_NVMemOpType__OpVal),
            "::",
            stringify!(bitclear)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bitset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_NVMemOpType__OpVal),
            "::",
            stringify!(bitset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).decr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_NVMemOpType__OpVal),
            "::",
            stringify!(decr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).incr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_NVMemOpType__OpVal),
            "::",
            stringify!(incr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).resize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_NVMemOpType__OpVal),
            "::",
            stringify!(resize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_NVMemOpType__OpVal),
            "::",
            stringify!(write)
        )
    );
}
impl Default for M_NVMemOpType__OpVal {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_NVMemOpType__OpVal {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_NVMemOpType__OpVal {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_FileOp_Args {
    pub flags: M_Cmd_FileOp_Args_flags,
    pub file: M_FileSpec,
    pub range: *mut M_FileRange,
    pub op: M_NVMemOpType,
    pub val: M_NVMemOpType__OpVal,
}
#[test]
fn bindgen_test_layout_M_Cmd_FileOp_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_FileOp_Args> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_FileOp_Args>(),
        80usize,
        concat!("Size of: ", stringify!(M_Cmd_FileOp_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_FileOp_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_FileOp_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FileOp_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).file) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FileOp_Args),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).range) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FileOp_Args),
            "::",
            stringify!(range)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).op) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FileOp_Args),
            "::",
            stringify!(op)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).val) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FileOp_Args),
            "::",
            stringify!(val)
        )
    );
}
impl Default for M_Cmd_FileOp_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_FileOp_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_FileOp_Args {{ flags: {:?}, file: {:?}, range: {:?}, op: {:?}, val: {:?} }}",
            self.flags, self.file, self.range, self.op, self.val
        )
    }
}
pub type M_Cmd_FirmwareAuthenticate_Args_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_FwAuthType_NFFHMAC1_Params {
    pub hkfc: M_KeyHash,
    pub iv: M_IV,
    pub chunk: M_Word,
    pub mackey: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_FwAuthType_NFFHMAC1_Params() {
    const UNINIT: ::core::mem::MaybeUninit<M_FwAuthType_NFFHMAC1_Params> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_FwAuthType_NFFHMAC1_Params>(),
        96usize,
        concat!("Size of: ", stringify!(M_FwAuthType_NFFHMAC1_Params))
    );
    assert_eq!(
        ::core::mem::align_of::<M_FwAuthType_NFFHMAC1_Params>(),
        8usize,
        concat!("Alignment of ", stringify!(M_FwAuthType_NFFHMAC1_Params))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hkfc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_FwAuthType_NFFHMAC1_Params),
            "::",
            stringify!(hkfc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iv) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_FwAuthType_NFFHMAC1_Params),
            "::",
            stringify!(iv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chunk) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(M_FwAuthType_NFFHMAC1_Params),
            "::",
            stringify!(chunk)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mackey) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(M_FwAuthType_NFFHMAC1_Params),
            "::",
            stringify!(mackey)
        )
    );
}
impl Default for M_FwAuthType_NFFHMAC1_Params {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_FwAuthType_NFFHMAC1_Params {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_FwAuthType_NFFHMAC1_Params {{ hkfc: {:?}, iv: {:?}, chunk: {:?}, mackey: {:?} }}",
            self.hkfc, self.iv, self.chunk, self.mackey
        )
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_FwAuthType_PRNG1_Params {
    pub variant: M_Word,
    pub index: M_Word,
}
#[test]
fn bindgen_test_layout_M_FwAuthType_PRNG1_Params() {
    const UNINIT: ::core::mem::MaybeUninit<M_FwAuthType_PRNG1_Params> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_FwAuthType_PRNG1_Params>(),
        8usize,
        concat!("Size of: ", stringify!(M_FwAuthType_PRNG1_Params))
    );
    assert_eq!(
        ::core::mem::align_of::<M_FwAuthType_PRNG1_Params>(),
        4usize,
        concat!("Alignment of ", stringify!(M_FwAuthType_PRNG1_Params))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).variant) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_FwAuthType_PRNG1_Params),
            "::",
            stringify!(variant)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_FwAuthType_PRNG1_Params),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_FwAuthType__Params {
    pub nffhmac1: M_FwAuthType_NFFHMAC1_Params,
    pub prng1: M_FwAuthType_PRNG1_Params,
}
#[test]
fn bindgen_test_layout_M_FwAuthType__Params() {
    const UNINIT: ::core::mem::MaybeUninit<M_FwAuthType__Params> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_FwAuthType__Params>(),
        96usize,
        concat!("Size of: ", stringify!(M_FwAuthType__Params))
    );
    assert_eq!(
        ::core::mem::align_of::<M_FwAuthType__Params>(),
        8usize,
        concat!("Alignment of ", stringify!(M_FwAuthType__Params))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nffhmac1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_FwAuthType__Params),
            "::",
            stringify!(nffhmac1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prng1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_FwAuthType__Params),
            "::",
            stringify!(prng1)
        )
    );
}
impl Default for M_FwAuthType__Params {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_FwAuthType__Params {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_FwAuthType__Params {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_FirmwareAuthenticate_Args {
    pub module: M_ModuleID,
    pub flags: M_Cmd_FirmwareAuthenticate_Args_flags,
    pub type_: M_FwAuthType,
    pub challenge: M_FwAuthType__Params,
}
#[test]
fn bindgen_test_layout_M_Cmd_FirmwareAuthenticate_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_FirmwareAuthenticate_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_FirmwareAuthenticate_Args>(),
        112usize,
        concat!("Size of: ", stringify!(M_Cmd_FirmwareAuthenticate_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_FirmwareAuthenticate_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_FirmwareAuthenticate_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FirmwareAuthenticate_Args),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FirmwareAuthenticate_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FirmwareAuthenticate_Args),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).challenge) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FirmwareAuthenticate_Args),
            "::",
            stringify!(challenge)
        )
    );
}
impl Default for M_Cmd_FirmwareAuthenticate_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_FirmwareAuthenticate_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_Cmd_FirmwareAuthenticate_Args {{ module: {:?}, flags: {:?}, type: {:?}, challenge: {:?} }}" , self . module , self . flags , self . type_ , self . challenge)
    }
}
pub type M_Cmd_ForeignTokenCmd_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_PhysTokenType_ISO7816_Args {
    pub header: M_Word,
    pub datain: M_ByteBlock,
    pub le: M_Word,
}
#[test]
fn bindgen_test_layout_M_PhysTokenType_ISO7816_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_PhysTokenType_ISO7816_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_PhysTokenType_ISO7816_Args>(),
        32usize,
        concat!("Size of: ", stringify!(M_PhysTokenType_ISO7816_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_PhysTokenType_ISO7816_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_PhysTokenType_ISO7816_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_PhysTokenType_ISO7816_Args),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).datain) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_PhysTokenType_ISO7816_Args),
            "::",
            stringify!(datain)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).le) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_PhysTokenType_ISO7816_Args),
            "::",
            stringify!(le)
        )
    );
}
impl Default for M_PhysTokenType_ISO7816_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_PhysTokenType__Args {
    pub iso7816: M_PhysTokenType_ISO7816_Args,
}
#[test]
fn bindgen_test_layout_M_PhysTokenType__Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_PhysTokenType__Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_PhysTokenType__Args>(),
        32usize,
        concat!("Size of: ", stringify!(M_PhysTokenType__Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_PhysTokenType__Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_PhysTokenType__Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iso7816) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_PhysTokenType__Args),
            "::",
            stringify!(iso7816)
        )
    );
}
impl Default for M_PhysTokenType__Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_PhysTokenType__Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_PhysTokenType__Args {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_ForeignTokenCmd_Args {
    pub flags: M_Cmd_ForeignTokenCmd_Args_flags,
    pub lock: M_KeyID,
    pub type_: M_PhysTokenType,
    pub args: M_PhysTokenType__Args,
}
#[test]
fn bindgen_test_layout_M_Cmd_ForeignTokenCmd_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ForeignTokenCmd_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ForeignTokenCmd_Args>(),
        48usize,
        concat!("Size of: ", stringify!(M_Cmd_ForeignTokenCmd_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ForeignTokenCmd_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_ForeignTokenCmd_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ForeignTokenCmd_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lock) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ForeignTokenCmd_Args),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ForeignTokenCmd_Args),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).args) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ForeignTokenCmd_Args),
            "::",
            stringify!(args)
        )
    );
}
impl Default for M_Cmd_ForeignTokenCmd_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_ForeignTokenCmd_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_ForeignTokenCmd_Args {{ flags: {:?}, lock: {:?}, type: {:?}, args: {:?} }}",
            self.flags, self.lock, self.type_, self.args
        )
    }
}
pub type M_Cmd_ForeignTokenOpen_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_ForeignTokenOpen_Args {
    pub flags: M_Cmd_ForeignTokenOpen_Args_flags,
    pub token: M_PhysToken,
}
#[test]
fn bindgen_test_layout_M_Cmd_ForeignTokenOpen_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ForeignTokenOpen_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ForeignTokenOpen_Args>(),
        16usize,
        concat!("Size of: ", stringify!(M_Cmd_ForeignTokenOpen_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ForeignTokenOpen_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_ForeignTokenOpen_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ForeignTokenOpen_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).token) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ForeignTokenOpen_Args),
            "::",
            stringify!(token)
        )
    );
}
pub type M_Cmd_FormatToken_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_FormatToken_Args {
    pub flags: M_Cmd_FormatToken_Args_flags,
    pub token: M_PhysToken,
    pub auth_key: *mut M_KMHash,
}
#[test]
fn bindgen_test_layout_M_Cmd_FormatToken_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_FormatToken_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_FormatToken_Args>(),
        24usize,
        concat!("Size of: ", stringify!(M_Cmd_FormatToken_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_FormatToken_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_FormatToken_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FormatToken_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).token) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FormatToken_Args),
            "::",
            stringify!(token)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).auth_key) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FormatToken_Args),
            "::",
            stringify!(auth_key)
        )
    );
}
impl Default for M_Cmd_FormatToken_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_GenerateKLF_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_GenerateKLF_Args {
    pub module: M_ModuleID,
    pub flags: M_Cmd_GenerateKLF_Args_flags,
}
#[test]
fn bindgen_test_layout_M_Cmd_GenerateKLF_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GenerateKLF_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GenerateKLF_Args>(),
        8usize,
        concat!("Size of: ", stringify!(M_Cmd_GenerateKLF_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GenerateKLF_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_GenerateKLF_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GenerateKLF_Args),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GenerateKLF_Args),
            "::",
            stringify!(flags)
        )
    );
}
pub type M_Cmd_GenerateKey_Args_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_AppData {
    pub bytes: [::core::ffi::c_uchar; 64usize],
    pub words: [M_Word; 16usize],
}
#[test]
fn bindgen_test_layout_M_AppData() {
    const UNINIT: ::core::mem::MaybeUninit<M_AppData> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_AppData>(),
        64usize,
        concat!("Size of: ", stringify!(M_AppData))
    );
    assert_eq!(
        ::core::mem::align_of::<M_AppData>(),
        4usize,
        concat!("Alignment of ", stringify!(M_AppData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_AppData),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).words) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_AppData),
            "::",
            stringify!(words)
        )
    );
}
impl Default for M_AppData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_AppData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_AppData {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_GenerateKey_Args {
    pub flags: M_Cmd_GenerateKey_Args_flags,
    pub module: M_ModuleID,
    pub params: M_KeyGenParams,
    pub acl: M_ACL,
    pub appdata: *mut M_AppData,
}
#[test]
fn bindgen_test_layout_M_Cmd_GenerateKey_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GenerateKey_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GenerateKey_Args>(),
        136usize,
        concat!("Size of: ", stringify!(M_Cmd_GenerateKey_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GenerateKey_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_GenerateKey_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GenerateKey_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GenerateKey_Args),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).params) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GenerateKey_Args),
            "::",
            stringify!(params)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).acl) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GenerateKey_Args),
            "::",
            stringify!(acl)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).appdata) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GenerateKey_Args),
            "::",
            stringify!(appdata)
        )
    );
}
impl Default for M_Cmd_GenerateKey_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_GenerateKey_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_Cmd_GenerateKey_Args {{ flags: {:?}, module: {:?}, params: {:?}, acl: {:?}, appdata: {:?} }}" , self . flags , self . module , self . params , self . acl , self . appdata)
    }
}
pub type M_Cmd_GenerateKeyPair_Args_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_GenerateKeyPair_Args {
    pub flags: M_Cmd_GenerateKeyPair_Args_flags,
    pub module: M_ModuleID,
    pub params: M_KeyGenParams,
    pub aclpriv: M_ACL,
    pub aclpub: M_ACL,
    pub appdatapriv: *mut M_AppData,
    pub appdatapub: *mut M_AppData,
}
#[test]
fn bindgen_test_layout_M_Cmd_GenerateKeyPair_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GenerateKeyPair_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GenerateKeyPair_Args>(),
        160usize,
        concat!("Size of: ", stringify!(M_Cmd_GenerateKeyPair_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GenerateKeyPair_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_GenerateKeyPair_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GenerateKeyPair_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GenerateKeyPair_Args),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).params) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GenerateKeyPair_Args),
            "::",
            stringify!(params)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).aclpriv) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GenerateKeyPair_Args),
            "::",
            stringify!(aclpriv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).aclpub) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GenerateKeyPair_Args),
            "::",
            stringify!(aclpub)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).appdatapriv) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GenerateKeyPair_Args),
            "::",
            stringify!(appdatapriv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).appdatapub) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GenerateKeyPair_Args),
            "::",
            stringify!(appdatapub)
        )
    );
}
impl Default for M_Cmd_GenerateKeyPair_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_GenerateKeyPair_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_Cmd_GenerateKeyPair_Args {{ flags: {:?}, module: {:?}, params: {:?}, aclpriv: {:?}, aclpub: {:?}, appdatapriv: {:?}, appdatapub: {:?} }}" , self . flags , self . module , self . params , self . aclpriv , self . aclpub , self . appdatapriv , self . appdatapub)
    }
}
pub type M_TokenParams_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_TokenParams {
    pub flags: M_TokenParams_flags,
    pub sharesneeded: M_Word,
    pub sharestotal: M_Word,
    pub timelimit: M_Word,
}
#[test]
fn bindgen_test_layout_M_TokenParams() {
    const UNINIT: ::core::mem::MaybeUninit<M_TokenParams> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_TokenParams>(),
        16usize,
        concat!("Size of: ", stringify!(M_TokenParams))
    );
    assert_eq!(
        ::core::mem::align_of::<M_TokenParams>(),
        4usize,
        concat!("Alignment of ", stringify!(M_TokenParams))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_TokenParams),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sharesneeded) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_TokenParams),
            "::",
            stringify!(sharesneeded)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sharestotal) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_TokenParams),
            "::",
            stringify!(sharestotal)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timelimit) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(M_TokenParams),
            "::",
            stringify!(timelimit)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_GenerateLogicalToken_Args {
    pub module: M_ModuleID,
    pub hkm: M_KMHash,
    pub params: M_TokenParams,
}
#[test]
fn bindgen_test_layout_M_Cmd_GenerateLogicalToken_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GenerateLogicalToken_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GenerateLogicalToken_Args>(),
        40usize,
        concat!("Size of: ", stringify!(M_Cmd_GenerateLogicalToken_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GenerateLogicalToken_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_GenerateLogicalToken_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GenerateLogicalToken_Args),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hkm) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GenerateLogicalToken_Args),
            "::",
            stringify!(hkm)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).params) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GenerateLogicalToken_Args),
            "::",
            stringify!(params)
        )
    );
}
impl Default for M_Cmd_GenerateLogicalToken_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_GenerateLogicalToken_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_GenerateLogicalToken_Args {{ module: {:?}, hkm: {:?}, params: {:?} }}",
            self.module, self.hkm, self.params
        )
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_GeneratePrime_Args {
    pub lenbits: M_Word,
}
#[test]
fn bindgen_test_layout_M_Cmd_GeneratePrime_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GeneratePrime_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GeneratePrime_Args>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_GeneratePrime_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GeneratePrime_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_GeneratePrime_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lenbits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GeneratePrime_Args),
            "::",
            stringify!(lenbits)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_GenerateRandom_Args {
    pub lenbytes: M_Word,
}
#[test]
fn bindgen_test_layout_M_Cmd_GenerateRandom_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GenerateRandom_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GenerateRandom_Args>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_GenerateRandom_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GenerateRandom_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_GenerateRandom_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lenbytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GenerateRandom_Args),
            "::",
            stringify!(lenbytes)
        )
    );
}
pub type M_Cmd_GetACL_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_GetACL_Args {
    pub flags: M_Cmd_GetACL_Args_flags,
    pub key: M_KeyID,
}
#[test]
fn bindgen_test_layout_M_Cmd_GetACL_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GetACL_Args> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GetACL_Args>(),
        8usize,
        concat!("Size of: ", stringify!(M_Cmd_GetACL_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GetACL_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_GetACL_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetACL_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetACL_Args),
            "::",
            stringify!(key)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_GetAppData_Args {
    pub key: M_KeyID,
}
#[test]
fn bindgen_test_layout_M_Cmd_GetAppData_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GetAppData_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GetAppData_Args>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_GetAppData_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GetAppData_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_GetAppData_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetAppData_Args),
            "::",
            stringify!(key)
        )
    );
}
pub type M_Cmd_GetApplianceTime_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_GetApplianceTime_Args {
    pub module: M_ModuleID,
    pub flags: M_Cmd_GetApplianceTime_Args_flags,
}
#[test]
fn bindgen_test_layout_M_Cmd_GetApplianceTime_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GetApplianceTime_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GetApplianceTime_Args>(),
        8usize,
        concat!("Size of: ", stringify!(M_Cmd_GetApplianceTime_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GetApplianceTime_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_GetApplianceTime_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetApplianceTime_Args),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetApplianceTime_Args),
            "::",
            stringify!(flags)
        )
    );
}
pub type M_Cmd_GetApplianceUpgradeStatus_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_GetApplianceUpgradeStatus_Args {
    pub module: M_ModuleID,
    pub flags: M_Cmd_GetApplianceUpgradeStatus_Args_flags,
}
#[test]
fn bindgen_test_layout_M_Cmd_GetApplianceUpgradeStatus_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GetApplianceUpgradeStatus_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GetApplianceUpgradeStatus_Args>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(M_Cmd_GetApplianceUpgradeStatus_Args)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GetApplianceUpgradeStatus_Args>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(M_Cmd_GetApplianceUpgradeStatus_Args)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetApplianceUpgradeStatus_Args),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetApplianceUpgradeStatus_Args),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_GetApplianceVersion_Args {
    pub module: M_ModuleID,
}
#[test]
fn bindgen_test_layout_M_Cmd_GetApplianceVersion_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GetApplianceVersion_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GetApplianceVersion_Args>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_GetApplianceVersion_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GetApplianceVersion_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_GetApplianceVersion_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetApplianceVersion_Args),
            "::",
            stringify!(module)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_GetChallenge_Args {
    pub module: M_ModuleID,
}
#[test]
fn bindgen_test_layout_M_Cmd_GetChallenge_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GetChallenge_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GetChallenge_Args>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_GetChallenge_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GetChallenge_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_GetChallenge_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetChallenge_Args),
            "::",
            stringify!(module)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_GetHardwareError_Args {
    pub module: M_ModuleID,
}
#[test]
fn bindgen_test_layout_M_Cmd_GetHardwareError_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GetHardwareError_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GetHardwareError_Args>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_GetHardwareError_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GetHardwareError_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_GetHardwareError_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetHardwareError_Args),
            "::",
            stringify!(module)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_GetKLF_Args {
    pub module: M_ModuleID,
}
#[test]
fn bindgen_test_layout_M_Cmd_GetKLF_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GetKLF_Args> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GetKLF_Args>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_GetKLF_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GetKLF_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_GetKLF_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetKLF_Args),
            "::",
            stringify!(module)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_GetKLF2_Args {
    pub module: M_ModuleID,
}
#[test]
fn bindgen_test_layout_M_Cmd_GetKLF2_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GetKLF2_Args> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GetKLF2_Args>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_GetKLF2_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GetKLF2_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_GetKLF2_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetKLF2_Args),
            "::",
            stringify!(module)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_GetKML_Args {
    pub module: M_ModuleID,
}
#[test]
fn bindgen_test_layout_M_Cmd_GetKML_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GetKML_Args> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GetKML_Args>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_GetKML_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GetKML_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_GetKML_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetKML_Args),
            "::",
            stringify!(module)
        )
    );
}
pub type M_Cmd_GetKMList_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_GetKMList_Args {
    pub module: M_ModuleID,
    pub flags: M_Cmd_GetKMList_Args_flags,
}
#[test]
fn bindgen_test_layout_M_Cmd_GetKMList_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GetKMList_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GetKMList_Args>(),
        8usize,
        concat!("Size of: ", stringify!(M_Cmd_GetKMList_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GetKMList_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_GetKMList_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetKMList_Args),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetKMList_Args),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_GetKeyInfo_Args {
    pub key: M_KeyID,
}
#[test]
fn bindgen_test_layout_M_Cmd_GetKeyInfo_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GetKeyInfo_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GetKeyInfo_Args>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_GetKeyInfo_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GetKeyInfo_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_GetKeyInfo_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetKeyInfo_Args),
            "::",
            stringify!(key)
        )
    );
}
pub type M_Cmd_GetKeyInfoEx_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_GetKeyInfoEx_Args {
    pub flags: M_Cmd_GetKeyInfoEx_Args_flags,
    pub key: M_KeyID,
}
#[test]
fn bindgen_test_layout_M_Cmd_GetKeyInfoEx_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GetKeyInfoEx_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GetKeyInfoEx_Args>(),
        8usize,
        concat!("Size of: ", stringify!(M_Cmd_GetKeyInfoEx_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GetKeyInfoEx_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_GetKeyInfoEx_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetKeyInfoEx_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetKeyInfoEx_Args),
            "::",
            stringify!(key)
        )
    );
}
pub type M_Cmd_GetKnetiPub_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_GetKnetiPub_Args {
    pub flags: M_Cmd_GetKnetiPub_Args_flags,
    pub module: M_ModuleID,
}
#[test]
fn bindgen_test_layout_M_Cmd_GetKnetiPub_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GetKnetiPub_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GetKnetiPub_Args>(),
        8usize,
        concat!("Size of: ", stringify!(M_Cmd_GetKnetiPub_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GetKnetiPub_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_GetKnetiPub_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetKnetiPub_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetKnetiPub_Args),
            "::",
            stringify!(module)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_GetLogicalTokenInfo_Args {
    pub idkt: M_KeyID,
}
#[test]
fn bindgen_test_layout_M_Cmd_GetLogicalTokenInfo_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GetLogicalTokenInfo_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GetLogicalTokenInfo_Args>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_GetLogicalTokenInfo_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GetLogicalTokenInfo_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_GetLogicalTokenInfo_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).idkt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetLogicalTokenInfo_Args),
            "::",
            stringify!(idkt)
        )
    );
}
pub type M_Cmd_GetLogicalTokenInfoEx_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_GetLogicalTokenInfoEx_Args {
    pub flags: M_Cmd_GetLogicalTokenInfoEx_Args_flags,
    pub idkt: M_KeyID,
}
#[test]
fn bindgen_test_layout_M_Cmd_GetLogicalTokenInfoEx_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GetLogicalTokenInfoEx_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GetLogicalTokenInfoEx_Args>(),
        8usize,
        concat!("Size of: ", stringify!(M_Cmd_GetLogicalTokenInfoEx_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GetLogicalTokenInfoEx_Args>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(M_Cmd_GetLogicalTokenInfoEx_Args)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetLogicalTokenInfoEx_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).idkt) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetLogicalTokenInfoEx_Args),
            "::",
            stringify!(idkt)
        )
    );
}
pub type M_Cmd_GetModuleState_Args_flags = M_Word;
pub type M_vec_ModuleAttribTag = *mut M_ModuleAttribTag;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_wrap_vec_ModuleAttribTag {
    pub n: ::core::ffi::c_int,
    pub v: M_vec_ModuleAttribTag,
}
#[test]
fn bindgen_test_layout_M_wrap_vec_ModuleAttribTag() {
    const UNINIT: ::core::mem::MaybeUninit<M_wrap_vec_ModuleAttribTag> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_wrap_vec_ModuleAttribTag>(),
        16usize,
        concat!("Size of: ", stringify!(M_wrap_vec_ModuleAttribTag))
    );
    assert_eq!(
        ::core::mem::align_of::<M_wrap_vec_ModuleAttribTag>(),
        8usize,
        concat!("Alignment of ", stringify!(M_wrap_vec_ModuleAttribTag))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_wrap_vec_ModuleAttribTag),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).v) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_wrap_vec_ModuleAttribTag),
            "::",
            stringify!(v)
        )
    );
}
impl Default for M_wrap_vec_ModuleAttribTag {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_GetModuleState_Args {
    pub module: M_ModuleID,
    pub flags: M_Cmd_GetModuleState_Args_flags,
    pub attribs: *mut M_wrap_vec_ModuleAttribTag,
}
#[test]
fn bindgen_test_layout_M_Cmd_GetModuleState_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GetModuleState_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GetModuleState_Args>(),
        16usize,
        concat!("Size of: ", stringify!(M_Cmd_GetModuleState_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GetModuleState_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_GetModuleState_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetModuleState_Args),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetModuleState_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).attribs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetModuleState_Args),
            "::",
            stringify!(attribs)
        )
    );
}
impl Default for M_Cmd_GetModuleState_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_GetMonitorLoaderState_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_GetMonitorLoaderState_Args {
    pub module: M_ModuleID,
    pub flags: M_Cmd_GetMonitorLoaderState_Args_flags,
}
#[test]
fn bindgen_test_layout_M_Cmd_GetMonitorLoaderState_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GetMonitorLoaderState_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GetMonitorLoaderState_Args>(),
        8usize,
        concat!("Size of: ", stringify!(M_Cmd_GetMonitorLoaderState_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GetMonitorLoaderState_Args>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(M_Cmd_GetMonitorLoaderState_Args)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetMonitorLoaderState_Args),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetMonitorLoaderState_Args),
            "::",
            stringify!(flags)
        )
    );
}
pub type M_Cmd_GetPoolInfo_Args_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_PoolInfo_ClientInfo_ReqData {
    pub client: M_CipherText,
}
#[test]
fn bindgen_test_layout_M_PoolInfo_ClientInfo_ReqData() {
    const UNINIT: ::core::mem::MaybeUninit<M_PoolInfo_ClientInfo_ReqData> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_PoolInfo_ClientInfo_ReqData>(),
        112usize,
        concat!("Size of: ", stringify!(M_PoolInfo_ClientInfo_ReqData))
    );
    assert_eq!(
        ::core::mem::align_of::<M_PoolInfo_ClientInfo_ReqData>(),
        8usize,
        concat!("Alignment of ", stringify!(M_PoolInfo_ClientInfo_ReqData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).client) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_PoolInfo_ClientInfo_ReqData),
            "::",
            stringify!(client)
        )
    );
}
impl Default for M_PoolInfo_ClientInfo_ReqData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_PoolInfo_ClientInfo_ReqData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_PoolInfo_ClientInfo_ReqData {{ client: {:?} }}",
            self.client
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_PoolInfo_KeyInfo_ReqData {
    pub key: M_CipherText,
}
#[test]
fn bindgen_test_layout_M_PoolInfo_KeyInfo_ReqData() {
    const UNINIT: ::core::mem::MaybeUninit<M_PoolInfo_KeyInfo_ReqData> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_PoolInfo_KeyInfo_ReqData>(),
        112usize,
        concat!("Size of: ", stringify!(M_PoolInfo_KeyInfo_ReqData))
    );
    assert_eq!(
        ::core::mem::align_of::<M_PoolInfo_KeyInfo_ReqData>(),
        8usize,
        concat!("Alignment of ", stringify!(M_PoolInfo_KeyInfo_ReqData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_PoolInfo_KeyInfo_ReqData),
            "::",
            stringify!(key)
        )
    );
}
impl Default for M_PoolInfo_KeyInfo_ReqData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_PoolInfo_KeyInfo_ReqData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_PoolInfo_KeyInfo_ReqData {{ key: {:?} }}", self.key)
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_PoolInfo_ModuleInfo_ReqData {
    pub module: M_Word,
}
#[test]
fn bindgen_test_layout_M_PoolInfo_ModuleInfo_ReqData() {
    const UNINIT: ::core::mem::MaybeUninit<M_PoolInfo_ModuleInfo_ReqData> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_PoolInfo_ModuleInfo_ReqData>(),
        4usize,
        concat!("Size of: ", stringify!(M_PoolInfo_ModuleInfo_ReqData))
    );
    assert_eq!(
        ::core::mem::align_of::<M_PoolInfo_ModuleInfo_ReqData>(),
        4usize,
        concat!("Alignment of ", stringify!(M_PoolInfo_ModuleInfo_ReqData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_PoolInfo_ModuleInfo_ReqData),
            "::",
            stringify!(module)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_PoolInfo__ReqData {
    pub clientinfo: M_PoolInfo_ClientInfo_ReqData,
    pub keyinfo: M_PoolInfo_KeyInfo_ReqData,
    pub moduleinfo: M_PoolInfo_ModuleInfo_ReqData,
}
#[test]
fn bindgen_test_layout_M_PoolInfo__ReqData() {
    const UNINIT: ::core::mem::MaybeUninit<M_PoolInfo__ReqData> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_PoolInfo__ReqData>(),
        112usize,
        concat!("Size of: ", stringify!(M_PoolInfo__ReqData))
    );
    assert_eq!(
        ::core::mem::align_of::<M_PoolInfo__ReqData>(),
        8usize,
        concat!("Alignment of ", stringify!(M_PoolInfo__ReqData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).clientinfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_PoolInfo__ReqData),
            "::",
            stringify!(clientinfo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).keyinfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_PoolInfo__ReqData),
            "::",
            stringify!(keyinfo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).moduleinfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_PoolInfo__ReqData),
            "::",
            stringify!(moduleinfo)
        )
    );
}
impl Default for M_PoolInfo__ReqData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_PoolInfo__ReqData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_PoolInfo__ReqData {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_GetPoolInfo_Args {
    pub flags: M_Cmd_GetPoolInfo_Args_flags,
    pub type_: M_PoolInfo,
    pub req: M_PoolInfo__ReqData,
}
#[test]
fn bindgen_test_layout_M_Cmd_GetPoolInfo_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GetPoolInfo_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GetPoolInfo_Args>(),
        120usize,
        concat!("Size of: ", stringify!(M_Cmd_GetPoolInfo_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GetPoolInfo_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_GetPoolInfo_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetPoolInfo_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetPoolInfo_Args),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).req) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetPoolInfo_Args),
            "::",
            stringify!(req)
        )
    );
}
impl Default for M_Cmd_GetPoolInfo_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_GetPoolInfo_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_GetPoolInfo_Args {{ flags: {:?}, type: {:?}, req: {:?} }}",
            self.flags, self.type_, self.req
        )
    }
}
pub type M_Cmd_GetPublishedObject_Args_flags = M_Word;
pub type M_HostServiceName = M_ASCIIString;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_GetPublishedObject_Args {
    pub flags: M_Cmd_GetPublishedObject_Args_flags,
    pub name: M_HostServiceName,
    pub module: M_ModuleID,
}
#[test]
fn bindgen_test_layout_M_Cmd_GetPublishedObject_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GetPublishedObject_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GetPublishedObject_Args>(),
        24usize,
        concat!("Size of: ", stringify!(M_Cmd_GetPublishedObject_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GetPublishedObject_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_GetPublishedObject_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetPublishedObject_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetPublishedObject_Args),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetPublishedObject_Args),
            "::",
            stringify!(module)
        )
    );
}
impl Default for M_Cmd_GetPublishedObject_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_GetRTC_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_GetRTC_Args {
    pub module: M_ModuleID,
    pub flags: M_Cmd_GetRTC_Args_flags,
}
#[test]
fn bindgen_test_layout_M_Cmd_GetRTC_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GetRTC_Args> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GetRTC_Args>(),
        8usize,
        concat!("Size of: ", stringify!(M_Cmd_GetRTC_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GetRTC_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_GetRTC_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetRTC_Args),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetRTC_Args),
            "::",
            stringify!(flags)
        )
    );
}
pub type M_Cmd_GetServerConfig_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_GetServerConfig_Args {
    pub flags: M_Cmd_GetServerConfig_Args_flags,
}
#[test]
fn bindgen_test_layout_M_Cmd_GetServerConfig_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GetServerConfig_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GetServerConfig_Args>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_GetServerConfig_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GetServerConfig_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_GetServerConfig_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetServerConfig_Args),
            "::",
            stringify!(flags)
        )
    );
}
pub type M_Cmd_GetShareACL_Args_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_GetShareACL_Args {
    pub flags: M_Cmd_GetShareACL_Args_flags,
    pub token: M_PhysToken,
    pub hkt: M_ShortHash,
    pub i: M_Word,
}
#[test]
fn bindgen_test_layout_M_Cmd_GetShareACL_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GetShareACL_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GetShareACL_Args>(),
        32usize,
        concat!("Size of: ", stringify!(M_Cmd_GetShareACL_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GetShareACL_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_GetShareACL_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetShareACL_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).token) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetShareACL_Args),
            "::",
            stringify!(token)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hkt) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetShareACL_Args),
            "::",
            stringify!(hkt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).i) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetShareACL_Args),
            "::",
            stringify!(i)
        )
    );
}
impl Default for M_Cmd_GetShareACL_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_GetShareACL_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_GetShareACL_Args {{ flags: {:?}, token: {:?}, hkt: {:?}, i: {:?} }}",
            self.flags, self.token, self.hkt, self.i
        )
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_GetSlotInfo_Args {
    pub module: M_ModuleID,
    pub slot: M_SlotID,
}
#[test]
fn bindgen_test_layout_M_Cmd_GetSlotInfo_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GetSlotInfo_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GetSlotInfo_Args>(),
        8usize,
        concat!("Size of: ", stringify!(M_Cmd_GetSlotInfo_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GetSlotInfo_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_GetSlotInfo_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetSlotInfo_Args),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).slot) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetSlotInfo_Args),
            "::",
            stringify!(slot)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_GetSlotList_Args {
    pub module: M_ModuleID,
}
#[test]
fn bindgen_test_layout_M_Cmd_GetSlotList_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GetSlotList_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GetSlotList_Args>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_GetSlotList_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GetSlotList_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_GetSlotList_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetSlotList_Args),
            "::",
            stringify!(module)
        )
    );
}
pub type M_Cmd_GetTicket_Args_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_TicketDestination_NamedClient_Details {
    pub hclientid: M_Hash,
}
#[test]
fn bindgen_test_layout_M_TicketDestination_NamedClient_Details() {
    const UNINIT: ::core::mem::MaybeUninit<M_TicketDestination_NamedClient_Details> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_TicketDestination_NamedClient_Details>(),
        20usize,
        concat!(
            "Size of: ",
            stringify!(M_TicketDestination_NamedClient_Details)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<M_TicketDestination_NamedClient_Details>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(M_TicketDestination_NamedClient_Details)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hclientid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_TicketDestination_NamedClient_Details),
            "::",
            stringify!(hclientid)
        )
    );
}
impl Default for M_TicketDestination_NamedClient_Details {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_TicketDestination_NamedClient_Details {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_TicketDestination_NamedClient_Details {{ hclientid: {:?} }}",
            self.hclientid
        )
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_TicketDestination_NamedSEEWorld_Details {
    pub world: M_KeyID,
}
#[test]
fn bindgen_test_layout_M_TicketDestination_NamedSEEWorld_Details() {
    const UNINIT: ::core::mem::MaybeUninit<M_TicketDestination_NamedSEEWorld_Details> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_TicketDestination_NamedSEEWorld_Details>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(M_TicketDestination_NamedSEEWorld_Details)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<M_TicketDestination_NamedSEEWorld_Details>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(M_TicketDestination_NamedSEEWorld_Details)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).world) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_TicketDestination_NamedSEEWorld_Details),
            "::",
            stringify!(world)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_TicketDestination__Details {
    pub namedclient: M_TicketDestination_NamedClient_Details,
    pub namedseeworld: M_TicketDestination_NamedSEEWorld_Details,
}
#[test]
fn bindgen_test_layout_M_TicketDestination__Details() {
    const UNINIT: ::core::mem::MaybeUninit<M_TicketDestination__Details> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_TicketDestination__Details>(),
        20usize,
        concat!("Size of: ", stringify!(M_TicketDestination__Details))
    );
    assert_eq!(
        ::core::mem::align_of::<M_TicketDestination__Details>(),
        4usize,
        concat!("Alignment of ", stringify!(M_TicketDestination__Details))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).namedclient) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_TicketDestination__Details),
            "::",
            stringify!(namedclient)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).namedseeworld) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_TicketDestination__Details),
            "::",
            stringify!(namedseeworld)
        )
    );
}
impl Default for M_TicketDestination__Details {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_TicketDestination__Details {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_TicketDestination__Details {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_GetTicket_Args {
    pub flags: M_Cmd_GetTicket_Args_flags,
    pub obj: M_KeyID,
    pub dest: M_TicketDestination,
    pub destspec: M_TicketDestination__Details,
}
#[test]
fn bindgen_test_layout_M_Cmd_GetTicket_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GetTicket_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GetTicket_Args>(),
        32usize,
        concat!("Size of: ", stringify!(M_Cmd_GetTicket_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GetTicket_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_GetTicket_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetTicket_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).obj) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetTicket_Args),
            "::",
            stringify!(obj)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dest) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetTicket_Args),
            "::",
            stringify!(dest)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).destspec) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetTicket_Args),
            "::",
            stringify!(destspec)
        )
    );
}
impl Default for M_Cmd_GetTicket_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_GetTicket_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_GetTicket_Args {{ flags: {:?}, obj: {:?}, dest: {:?}, destspec: {:?} }}",
            self.flags, self.obj, self.dest, self.destspec
        )
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_GetWhichModule_Args {
    pub key: M_KeyID,
}
#[test]
fn bindgen_test_layout_M_Cmd_GetWhichModule_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GetWhichModule_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GetWhichModule_Args>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_GetWhichModule_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GetWhichModule_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_GetWhichModule_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetWhichModule_Args),
            "::",
            stringify!(key)
        )
    );
}
pub type M_Cmd_GetWorldSigners_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_GetWorldSigners_Args {
    pub flags: M_Cmd_GetWorldSigners_Args_flags,
}
#[test]
fn bindgen_test_layout_M_Cmd_GetWorldSigners_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GetWorldSigners_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GetWorldSigners_Args>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_GetWorldSigners_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GetWorldSigners_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_GetWorldSigners_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetWorldSigners_Args),
            "::",
            stringify!(flags)
        )
    );
}
pub type M_Cmd_Hash_Args_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_Hash_Args {
    pub flags: M_Cmd_Hash_Args_flags,
    pub mech: M_Mech,
    pub plain: M_PlainText,
}
#[test]
fn bindgen_test_layout_M_Cmd_Hash_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_Hash_Args> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_Hash_Args>(),
        80usize,
        concat!("Size of: ", stringify!(M_Cmd_Hash_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_Hash_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_Hash_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_Hash_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mech) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_Hash_Args),
            "::",
            stringify!(mech)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).plain) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_Hash_Args),
            "::",
            stringify!(plain)
        )
    );
}
impl Default for M_Cmd_Hash_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_Hash_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_Hash_Args {{ flags: {:?}, mech: {:?}, plain: {:?} }}",
            self.flags, self.mech, self.plain
        )
    }
}
pub type M_Cmd_HotReset_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_HotReset_Args {
    pub flags: M_Cmd_HotReset_Args_flags,
    pub module: M_ModuleID,
}
#[test]
fn bindgen_test_layout_M_Cmd_HotReset_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_HotReset_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_HotReset_Args>(),
        8usize,
        concat!("Size of: ", stringify!(M_Cmd_HotReset_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_HotReset_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_HotReset_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_HotReset_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_HotReset_Args),
            "::",
            stringify!(module)
        )
    );
}
pub type M_Cmd_IOBoardReprogram_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_IOBoardReprogram_Args {
    pub flags: M_Cmd_IOBoardReprogram_Args_flags,
    pub buffer: M_KeyID,
}
#[test]
fn bindgen_test_layout_M_Cmd_IOBoardReprogram_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_IOBoardReprogram_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_IOBoardReprogram_Args>(),
        8usize,
        concat!("Size of: ", stringify!(M_Cmd_IOBoardReprogram_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_IOBoardReprogram_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_IOBoardReprogram_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_IOBoardReprogram_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_IOBoardReprogram_Args),
            "::",
            stringify!(buffer)
        )
    );
}
pub type M_ImpathID = M_KeyID;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_ImpathGetInfo_Args {
    pub imp: M_ImpathID,
}
#[test]
fn bindgen_test_layout_M_Cmd_ImpathGetInfo_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ImpathGetInfo_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ImpathGetInfo_Args>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_ImpathGetInfo_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ImpathGetInfo_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_ImpathGetInfo_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).imp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ImpathGetInfo_Args),
            "::",
            stringify!(imp)
        )
    );
}
pub type M_Cmd_ImpathKXBegin_Args_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_ImpathKXBegin_Args {
    pub flags: M_Cmd_ImpathKXBegin_Args_flags,
    pub module: M_ModuleID,
    pub me: M_RemoteModule,
    pub him: M_RemoteModule,
    pub hisgroups: M_ImpathKXGroupSelection,
    pub n: M_Nonce,
    pub n_keys: ::core::ffi::c_int,
    pub keys: M_vec_KeyID,
}
#[test]
fn bindgen_test_layout_M_Cmd_ImpathKXBegin_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ImpathKXBegin_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ImpathKXBegin_Args>(),
        184usize,
        concat!("Size of: ", stringify!(M_Cmd_ImpathKXBegin_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ImpathKXBegin_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_ImpathKXBegin_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ImpathKXBegin_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ImpathKXBegin_Args),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).me) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ImpathKXBegin_Args),
            "::",
            stringify!(me)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).him) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ImpathKXBegin_Args),
            "::",
            stringify!(him)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hisgroups) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ImpathKXBegin_Args),
            "::",
            stringify!(hisgroups)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ImpathKXBegin_Args),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_keys) as usize - ptr as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ImpathKXBegin_Args),
            "::",
            stringify!(n_keys)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).keys) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ImpathKXBegin_Args),
            "::",
            stringify!(keys)
        )
    );
}
impl Default for M_Cmd_ImpathKXBegin_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_ImpathKXBegin_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_Cmd_ImpathKXBegin_Args {{ flags: {:?}, module: {:?}, me: {:?}, him: {:?}, hisgroups: {:?}, n: {:?}, n_keys: {:?}, keys: {:?} }}" , self . flags , self . module , self . me , self . him , self . hisgroups , self . n , self . n_keys , self . keys)
    }
}
pub type M_Cmd_ImpathKXFinish_Args_flags = M_Word;
pub type M_vec_ImpathWarrant = *mut M_ImpathWarrant;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_wrap_vec_ImpathWarrant {
    pub n: ::core::ffi::c_int,
    pub v: M_vec_ImpathWarrant,
}
#[test]
fn bindgen_test_layout_M_wrap_vec_ImpathWarrant() {
    const UNINIT: ::core::mem::MaybeUninit<M_wrap_vec_ImpathWarrant> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_wrap_vec_ImpathWarrant>(),
        16usize,
        concat!("Size of: ", stringify!(M_wrap_vec_ImpathWarrant))
    );
    assert_eq!(
        ::core::mem::align_of::<M_wrap_vec_ImpathWarrant>(),
        8usize,
        concat!("Alignment of ", stringify!(M_wrap_vec_ImpathWarrant))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_wrap_vec_ImpathWarrant),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).v) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_wrap_vec_ImpathWarrant),
            "::",
            stringify!(v)
        )
    );
}
impl Default for M_wrap_vec_ImpathWarrant {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ImpathKXFinish_Args {
    pub flags: M_Cmd_ImpathKXFinish_Args_flags,
    pub imp: M_ImpathID,
    pub addr: *mut M_NetworkAddress,
    pub n_keys: ::core::ffi::c_int,
    pub keys: M_vec_KeyID,
    pub kx: M_ByteBlock,
    pub warrants: *mut M_wrap_vec_ImpathWarrant,
}
#[test]
fn bindgen_test_layout_M_Cmd_ImpathKXFinish_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ImpathKXFinish_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ImpathKXFinish_Args>(),
        56usize,
        concat!("Size of: ", stringify!(M_Cmd_ImpathKXFinish_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ImpathKXFinish_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_ImpathKXFinish_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ImpathKXFinish_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).imp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ImpathKXFinish_Args),
            "::",
            stringify!(imp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).addr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ImpathKXFinish_Args),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_keys) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ImpathKXFinish_Args),
            "::",
            stringify!(n_keys)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).keys) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ImpathKXFinish_Args),
            "::",
            stringify!(keys)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kx) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ImpathKXFinish_Args),
            "::",
            stringify!(kx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).warrants) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ImpathKXFinish_Args),
            "::",
            stringify!(warrants)
        )
    );
}
impl Default for M_Cmd_ImpathKXFinish_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ImpathReceive_Args {
    pub imp: M_ImpathID,
    pub cipher: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_Cmd_ImpathReceive_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ImpathReceive_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ImpathReceive_Args>(),
        24usize,
        concat!("Size of: ", stringify!(M_Cmd_ImpathReceive_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ImpathReceive_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_ImpathReceive_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).imp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ImpathReceive_Args),
            "::",
            stringify!(imp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cipher) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ImpathReceive_Args),
            "::",
            stringify!(cipher)
        )
    );
}
impl Default for M_Cmd_ImpathReceive_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_ImpathSend_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ImpathSend_Args {
    pub flags: M_Cmd_ImpathSend_Args_flags,
    pub imp: M_ImpathID,
    pub data: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_Cmd_ImpathSend_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ImpathSend_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ImpathSend_Args>(),
        24usize,
        concat!("Size of: ", stringify!(M_Cmd_ImpathSend_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ImpathSend_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_ImpathSend_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ImpathSend_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).imp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ImpathSend_Args),
            "::",
            stringify!(imp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ImpathSend_Args),
            "::",
            stringify!(data)
        )
    );
}
impl Default for M_Cmd_ImpathSend_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_Import_Args {
    pub module: M_ModuleID,
    pub data: M_KeyData,
    pub acl: M_ACL,
    pub appdata: M_AppData,
}
#[test]
fn bindgen_test_layout_M_Cmd_Import_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_Import_Args> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_Import_Args>(),
        216usize,
        concat!("Size of: ", stringify!(M_Cmd_Import_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_Import_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_Import_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_Import_Args),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_Import_Args),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).acl) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_Import_Args),
            "::",
            stringify!(acl)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).appdata) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_Import_Args),
            "::",
            stringify!(appdata)
        )
    );
}
impl Default for M_Cmd_Import_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_Import_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_Import_Args {{ module: {:?}, data: {:?}, acl: {:?}, appdata: {:?} }}",
            self.module, self.data, self.acl, self.appdata
        )
    }
}
pub type M_Cmd_ImportModule_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ImportModule_Args {
    pub flags: M_Cmd_ImportModule_Args_flags,
    pub module: M_ModuleID,
    pub us: M_RemoteModule,
    pub rm: M_RemoteModule,
}
#[test]
fn bindgen_test_layout_M_Cmd_ImportModule_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ImportModule_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ImportModule_Args>(),
        136usize,
        concat!("Size of: ", stringify!(M_Cmd_ImportModule_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ImportModule_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_ImportModule_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ImportModule_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ImportModule_Args),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).us) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ImportModule_Args),
            "::",
            stringify!(us)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rm) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ImportModule_Args),
            "::",
            stringify!(rm)
        )
    );
}
impl Default for M_Cmd_ImportModule_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_ImportSlot_Args_flags = M_Word;
pub type M_RemoteSlotID = M_Word;
pub type M_vec_Certificate = *mut M_Certificate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_CertificateList {
    pub n_certs: ::core::ffi::c_int,
    pub certs: M_vec_Certificate,
}
#[test]
fn bindgen_test_layout_M_CertificateList() {
    const UNINIT: ::core::mem::MaybeUninit<M_CertificateList> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_CertificateList>(),
        16usize,
        concat!("Size of: ", stringify!(M_CertificateList))
    );
    assert_eq!(
        ::core::mem::align_of::<M_CertificateList>(),
        8usize,
        concat!("Alignment of ", stringify!(M_CertificateList))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_certs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_CertificateList),
            "::",
            stringify!(n_certs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).certs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_CertificateList),
            "::",
            stringify!(certs)
        )
    );
}
impl Default for M_CertificateList {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ImportSlot_Args {
    pub flags: M_Cmd_ImportSlot_Args_flags,
    pub to: M_RemoteModule,
    pub from: M_RemoteModule,
    pub rslot: M_RemoteSlotID,
    pub sendcert: M_CertificateList,
}
#[test]
fn bindgen_test_layout_M_Cmd_ImportSlot_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ImportSlot_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ImportSlot_Args>(),
        160usize,
        concat!("Size of: ", stringify!(M_Cmd_ImportSlot_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ImportSlot_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_ImportSlot_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ImportSlot_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).to) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ImportSlot_Args),
            "::",
            stringify!(to)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).from) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ImportSlot_Args),
            "::",
            stringify!(from)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rslot) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ImportSlot_Args),
            "::",
            stringify!(rslot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sendcert) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ImportSlot_Args),
            "::",
            stringify!(sendcert)
        )
    );
}
impl Default for M_Cmd_ImportSlot_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_InitialiseUnit_Args {
    pub module: M_ModuleID,
}
#[test]
fn bindgen_test_layout_M_Cmd_InitialiseUnit_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_InitialiseUnit_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_InitialiseUnit_Args>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_InitialiseUnit_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_InitialiseUnit_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_InitialiseUnit_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_InitialiseUnit_Args),
            "::",
            stringify!(module)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_InitialiseUnitEx_Args {
    pub flags: M_InitModeFlags,
    pub module: M_ModuleID,
    pub kml: M_KMLType,
}
#[test]
fn bindgen_test_layout_M_Cmd_InitialiseUnitEx_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_InitialiseUnitEx_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_InitialiseUnitEx_Args>(),
        12usize,
        concat!("Size of: ", stringify!(M_Cmd_InitialiseUnitEx_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_InitialiseUnitEx_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_InitialiseUnitEx_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_InitialiseUnitEx_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_InitialiseUnitEx_Args),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kml) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_InitialiseUnitEx_Args),
            "::",
            stringify!(kml)
        )
    );
}
impl Default for M_Cmd_InitialiseUnitEx_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_InsertSoftToken_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_InsertSoftToken_Args {
    pub flags: M_Cmd_InsertSoftToken_Args_flags,
    pub token: M_PhysToken,
    pub data: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_Cmd_InsertSoftToken_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_InsertSoftToken_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_InsertSoftToken_Args>(),
        32usize,
        concat!("Size of: ", stringify!(M_Cmd_InsertSoftToken_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_InsertSoftToken_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_InsertSoftToken_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_InsertSoftToken_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).token) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_InsertSoftToken_Args),
            "::",
            stringify!(token)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_InsertSoftToken_Args),
            "::",
            stringify!(data)
        )
    );
}
impl Default for M_Cmd_InsertSoftToken_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ListRemoteServerPermission_Args {
    pub op: M_RemoteServerOp,
}
#[test]
fn bindgen_test_layout_M_Cmd_ListRemoteServerPermission_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ListRemoteServerPermission_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ListRemoteServerPermission_Args>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(M_Cmd_ListRemoteServerPermission_Args)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ListRemoteServerPermission_Args>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(M_Cmd_ListRemoteServerPermission_Args)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).op) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ListRemoteServerPermission_Args),
            "::",
            stringify!(op)
        )
    );
}
impl Default for M_Cmd_ListRemoteServerPermission_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_ListRemoteServerPermissionEx_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ListRemoteServerPermissionEx_Args {
    pub flags: M_Cmd_ListRemoteServerPermissionEx_Args_flags,
    pub op: M_RemoteServerOp,
    pub offset: M_Word,
}
#[test]
fn bindgen_test_layout_M_Cmd_ListRemoteServerPermissionEx_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ListRemoteServerPermissionEx_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ListRemoteServerPermissionEx_Args>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(M_Cmd_ListRemoteServerPermissionEx_Args)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ListRemoteServerPermissionEx_Args>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(M_Cmd_ListRemoteServerPermissionEx_Args)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ListRemoteServerPermissionEx_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).op) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ListRemoteServerPermissionEx_Args),
            "::",
            stringify!(op)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ListRemoteServerPermissionEx_Args),
            "::",
            stringify!(offset)
        )
    );
}
impl Default for M_Cmd_ListRemoteServerPermissionEx_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_LoadBlob_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_LoadBlob_Args {
    pub flags: M_Cmd_LoadBlob_Args_flags,
    pub module: M_ModuleID,
    pub blob: M_ByteBlock,
    pub idkb: *mut M_KeyID,
    pub file: *mut M_FileSpec,
}
#[test]
fn bindgen_test_layout_M_Cmd_LoadBlob_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_LoadBlob_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_LoadBlob_Args>(),
        40usize,
        concat!("Size of: ", stringify!(M_Cmd_LoadBlob_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_LoadBlob_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_LoadBlob_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_LoadBlob_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_LoadBlob_Args),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).blob) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_LoadBlob_Args),
            "::",
            stringify!(blob)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).idkb) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_LoadBlob_Args),
            "::",
            stringify!(idkb)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).file) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_LoadBlob_Args),
            "::",
            stringify!(file)
        )
    );
}
impl Default for M_Cmd_LoadBlob_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_LoadBuffer_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_LoadBuffer_Args {
    pub id: M_KeyID,
    pub flags: M_Cmd_LoadBuffer_Args_flags,
    pub chunk: M_ByteBlock,
    pub flashsegment: *mut M_Word,
}
#[test]
fn bindgen_test_layout_M_Cmd_LoadBuffer_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_LoadBuffer_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_LoadBuffer_Args>(),
        32usize,
        concat!("Size of: ", stringify!(M_Cmd_LoadBuffer_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_LoadBuffer_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_LoadBuffer_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_LoadBuffer_Args),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_LoadBuffer_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chunk) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_LoadBuffer_Args),
            "::",
            stringify!(chunk)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flashsegment) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_LoadBuffer_Args),
            "::",
            stringify!(flashsegment)
        )
    );
}
impl Default for M_Cmd_LoadBuffer_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_LoadLogicalToken_Args {
    pub module: M_ModuleID,
    pub hkt: M_TokenHash,
    pub hkm: M_KMHash,
    pub params: M_TokenParams,
}
#[test]
fn bindgen_test_layout_M_Cmd_LoadLogicalToken_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_LoadLogicalToken_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_LoadLogicalToken_Args>(),
        60usize,
        concat!("Size of: ", stringify!(M_Cmd_LoadLogicalToken_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_LoadLogicalToken_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_LoadLogicalToken_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_LoadLogicalToken_Args),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hkt) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_LoadLogicalToken_Args),
            "::",
            stringify!(hkt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hkm) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_LoadLogicalToken_Args),
            "::",
            stringify!(hkm)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).params) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_LoadLogicalToken_Args),
            "::",
            stringify!(params)
        )
    );
}
impl Default for M_Cmd_LoadLogicalToken_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_LoadLogicalToken_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_LoadLogicalToken_Args {{ module: {:?}, hkt: {:?}, hkm: {:?}, params: {:?} }}",
            self.module, self.hkt, self.hkm, self.params
        )
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_LoadMonitor_Args {
    pub module: M_ModuleID,
}
#[test]
fn bindgen_test_layout_M_Cmd_LoadMonitor_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_LoadMonitor_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_LoadMonitor_Args>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_LoadMonitor_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_LoadMonitor_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_LoadMonitor_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_LoadMonitor_Args),
            "::",
            stringify!(module)
        )
    );
}
pub type M_Cmd_LoadRaw_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_LoadRaw_Args {
    pub module: M_ModuleID,
    pub flags: M_Cmd_LoadRaw_Args_flags,
    pub absoluteaddr: M_Word,
    pub data: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_Cmd_LoadRaw_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_LoadRaw_Args> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_LoadRaw_Args>(),
        32usize,
        concat!("Size of: ", stringify!(M_Cmd_LoadRaw_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_LoadRaw_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_LoadRaw_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_LoadRaw_Args),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_LoadRaw_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).absoluteaddr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_LoadRaw_Args),
            "::",
            stringify!(absoluteaddr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_LoadRaw_Args),
            "::",
            stringify!(data)
        )
    );
}
impl Default for M_Cmd_LoadRaw_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_Maintenance_Args {
    pub module: M_ModuleID,
}
#[test]
fn bindgen_test_layout_M_Cmd_Maintenance_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_Maintenance_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_Maintenance_Args>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_Maintenance_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_Maintenance_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_Maintenance_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_Maintenance_Args),
            "::",
            stringify!(module)
        )
    );
}
pub type M_Cmd_MakeBlob_Args_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_MakeBlob_Args {
    pub flags: M_Cmd_MakeBlob_Args_flags,
    pub format: M_BlobFormat,
    pub idka: M_KeyID,
    pub blobkey: M_BlobFormat__MkBlobParams,
    pub acl: *mut M_ACL,
    pub file: *mut M_MakeBlobFile,
}
#[test]
fn bindgen_test_layout_M_Cmd_MakeBlob_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_MakeBlob_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_MakeBlob_Args>(),
        48usize,
        concat!("Size of: ", stringify!(M_Cmd_MakeBlob_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_MakeBlob_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_MakeBlob_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_MakeBlob_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_MakeBlob_Args),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).idka) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_MakeBlob_Args),
            "::",
            stringify!(idka)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).blobkey) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_MakeBlob_Args),
            "::",
            stringify!(blobkey)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).acl) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_MakeBlob_Args),
            "::",
            stringify!(acl)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).file) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_MakeBlob_Args),
            "::",
            stringify!(file)
        )
    );
}
impl Default for M_Cmd_MakeBlob_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_MakeBlob_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_Cmd_MakeBlob_Args {{ flags: {:?}, format: {:?}, idka: {:?}, blobkey: {:?}, acl: {:?}, file: {:?} }}" , self . flags , self . format , self . idka , self . blobkey , self . acl , self . file)
    }
}
pub type M_Cmd_MakeSEEWill_Args_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_MakeSEEWill_Args {
    pub willid: M_Hash,
    pub flags: M_Cmd_MakeSEEWill_Args_flags,
    pub worldid: M_KeyID,
    pub will: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_Cmd_MakeSEEWill_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_MakeSEEWill_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_MakeSEEWill_Args>(),
        48usize,
        concat!("Size of: ", stringify!(M_Cmd_MakeSEEWill_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_MakeSEEWill_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_MakeSEEWill_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).willid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_MakeSEEWill_Args),
            "::",
            stringify!(willid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_MakeSEEWill_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).worldid) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_MakeSEEWill_Args),
            "::",
            stringify!(worldid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).will) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_MakeSEEWill_Args),
            "::",
            stringify!(will)
        )
    );
}
impl Default for M_Cmd_MakeSEEWill_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_MakeSEEWill_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_MakeSEEWill_Args {{ willid: {:?}, flags: {:?}, worldid: {:?}, will: {:?} }}",
            self.willid, self.flags, self.worldid, self.will
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_MergeKeyIDs_Args {
    pub n_keys: ::core::ffi::c_int,
    pub keys: M_vec_KeyID,
}
#[test]
fn bindgen_test_layout_M_Cmd_MergeKeyIDs_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_MergeKeyIDs_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_MergeKeyIDs_Args>(),
        16usize,
        concat!("Size of: ", stringify!(M_Cmd_MergeKeyIDs_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_MergeKeyIDs_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_MergeKeyIDs_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_keys) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_MergeKeyIDs_Args),
            "::",
            stringify!(n_keys)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).keys) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_MergeKeyIDs_Args),
            "::",
            stringify!(keys)
        )
    );
}
impl Default for M_Cmd_MergeKeyIDs_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ModExp_Args {
    pub a: M_Bignum,
    pub p: M_Bignum,
    pub n: M_Bignum,
}
#[test]
fn bindgen_test_layout_M_Cmd_ModExp_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ModExp_Args> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ModExp_Args>(),
        24usize,
        concat!("Size of: ", stringify!(M_Cmd_ModExp_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ModExp_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_ModExp_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).a) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ModExp_Args),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ModExp_Args),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ModExp_Args),
            "::",
            stringify!(n)
        )
    );
}
impl Default for M_Cmd_ModExp_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ModExpCrt_Args {
    pub a: M_Bignum,
    pub p: M_Bignum,
    pub q: M_Bignum,
    pub dmp1: M_Bignum,
    pub dmq1: M_Bignum,
    pub iqmp: M_Bignum,
}
#[test]
fn bindgen_test_layout_M_Cmd_ModExpCrt_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ModExpCrt_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ModExpCrt_Args>(),
        48usize,
        concat!("Size of: ", stringify!(M_Cmd_ModExpCrt_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ModExpCrt_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_ModExpCrt_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).a) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ModExpCrt_Args),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ModExpCrt_Args),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).q) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ModExpCrt_Args),
            "::",
            stringify!(q)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dmp1) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ModExpCrt_Args),
            "::",
            stringify!(dmp1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dmq1) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ModExpCrt_Args),
            "::",
            stringify!(dmq1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iqmp) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ModExpCrt_Args),
            "::",
            stringify!(iqmp)
        )
    );
}
impl Default for M_Cmd_ModExpCrt_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_ModuleInfo_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_ModuleInfo_Args {
    pub module: M_ModuleID,
    pub flags: M_Cmd_ModuleInfo_Args_flags,
    pub format: M_Word,
}
#[test]
fn bindgen_test_layout_M_Cmd_ModuleInfo_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ModuleInfo_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ModuleInfo_Args>(),
        12usize,
        concat!("Size of: ", stringify!(M_Cmd_ModuleInfo_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ModuleInfo_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_ModuleInfo_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ModuleInfo_Args),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ModuleInfo_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ModuleInfo_Args),
            "::",
            stringify!(format)
        )
    );
}
pub type M_Cmd_NVMemAlloc_Args_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_NVMemAlloc_Args {
    pub module: M_ModuleID,
    pub flags: M_Cmd_NVMemAlloc_Args_flags,
    pub info: M_FileInfo,
    pub acl: M_ACL,
}
#[test]
fn bindgen_test_layout_M_Cmd_NVMemAlloc_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_NVMemAlloc_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_NVMemAlloc_Args>(),
        48usize,
        concat!("Size of: ", stringify!(M_Cmd_NVMemAlloc_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_NVMemAlloc_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_NVMemAlloc_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_NVMemAlloc_Args),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_NVMemAlloc_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_NVMemAlloc_Args),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).acl) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_NVMemAlloc_Args),
            "::",
            stringify!(acl)
        )
    );
}
impl Default for M_Cmd_NVMemAlloc_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_NVMemAlloc_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_NVMemAlloc_Args {{ module: {:?}, flags: {:?}, info: {:?}, acl: {:?} }}",
            self.module, self.flags, self.info, self.acl
        )
    }
}
pub type M_Cmd_NVMemFree_Args_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_NVMemFree_Args {
    pub module: M_ModuleID,
    pub flags: M_Cmd_NVMemFree_Args_flags,
    pub name: M_FileID,
}
#[test]
fn bindgen_test_layout_M_Cmd_NVMemFree_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_NVMemFree_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_NVMemFree_Args>(),
        20usize,
        concat!("Size of: ", stringify!(M_Cmd_NVMemFree_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_NVMemFree_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_NVMemFree_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_NVMemFree_Args),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_NVMemFree_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_NVMemFree_Args),
            "::",
            stringify!(name)
        )
    );
}
impl Default for M_Cmd_NVMemFree_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_NVMemFree_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_NVMemFree_Args {{ module: {:?}, flags: {:?}, name: {:?} }}",
            self.module, self.flags, self.name
        )
    }
}
pub type M_Cmd_NVMemList_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_NVMemList_Args {
    pub module: M_ModuleID,
    pub flags: M_Cmd_NVMemList_Args_flags,
}
#[test]
fn bindgen_test_layout_M_Cmd_NVMemList_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_NVMemList_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_NVMemList_Args>(),
        8usize,
        concat!("Size of: ", stringify!(M_Cmd_NVMemList_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_NVMemList_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_NVMemList_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_NVMemList_Args),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_NVMemList_Args),
            "::",
            stringify!(flags)
        )
    );
}
pub type M_Cmd_NVMemOp_Args_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_NVMemOp_Args {
    pub module: M_ModuleID,
    pub flags: M_Cmd_NVMemOp_Args_flags,
    pub name: M_FileID,
    pub range: *mut M_NVMemRange,
    pub op: M_NVMemOpType,
    pub val: M_NVMemOpType__OpVal,
}
#[test]
fn bindgen_test_layout_M_Cmd_NVMemOp_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_NVMemOp_Args> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_NVMemOp_Args>(),
        56usize,
        concat!("Size of: ", stringify!(M_Cmd_NVMemOp_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_NVMemOp_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_NVMemOp_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_NVMemOp_Args),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_NVMemOp_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_NVMemOp_Args),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).range) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_NVMemOp_Args),
            "::",
            stringify!(range)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).op) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_NVMemOp_Args),
            "::",
            stringify!(op)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).val) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_NVMemOp_Args),
            "::",
            stringify!(val)
        )
    );
}
impl Default for M_Cmd_NVMemOp_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_NVMemOp_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_Cmd_NVMemOp_Args {{ module: {:?}, flags: {:?}, name: {:?}, range: {:?}, op: {:?}, val: {:?} }}" , self . module , self . flags , self . name , self . range , self . op , self . val)
    }
}
pub type M_Cmd_NewClient_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_NewClient_Args {
    pub flags: M_Cmd_NewClient_Args_flags,
}
#[test]
fn bindgen_test_layout_M_Cmd_NewClient_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_NewClient_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_NewClient_Args>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_NewClient_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_NewClient_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_NewClient_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_NewClient_Args),
            "::",
            stringify!(flags)
        )
    );
}
pub type M_Cmd_NewEnquiry_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_NewEnquiry_Args {
    pub flags: M_Cmd_NewEnquiry_Args_flags,
    pub version: M_Word,
    pub module: M_ModuleID,
}
#[test]
fn bindgen_test_layout_M_Cmd_NewEnquiry_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_NewEnquiry_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_NewEnquiry_Args>(),
        12usize,
        concat!("Size of: ", stringify!(M_Cmd_NewEnquiry_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_NewEnquiry_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_NewEnquiry_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_NewEnquiry_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_NewEnquiry_Args),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_NewEnquiry_Args),
            "::",
            stringify!(module)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_NoOp_Args {
    pub module: M_ModuleID,
}
#[test]
fn bindgen_test_layout_M_Cmd_NoOp_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_NoOp_Args> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_NoOp_Args>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_NoOp_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_NoOp_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_NoOp_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_NoOp_Args),
            "::",
            stringify!(module)
        )
    );
}
pub type M_Cmd_PauseForNotifications_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_PauseForNotifications_Args {
    pub module: M_ModuleID,
    pub flags: M_Cmd_PauseForNotifications_Args_flags,
    pub ms: M_Word,
}
#[test]
fn bindgen_test_layout_M_Cmd_PauseForNotifications_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_PauseForNotifications_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_PauseForNotifications_Args>(),
        12usize,
        concat!("Size of: ", stringify!(M_Cmd_PauseForNotifications_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_PauseForNotifications_Args>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(M_Cmd_PauseForNotifications_Args)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_PauseForNotifications_Args),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_PauseForNotifications_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ms) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_PauseForNotifications_Args),
            "::",
            stringify!(ms)
        )
    );
}
pub type M_Cmd_PollModuleState_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_PollModuleState_Args {
    pub flags: M_Cmd_PollModuleState_Args_flags,
    pub module: M_ModuleID,
}
#[test]
fn bindgen_test_layout_M_Cmd_PollModuleState_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_PollModuleState_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_PollModuleState_Args>(),
        8usize,
        concat!("Size of: ", stringify!(M_Cmd_PollModuleState_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_PollModuleState_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_PollModuleState_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_PollModuleState_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_PollModuleState_Args),
            "::",
            stringify!(module)
        )
    );
}
pub type M_Cmd_PollSlotList_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_PollSlotList_Args {
    pub flags: M_Cmd_PollSlotList_Args_flags,
    pub module: M_ModuleID,
}
#[test]
fn bindgen_test_layout_M_Cmd_PollSlotList_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_PollSlotList_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_PollSlotList_Args>(),
        8usize,
        concat!("Size of: ", stringify!(M_Cmd_PollSlotList_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_PollSlotList_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_PollSlotList_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_PollSlotList_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_PollSlotList_Args),
            "::",
            stringify!(module)
        )
    );
}
pub type M_Cmd_ProductionSetup_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ProductionSetup_Args {
    pub module: M_ModuleID,
    pub flags: M_Cmd_ProductionSetup_Args_flags,
    pub option: M_Word,
    pub data: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_Cmd_ProductionSetup_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ProductionSetup_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ProductionSetup_Args>(),
        32usize,
        concat!("Size of: ", stringify!(M_Cmd_ProductionSetup_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ProductionSetup_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_ProductionSetup_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ProductionSetup_Args),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ProductionSetup_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).option) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ProductionSetup_Args),
            "::",
            stringify!(option)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ProductionSetup_Args),
            "::",
            stringify!(data)
        )
    );
}
impl Default for M_Cmd_ProductionSetup_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_ProgrammingBegin_Args {
    pub module: M_ModuleID,
    pub hkfi: M_KeyHash,
    pub hkfc: M_KeyHash,
    pub sdhash: M_Hash,
    pub sd: M_ByteBlock,
    pub sig: M_CipherText,
}
#[test]
fn bindgen_test_layout_M_Cmd_ProgrammingBegin_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ProgrammingBegin_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ProgrammingBegin_Args>(),
        192usize,
        concat!("Size of: ", stringify!(M_Cmd_ProgrammingBegin_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ProgrammingBegin_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_ProgrammingBegin_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ProgrammingBegin_Args),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hkfi) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ProgrammingBegin_Args),
            "::",
            stringify!(hkfi)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hkfc) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ProgrammingBegin_Args),
            "::",
            stringify!(hkfc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sdhash) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ProgrammingBegin_Args),
            "::",
            stringify!(sdhash)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sd) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ProgrammingBegin_Args),
            "::",
            stringify!(sd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sig) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ProgrammingBegin_Args),
            "::",
            stringify!(sig)
        )
    );
}
impl Default for M_Cmd_ProgrammingBegin_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_ProgrammingBegin_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_Cmd_ProgrammingBegin_Args {{ module: {:?}, hkfi: {:?}, hkfc: {:?}, sdhash: {:?}, sd: {:?}, sig: {:?} }}" , self . module , self . hkfi , self . hkfc , self . sdhash , self . sd , self . sig)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_ProgrammingBeginChunk_Args {
    pub module: M_ModuleID,
    pub index: M_Word,
    pub sdhash: M_Hash,
    pub iv: M_IV,
}
#[test]
fn bindgen_test_layout_M_Cmd_ProgrammingBeginChunk_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ProgrammingBeginChunk_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ProgrammingBeginChunk_Args>(),
        80usize,
        concat!("Size of: ", stringify!(M_Cmd_ProgrammingBeginChunk_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ProgrammingBeginChunk_Args>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(M_Cmd_ProgrammingBeginChunk_Args)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ProgrammingBeginChunk_Args),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ProgrammingBeginChunk_Args),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sdhash) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ProgrammingBeginChunk_Args),
            "::",
            stringify!(sdhash)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iv) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ProgrammingBeginChunk_Args),
            "::",
            stringify!(iv)
        )
    );
}
impl Default for M_Cmd_ProgrammingBeginChunk_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_ProgrammingBeginChunk_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_Cmd_ProgrammingBeginChunk_Args {{ module: {:?}, index: {:?}, sdhash: {:?}, iv: {:?} }}" , self . module , self . index , self . sdhash , self . iv)
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_ProgrammingEnd_Args {
    pub module: M_ModuleID,
}
#[test]
fn bindgen_test_layout_M_Cmd_ProgrammingEnd_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ProgrammingEnd_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ProgrammingEnd_Args>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_ProgrammingEnd_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ProgrammingEnd_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_ProgrammingEnd_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ProgrammingEnd_Args),
            "::",
            stringify!(module)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_ProgrammingEndChunk_Args {
    pub module: M_ModuleID,
}
#[test]
fn bindgen_test_layout_M_Cmd_ProgrammingEndChunk_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ProgrammingEndChunk_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ProgrammingEndChunk_Args>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_ProgrammingEndChunk_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ProgrammingEndChunk_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_ProgrammingEndChunk_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ProgrammingEndChunk_Args),
            "::",
            stringify!(module)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_ProgrammingGetKeyList_Args {
    pub module: M_ModuleID,
}
#[test]
fn bindgen_test_layout_M_Cmd_ProgrammingGetKeyList_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ProgrammingGetKeyList_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ProgrammingGetKeyList_Args>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_ProgrammingGetKeyList_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ProgrammingGetKeyList_Args>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(M_Cmd_ProgrammingGetKeyList_Args)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ProgrammingGetKeyList_Args),
            "::",
            stringify!(module)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ProgrammingLoadBlock_Args {
    pub module: M_ModuleID,
    pub offsetincipher: M_Word,
    pub data: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_Cmd_ProgrammingLoadBlock_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ProgrammingLoadBlock_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ProgrammingLoadBlock_Args>(),
        24usize,
        concat!("Size of: ", stringify!(M_Cmd_ProgrammingLoadBlock_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ProgrammingLoadBlock_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_ProgrammingLoadBlock_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ProgrammingLoadBlock_Args),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).offsetincipher) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ProgrammingLoadBlock_Args),
            "::",
            stringify!(offsetincipher)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ProgrammingLoadBlock_Args),
            "::",
            stringify!(data)
        )
    );
}
impl Default for M_Cmd_ProgrammingLoadBlock_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_QueryLongJobs_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_QueryLongJobs_Args {
    pub module: M_ModuleID,
    pub flags: M_Cmd_QueryLongJobs_Args_flags,
}
#[test]
fn bindgen_test_layout_M_Cmd_QueryLongJobs_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_QueryLongJobs_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_QueryLongJobs_Args>(),
        8usize,
        concat!("Size of: ", stringify!(M_Cmd_QueryLongJobs_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_QueryLongJobs_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_QueryLongJobs_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_QueryLongJobs_Args),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_QueryLongJobs_Args),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_RSAImmedSignDecrypt_Args {
    pub m: M_Bignum,
    pub k_p: M_Bignum,
    pub k_q: M_Bignum,
    pub k_dmp1: M_Bignum,
    pub k_dmq1: M_Bignum,
    pub k_iqmp: M_Bignum,
}
#[test]
fn bindgen_test_layout_M_Cmd_RSAImmedSignDecrypt_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_RSAImmedSignDecrypt_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_RSAImmedSignDecrypt_Args>(),
        48usize,
        concat!("Size of: ", stringify!(M_Cmd_RSAImmedSignDecrypt_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_RSAImmedSignDecrypt_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_RSAImmedSignDecrypt_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_RSAImmedSignDecrypt_Args),
            "::",
            stringify!(m)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).k_p) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_RSAImmedSignDecrypt_Args),
            "::",
            stringify!(k_p)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).k_q) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_RSAImmedSignDecrypt_Args),
            "::",
            stringify!(k_q)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).k_dmp1) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_RSAImmedSignDecrypt_Args),
            "::",
            stringify!(k_dmp1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).k_dmq1) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_RSAImmedSignDecrypt_Args),
            "::",
            stringify!(k_dmq1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).k_iqmp) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_RSAImmedSignDecrypt_Args),
            "::",
            stringify!(k_iqmp)
        )
    );
}
impl Default for M_Cmd_RSAImmedSignDecrypt_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_RSAImmedVerifyEncrypt_Args {
    pub m: M_Bignum,
    pub k_e: M_Bignum,
    pub k_n: M_Bignum,
}
#[test]
fn bindgen_test_layout_M_Cmd_RSAImmedVerifyEncrypt_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_RSAImmedVerifyEncrypt_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_RSAImmedVerifyEncrypt_Args>(),
        24usize,
        concat!("Size of: ", stringify!(M_Cmd_RSAImmedVerifyEncrypt_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_RSAImmedVerifyEncrypt_Args>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(M_Cmd_RSAImmedVerifyEncrypt_Args)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_RSAImmedVerifyEncrypt_Args),
            "::",
            stringify!(m)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).k_e) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_RSAImmedVerifyEncrypt_Args),
            "::",
            stringify!(k_e)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).k_n) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_RSAImmedVerifyEncrypt_Args),
            "::",
            stringify!(k_n)
        )
    );
}
impl Default for M_Cmd_RSAImmedVerifyEncrypt_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_ReReadConfig_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ReReadConfig_Args {
    pub flags: M_Cmd_ReReadConfig_Args_flags,
    pub unused: M_ASCIIString,
}
#[test]
fn bindgen_test_layout_M_Cmd_ReReadConfig_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ReReadConfig_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ReReadConfig_Args>(),
        16usize,
        concat!("Size of: ", stringify!(M_Cmd_ReReadConfig_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ReReadConfig_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_ReReadConfig_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ReReadConfig_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ReReadConfig_Args),
            "::",
            stringify!(unused)
        )
    );
}
impl Default for M_Cmd_ReReadConfig_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_ReadFile_Args_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_ReadFile_Args {
    pub flags: M_Cmd_ReadFile_Args_flags,
    pub token: M_PhysToken,
    pub file: M_FileInfo,
}
#[test]
fn bindgen_test_layout_M_Cmd_ReadFile_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ReadFile_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ReadFile_Args>(),
        36usize,
        concat!("Size of: ", stringify!(M_Cmd_ReadFile_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ReadFile_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_ReadFile_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ReadFile_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).token) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ReadFile_Args),
            "::",
            stringify!(token)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).file) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ReadFile_Args),
            "::",
            stringify!(file)
        )
    );
}
impl Default for M_Cmd_ReadFile_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_ReadFile_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_ReadFile_Args {{ flags: {:?}, token: {:?}, file: {:?} }}",
            self.flags, self.token, self.file
        )
    }
}
pub type M_Cmd_ReadShare_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ReadShare_Args {
    pub flags: M_Cmd_ReadShare_Args_flags,
    pub token: M_PhysToken,
    pub idkt: M_KeyID,
    pub i: M_Word,
    pub pin: *mut M_PIN,
}
#[test]
fn bindgen_test_layout_M_Cmd_ReadShare_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ReadShare_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ReadShare_Args>(),
        32usize,
        concat!("Size of: ", stringify!(M_Cmd_ReadShare_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ReadShare_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_ReadShare_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ReadShare_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).token) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ReadShare_Args),
            "::",
            stringify!(token)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).idkt) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ReadShare_Args),
            "::",
            stringify!(idkt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).i) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ReadShare_Args),
            "::",
            stringify!(i)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pin) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ReadShare_Args),
            "::",
            stringify!(pin)
        )
    );
}
impl Default for M_Cmd_ReadShare_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_ReadSoftTokenShare_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ReadSoftTokenShare_Args {
    pub flags: M_Cmd_ReadSoftTokenShare_Args_flags,
    pub token: M_PhysToken,
    pub data: M_ByteBlock,
    pub idkt: M_KeyID,
    pub i: M_Word,
    pub pin: *mut M_PIN,
}
#[test]
fn bindgen_test_layout_M_Cmd_ReadSoftTokenShare_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ReadSoftTokenShare_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ReadSoftTokenShare_Args>(),
        48usize,
        concat!("Size of: ", stringify!(M_Cmd_ReadSoftTokenShare_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ReadSoftTokenShare_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_ReadSoftTokenShare_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ReadSoftTokenShare_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).token) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ReadSoftTokenShare_Args),
            "::",
            stringify!(token)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ReadSoftTokenShare_Args),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).idkt) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ReadSoftTokenShare_Args),
            "::",
            stringify!(idkt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).i) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ReadSoftTokenShare_Args),
            "::",
            stringify!(i)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pin) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ReadSoftTokenShare_Args),
            "::",
            stringify!(pin)
        )
    );
}
impl Default for M_Cmd_ReadSoftTokenShare_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_ReceiveKey_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ReceiveKey_Args {
    pub flags: M_Cmd_ReceiveKey_Args_flags,
    pub imp: M_ImpathID,
    pub blob: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_Cmd_ReceiveKey_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ReceiveKey_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ReceiveKey_Args>(),
        24usize,
        concat!("Size of: ", stringify!(M_Cmd_ReceiveKey_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ReceiveKey_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_ReceiveKey_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ReceiveKey_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).imp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ReceiveKey_Args),
            "::",
            stringify!(imp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).blob) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ReceiveKey_Args),
            "::",
            stringify!(blob)
        )
    );
}
impl Default for M_Cmd_ReceiveKey_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_ReceiveShare_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ReceiveShare_Args {
    pub flags: M_Cmd_ReceiveShare_Args_flags,
    pub imp: M_ImpathID,
    pub idkt: M_KeyID,
    pub share: M_ByteBlock,
    pub pin: *mut M_PIN,
}
#[test]
fn bindgen_test_layout_M_Cmd_ReceiveShare_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ReceiveShare_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ReceiveShare_Args>(),
        40usize,
        concat!("Size of: ", stringify!(M_Cmd_ReceiveShare_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ReceiveShare_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_ReceiveShare_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ReceiveShare_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).imp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ReceiveShare_Args),
            "::",
            stringify!(imp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).idkt) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ReceiveShare_Args),
            "::",
            stringify!(idkt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).share) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ReceiveShare_Args),
            "::",
            stringify!(share)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pin) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ReceiveShare_Args),
            "::",
            stringify!(pin)
        )
    );
}
impl Default for M_Cmd_ReceiveShare_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_RedeemTicket_Args_flags = M_Word;
pub type M_nest_Ticket = M_ByteBlock;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_RedeemTicket_Args {
    pub flags: M_Cmd_RedeemTicket_Args_flags,
    pub module: M_ModuleID,
    pub ticket: M_nest_Ticket,
}
#[test]
fn bindgen_test_layout_M_Cmd_RedeemTicket_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_RedeemTicket_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_RedeemTicket_Args>(),
        24usize,
        concat!("Size of: ", stringify!(M_Cmd_RedeemTicket_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_RedeemTicket_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_RedeemTicket_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_RedeemTicket_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_RedeemTicket_Args),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ticket) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_RedeemTicket_Args),
            "::",
            stringify!(ticket)
        )
    );
}
impl Default for M_Cmd_RedeemTicket_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_RemoteReboot_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_RemoteReboot_Args {
    pub flags: M_Cmd_RemoteReboot_Args_flags,
    pub module: M_ModuleID,
}
#[test]
fn bindgen_test_layout_M_Cmd_RemoteReboot_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_RemoteReboot_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_RemoteReboot_Args>(),
        8usize,
        concat!("Size of: ", stringify!(M_Cmd_RemoteReboot_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_RemoteReboot_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_RemoteReboot_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_RemoteReboot_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_RemoteReboot_Args),
            "::",
            stringify!(module)
        )
    );
}
pub type M_Cmd_RemoteSlots_Args_flags = M_Word;
pub type M_vec_RemoteSlotParams = *mut M_RemoteSlotParams;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_RemoteSlots_Args {
    pub flags: M_Cmd_RemoteSlots_Args_flags,
    pub n_rsparams: ::core::ffi::c_int,
    pub rsparams: M_vec_RemoteSlotParams,
}
#[test]
fn bindgen_test_layout_M_Cmd_RemoteSlots_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_RemoteSlots_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_RemoteSlots_Args>(),
        16usize,
        concat!("Size of: ", stringify!(M_Cmd_RemoteSlots_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_RemoteSlots_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_RemoteSlots_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_RemoteSlots_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_rsparams) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_RemoteSlots_Args),
            "::",
            stringify!(n_rsparams)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rsparams) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_RemoteSlots_Args),
            "::",
            stringify!(rsparams)
        )
    );
}
impl Default for M_Cmd_RemoteSlots_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_RemoveKM_Args_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_RemoveKM_Args {
    pub module: M_ModuleID,
    pub flags: M_Cmd_RemoveKM_Args_flags,
    pub hkm: M_KMHash,
}
#[test]
fn bindgen_test_layout_M_Cmd_RemoveKM_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_RemoveKM_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_RemoveKM_Args>(),
        28usize,
        concat!("Size of: ", stringify!(M_Cmd_RemoveKM_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_RemoveKM_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_RemoveKM_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_RemoveKM_Args),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_RemoveKM_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hkm) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_RemoveKM_Args),
            "::",
            stringify!(hkm)
        )
    );
}
impl Default for M_Cmd_RemoveKM_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_RemoveKM_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_RemoveKM_Args {{ module: {:?}, flags: {:?}, hkm: {:?} }}",
            self.module, self.flags, self.hkm
        )
    }
}
pub type M_Cmd_RemovePublishedObject_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_RemovePublishedObject_Args {
    pub name: M_HostServiceName,
    pub module: M_ModuleID,
    pub flags: M_Cmd_RemovePublishedObject_Args_flags,
}
#[test]
fn bindgen_test_layout_M_Cmd_RemovePublishedObject_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_RemovePublishedObject_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_RemovePublishedObject_Args>(),
        16usize,
        concat!("Size of: ", stringify!(M_Cmd_RemovePublishedObject_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_RemovePublishedObject_Args>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(M_Cmd_RemovePublishedObject_Args)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_RemovePublishedObject_Args),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_RemovePublishedObject_Args),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_RemovePublishedObject_Args),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for M_Cmd_RemovePublishedObject_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_RemoveRemoteServerPermission_Args {
    pub permid: M_Word,
}
#[test]
fn bindgen_test_layout_M_Cmd_RemoveRemoteServerPermission_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_RemoveRemoteServerPermission_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_RemoveRemoteServerPermission_Args>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(M_Cmd_RemoveRemoteServerPermission_Args)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_RemoveRemoteServerPermission_Args>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(M_Cmd_RemoveRemoteServerPermission_Args)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).permid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_RemoveRemoteServerPermission_Args),
            "::",
            stringify!(permid)
        )
    );
}
pub type M_Cmd_RemoveSoftToken_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_RemoveSoftToken_Args {
    pub flags: M_Cmd_RemoveSoftToken_Args_flags,
    pub token: M_PhysToken,
}
#[test]
fn bindgen_test_layout_M_Cmd_RemoveSoftToken_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_RemoveSoftToken_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_RemoveSoftToken_Args>(),
        16usize,
        concat!("Size of: ", stringify!(M_Cmd_RemoveSoftToken_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_RemoveSoftToken_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_RemoveSoftToken_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_RemoveSoftToken_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).token) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_RemoveSoftToken_Args),
            "::",
            stringify!(token)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_ReportWorldState_Args {
    pub flags: M_Word,
}
#[test]
fn bindgen_test_layout_M_Cmd_ReportWorldState_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ReportWorldState_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ReportWorldState_Args>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_ReportWorldState_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ReportWorldState_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_ReportWorldState_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ReportWorldState_Args),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_RetryFailedModule_Args {
    pub module: M_ModuleID,
}
#[test]
fn bindgen_test_layout_M_Cmd_RetryFailedModule_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_RetryFailedModule_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_RetryFailedModule_Args>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_RetryFailedModule_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_RetryFailedModule_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_RetryFailedModule_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_RetryFailedModule_Args),
            "::",
            stringify!(module)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_SEEJob_Args {
    pub worldid: M_KeyID,
    pub seeargs: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_Cmd_SEEJob_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_SEEJob_Args> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_SEEJob_Args>(),
        24usize,
        concat!("Size of: ", stringify!(M_Cmd_SEEJob_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_SEEJob_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_SEEJob_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).worldid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_SEEJob_Args),
            "::",
            stringify!(worldid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).seeargs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_SEEJob_Args),
            "::",
            stringify!(seeargs)
        )
    );
}
impl Default for M_Cmd_SEEJob_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_SendKey_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_SendKey_Args {
    pub flags: M_Cmd_SendKey_Args_flags,
    pub imp: M_ImpathID,
    pub idka: M_KeyID,
    pub acl: *mut M_ACL,
}
#[test]
fn bindgen_test_layout_M_Cmd_SendKey_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_SendKey_Args> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_SendKey_Args>(),
        24usize,
        concat!("Size of: ", stringify!(M_Cmd_SendKey_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_SendKey_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_SendKey_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_SendKey_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).imp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_SendKey_Args),
            "::",
            stringify!(imp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).idka) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_SendKey_Args),
            "::",
            stringify!(idka)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).acl) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_SendKey_Args),
            "::",
            stringify!(acl)
        )
    );
}
impl Default for M_Cmd_SendKey_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_SendShare_Args_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_SendShare_Args {
    pub flags: M_Cmd_SendShare_Args_flags,
    pub imp: M_ImpathID,
    pub token: M_PhysToken,
    pub i: M_Word,
    pub hkm: M_KMHash,
    pub hkt: M_TokenHash,
    pub pin: *mut M_PIN,
}
#[test]
fn bindgen_test_layout_M_Cmd_SendShare_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_SendShare_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_SendShare_Args>(),
        72usize,
        concat!("Size of: ", stringify!(M_Cmd_SendShare_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_SendShare_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_SendShare_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_SendShare_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).imp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_SendShare_Args),
            "::",
            stringify!(imp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).token) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_SendShare_Args),
            "::",
            stringify!(token)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).i) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_SendShare_Args),
            "::",
            stringify!(i)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hkm) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_SendShare_Args),
            "::",
            stringify!(hkm)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hkt) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_SendShare_Args),
            "::",
            stringify!(hkt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pin) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_SendShare_Args),
            "::",
            stringify!(pin)
        )
    );
}
impl Default for M_Cmd_SendShare_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_SendShare_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_Cmd_SendShare_Args {{ flags: {:?}, imp: {:?}, token: {:?}, i: {:?}, hkm: {:?}, hkt: {:?}, pin: {:?} }}" , self . flags , self . imp , self . token , self . i , self . hkm , self . hkt , self . pin)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ServerNoOp_Args {
    pub module: M_ModuleID,
    pub payload: M_ByteBlock,
    pub replylen: M_Word,
}
#[test]
fn bindgen_test_layout_M_Cmd_ServerNoOp_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ServerNoOp_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ServerNoOp_Args>(),
        32usize,
        concat!("Size of: ", stringify!(M_Cmd_ServerNoOp_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ServerNoOp_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_ServerNoOp_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ServerNoOp_Args),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).payload) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ServerNoOp_Args),
            "::",
            stringify!(payload)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).replylen) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ServerNoOp_Args),
            "::",
            stringify!(replylen)
        )
    );
}
impl Default for M_Cmd_ServerNoOp_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_ServerSendShare_Args_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_ServerSendShare_Args {
    pub flags: M_Cmd_ServerSendShare_Args_flags,
    pub imp: M_MustBeZeroWord,
    pub token: M_PhysToken,
    pub i: M_Word,
    pub hkm: M_KMHash,
    pub hkt: M_TokenHash,
    pub pin: *mut M_PIN,
}
#[test]
fn bindgen_test_layout_M_Cmd_ServerSendShare_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ServerSendShare_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ServerSendShare_Args>(),
        72usize,
        concat!("Size of: ", stringify!(M_Cmd_ServerSendShare_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ServerSendShare_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_ServerSendShare_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ServerSendShare_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).imp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ServerSendShare_Args),
            "::",
            stringify!(imp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).token) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ServerSendShare_Args),
            "::",
            stringify!(token)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).i) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ServerSendShare_Args),
            "::",
            stringify!(i)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hkm) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ServerSendShare_Args),
            "::",
            stringify!(hkm)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hkt) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ServerSendShare_Args),
            "::",
            stringify!(hkt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pin) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ServerSendShare_Args),
            "::",
            stringify!(pin)
        )
    );
}
impl Default for M_Cmd_ServerSendShare_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_ServerSendShare_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_Cmd_ServerSendShare_Args {{ flags: {:?}, imp: {:?}, token: {:?}, i: {:?}, hkm: {:?}, hkt: {:?}, pin: {:?} }}" , self . flags , self . imp , self . token , self . i , self . hkm , self . hkt , self . pin)
    }
}
pub type M_Cmd_SetACL_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_SetACL_Args {
    pub flags: M_Cmd_SetACL_Args_flags,
    pub key: M_KeyID,
    pub newacl: M_ACL,
}
#[test]
fn bindgen_test_layout_M_Cmd_SetACL_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_SetACL_Args> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_SetACL_Args>(),
        24usize,
        concat!("Size of: ", stringify!(M_Cmd_SetACL_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_SetACL_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_SetACL_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_SetACL_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_SetACL_Args),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).newacl) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_SetACL_Args),
            "::",
            stringify!(newacl)
        )
    );
}
impl Default for M_Cmd_SetACL_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_SetAppData_Args {
    pub key: M_KeyID,
    pub appdata: M_AppData,
}
#[test]
fn bindgen_test_layout_M_Cmd_SetAppData_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_SetAppData_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_SetAppData_Args>(),
        68usize,
        concat!("Size of: ", stringify!(M_Cmd_SetAppData_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_SetAppData_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_SetAppData_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_SetAppData_Args),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).appdata) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_SetAppData_Args),
            "::",
            stringify!(appdata)
        )
    );
}
impl Default for M_Cmd_SetAppData_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_SetAppData_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_SetAppData_Args {{ key: {:?}, appdata: {:?} }}",
            self.key, self.appdata
        )
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_RTCTime {
    pub currenttimehigh: M_Word,
    pub currenttimelow: M_Word,
    pub currenttimenanos: M_Word,
    pub precision: M_Word,
}
#[test]
fn bindgen_test_layout_M_RTCTime() {
    const UNINIT: ::core::mem::MaybeUninit<M_RTCTime> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_RTCTime>(),
        16usize,
        concat!("Size of: ", stringify!(M_RTCTime))
    );
    assert_eq!(
        ::core::mem::align_of::<M_RTCTime>(),
        4usize,
        concat!("Alignment of ", stringify!(M_RTCTime))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).currenttimehigh) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_RTCTime),
            "::",
            stringify!(currenttimehigh)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).currenttimelow) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_RTCTime),
            "::",
            stringify!(currenttimelow)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).currenttimenanos) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_RTCTime),
            "::",
            stringify!(currenttimenanos)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).precision) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(M_RTCTime),
            "::",
            stringify!(precision)
        )
    );
}
pub type M_Cmd_SetApplianceTime_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_SetApplianceTime_Args {
    pub module: M_ModuleID,
    pub time: M_RTCTime,
    pub flags: M_Cmd_SetApplianceTime_Args_flags,
}
#[test]
fn bindgen_test_layout_M_Cmd_SetApplianceTime_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_SetApplianceTime_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_SetApplianceTime_Args>(),
        24usize,
        concat!("Size of: ", stringify!(M_Cmd_SetApplianceTime_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_SetApplianceTime_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_SetApplianceTime_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_SetApplianceTime_Args),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_SetApplianceTime_Args),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_SetApplianceTime_Args),
            "::",
            stringify!(flags)
        )
    );
}
pub type M_Cmd_SetApplianceUpgradeStatus_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_SetApplianceUpgradeStatus_Args {
    pub module: M_ModuleID,
    pub error: M_Status,
    pub stage: M_UpgradeState,
    pub flags: M_Cmd_SetApplianceUpgradeStatus_Args_flags,
}
#[test]
fn bindgen_test_layout_M_Cmd_SetApplianceUpgradeStatus_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_SetApplianceUpgradeStatus_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_SetApplianceUpgradeStatus_Args>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(M_Cmd_SetApplianceUpgradeStatus_Args)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_SetApplianceUpgradeStatus_Args>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(M_Cmd_SetApplianceUpgradeStatus_Args)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_SetApplianceUpgradeStatus_Args),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).error) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_SetApplianceUpgradeStatus_Args),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stage) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_SetApplianceUpgradeStatus_Args),
            "::",
            stringify!(stage)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_SetApplianceUpgradeStatus_Args),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for M_Cmd_SetApplianceUpgradeStatus_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_SetKM_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_SetKM_Args {
    pub module: M_ModuleID,
    pub flags: M_Cmd_SetKM_Args_flags,
    pub idka: M_KeyID,
}
#[test]
fn bindgen_test_layout_M_Cmd_SetKM_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_SetKM_Args> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_SetKM_Args>(),
        12usize,
        concat!("Size of: ", stringify!(M_Cmd_SetKM_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_SetKM_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_SetKM_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_SetKM_Args),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_SetKM_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).idka) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_SetKM_Args),
            "::",
            stringify!(idka)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_SetMaxNumClients_Args {
    pub max: M_Word,
}
#[test]
fn bindgen_test_layout_M_Cmd_SetMaxNumClients_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_SetMaxNumClients_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_SetMaxNumClients_Args>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_SetMaxNumClients_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_SetMaxNumClients_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_SetMaxNumClients_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_SetMaxNumClients_Args),
            "::",
            stringify!(max)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_SetNSOPerms_Args {
    pub module: M_ModuleID,
    pub flags: M_NSOPermsModeFlags,
    pub hknso: M_KeyHash,
    pub publicperms: M_NSOPerms,
}
#[test]
fn bindgen_test_layout_M_Cmd_SetNSOPerms_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_SetNSOPerms_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_SetNSOPerms_Args>(),
        32usize,
        concat!("Size of: ", stringify!(M_Cmd_SetNSOPerms_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_SetNSOPerms_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_SetNSOPerms_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_SetNSOPerms_Args),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_SetNSOPerms_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hknso) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_SetNSOPerms_Args),
            "::",
            stringify!(hknso)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).publicperms) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_SetNSOPerms_Args),
            "::",
            stringify!(publicperms)
        )
    );
}
impl Default for M_Cmd_SetNSOPerms_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_SetNSOPerms_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_Cmd_SetNSOPerms_Args {{ module: {:?}, flags: {:?}, hknso: {:?}, publicperms: {:?} }}" , self . module , self . flags , self . hknso , self . publicperms)
    }
}
pub type M_Cmd_SetPrimarySlot_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_SetPrimarySlot_Args {
    pub flags: M_Cmd_SetPrimarySlot_Args_flags,
    pub module: M_ModuleID,
    pub slot: M_Word,
}
#[test]
fn bindgen_test_layout_M_Cmd_SetPrimarySlot_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_SetPrimarySlot_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_SetPrimarySlot_Args>(),
        12usize,
        concat!("Size of: ", stringify!(M_Cmd_SetPrimarySlot_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_SetPrimarySlot_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_SetPrimarySlot_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_SetPrimarySlot_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_SetPrimarySlot_Args),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).slot) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_SetPrimarySlot_Args),
            "::",
            stringify!(slot)
        )
    );
}
pub type M_Cmd_SetPublishedObject_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_SetPublishedObject_Args {
    pub flags: M_Cmd_SetPublishedObject_Args_flags,
    pub name: M_HostServiceName,
    pub module: M_ModuleID,
    pub object: *mut M_KeyID,
    pub data: *mut M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_Cmd_SetPublishedObject_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_SetPublishedObject_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_SetPublishedObject_Args>(),
        40usize,
        concat!("Size of: ", stringify!(M_Cmd_SetPublishedObject_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_SetPublishedObject_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_SetPublishedObject_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_SetPublishedObject_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_SetPublishedObject_Args),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_SetPublishedObject_Args),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).object) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_SetPublishedObject_Args),
            "::",
            stringify!(object)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_SetPublishedObject_Args),
            "::",
            stringify!(data)
        )
    );
}
impl Default for M_Cmd_SetPublishedObject_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_SetRTC_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_SetRTC_Args {
    pub module: M_ModuleID,
    pub flags: M_Cmd_SetRTC_Args_flags,
    pub time: M_RTCTime,
}
#[test]
fn bindgen_test_layout_M_Cmd_SetRTC_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_SetRTC_Args> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_SetRTC_Args>(),
        24usize,
        concat!("Size of: ", stringify!(M_Cmd_SetRTC_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_SetRTC_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_SetRTC_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_SetRTC_Args),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_SetRTC_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_SetRTC_Args),
            "::",
            stringify!(time)
        )
    );
}
pub type M_Cmd_SetSEEMachine_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_SetSEEMachine_Args {
    pub flags: M_Cmd_SetSEEMachine_Args_flags,
    pub buffer: M_KeyID,
}
#[test]
fn bindgen_test_layout_M_Cmd_SetSEEMachine_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_SetSEEMachine_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_SetSEEMachine_Args>(),
        8usize,
        concat!("Size of: ", stringify!(M_Cmd_SetSEEMachine_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_SetSEEMachine_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_SetSEEMachine_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_SetSEEMachine_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_SetSEEMachine_Args),
            "::",
            stringify!(buffer)
        )
    );
}
pub type M_Cmd_Sign_Args_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_Sign_Args {
    pub flags: M_Cmd_Sign_Args_flags,
    pub key: M_KeyID,
    pub mech: M_Mech,
    pub plain: M_PlainText,
    pub given_iv: *mut M_IV,
}
#[test]
fn bindgen_test_layout_M_Cmd_Sign_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_Sign_Args> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_Sign_Args>(),
        96usize,
        concat!("Size of: ", stringify!(M_Cmd_Sign_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_Sign_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_Sign_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_Sign_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_Sign_Args),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mech) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_Sign_Args),
            "::",
            stringify!(mech)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).plain) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_Sign_Args),
            "::",
            stringify!(plain)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).given_iv) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_Sign_Args),
            "::",
            stringify!(given_iv)
        )
    );
}
impl Default for M_Cmd_Sign_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_Sign_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_Sign_Args {{ flags: {:?}, key: {:?}, mech: {:?}, plain: {:?}, given_iv: {:?} }}",
            self.flags, self.key, self.mech, self.plain, self.given_iv
        )
    }
}
pub type M_Cmd_SignModuleState_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_SignerType_AppKey_SignerInfo {
    pub key: M_KeyID,
    pub mech: M_Mech,
}
#[test]
fn bindgen_test_layout_M_SignerType_AppKey_SignerInfo() {
    const UNINIT: ::core::mem::MaybeUninit<M_SignerType_AppKey_SignerInfo> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_SignerType_AppKey_SignerInfo>(),
        8usize,
        concat!("Size of: ", stringify!(M_SignerType_AppKey_SignerInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<M_SignerType_AppKey_SignerInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(M_SignerType_AppKey_SignerInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_SignerType_AppKey_SignerInfo),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mech) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_SignerType_AppKey_SignerInfo),
            "::",
            stringify!(mech)
        )
    );
}
impl Default for M_SignerType_AppKey_SignerInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_SignerType__SignerInfo {
    pub appkey: M_SignerType_AppKey_SignerInfo,
}
#[test]
fn bindgen_test_layout_M_SignerType__SignerInfo() {
    const UNINIT: ::core::mem::MaybeUninit<M_SignerType__SignerInfo> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_SignerType__SignerInfo>(),
        8usize,
        concat!("Size of: ", stringify!(M_SignerType__SignerInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<M_SignerType__SignerInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(M_SignerType__SignerInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).appkey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_SignerType__SignerInfo),
            "::",
            stringify!(appkey)
        )
    );
}
impl Default for M_SignerType__SignerInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_SignerType__SignerInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_SignerType__SignerInfo {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_SignModuleState_Args {
    pub module: M_ModuleID,
    pub flags: M_Cmd_SignModuleState_Args_flags,
    pub signer: M_SignerType,
    pub siginfo: M_SignerType__SignerInfo,
    pub challenge: *mut M_Nonce,
    pub attribs: *mut M_wrap_vec_ModuleAttribTag,
}
#[test]
fn bindgen_test_layout_M_Cmd_SignModuleState_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_SignModuleState_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_SignModuleState_Args>(),
        40usize,
        concat!("Size of: ", stringify!(M_Cmd_SignModuleState_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_SignModuleState_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_SignModuleState_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_SignModuleState_Args),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_SignModuleState_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).signer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_SignModuleState_Args),
            "::",
            stringify!(signer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).siginfo) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_SignModuleState_Args),
            "::",
            stringify!(siginfo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).challenge) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_SignModuleState_Args),
            "::",
            stringify!(challenge)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).attribs) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_SignModuleState_Args),
            "::",
            stringify!(attribs)
        )
    );
}
impl Default for M_Cmd_SignModuleState_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_SignModuleState_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_Cmd_SignModuleState_Args {{ module: {:?}, flags: {:?}, signer: {:?}, siginfo: {:?}, challenge: {:?}, attribs: {:?} }}" , self . module , self . flags , self . signer , self . siginfo , self . challenge , self . attribs)
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_StartUpdateWorld_Args {
    pub module: M_ModuleID,
}
#[test]
fn bindgen_test_layout_M_Cmd_StartUpdateWorld_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_StartUpdateWorld_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_StartUpdateWorld_Args>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_StartUpdateWorld_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_StartUpdateWorld_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_StartUpdateWorld_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_StartUpdateWorld_Args),
            "::",
            stringify!(module)
        )
    );
}
pub type M_Cmd_StatEnumTree_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_StatEnumTree_Args {
    pub flags: M_Cmd_StatEnumTree_Args_flags,
    pub n_path_tags: ::core::ffi::c_int,
    pub path_tags: M_vec_Word,
}
#[test]
fn bindgen_test_layout_M_Cmd_StatEnumTree_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_StatEnumTree_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_StatEnumTree_Args>(),
        16usize,
        concat!("Size of: ", stringify!(M_Cmd_StatEnumTree_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_StatEnumTree_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_StatEnumTree_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_StatEnumTree_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_path_tags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_StatEnumTree_Args),
            "::",
            stringify!(n_path_tags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).path_tags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_StatEnumTree_Args),
            "::",
            stringify!(path_tags)
        )
    );
}
impl Default for M_Cmd_StatEnumTree_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_StatGetValues_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_StatGetValues_Args {
    pub flags: M_Cmd_StatGetValues_Args_flags,
    pub n_path_tags: ::core::ffi::c_int,
    pub path_tags: M_vec_Word,
}
#[test]
fn bindgen_test_layout_M_Cmd_StatGetValues_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_StatGetValues_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_StatGetValues_Args>(),
        16usize,
        concat!("Size of: ", stringify!(M_Cmd_StatGetValues_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_StatGetValues_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_StatGetValues_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_StatGetValues_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_path_tags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_StatGetValues_Args),
            "::",
            stringify!(n_path_tags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).path_tags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_StatGetValues_Args),
            "::",
            stringify!(path_tags)
        )
    );
}
impl Default for M_Cmd_StatGetValues_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_StaticFeatureEnable_Args {
    pub module: M_ModuleID,
    pub info: M_FeatureInfo,
}
#[test]
fn bindgen_test_layout_M_Cmd_StaticFeatureEnable_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_StaticFeatureEnable_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_StaticFeatureEnable_Args>(),
        16usize,
        concat!("Size of: ", stringify!(M_Cmd_StaticFeatureEnable_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_StaticFeatureEnable_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_StaticFeatureEnable_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_StaticFeatureEnable_Args),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_StaticFeatureEnable_Args),
            "::",
            stringify!(info)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_TraceSEEWorld_Args {
    pub worldid: M_KeyID,
}
#[test]
fn bindgen_test_layout_M_Cmd_TraceSEEWorld_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_TraceSEEWorld_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_TraceSEEWorld_Args>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_TraceSEEWorld_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_TraceSEEWorld_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_TraceSEEWorld_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).worldid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_TraceSEEWorld_Args),
            "::",
            stringify!(worldid)
        )
    );
}
pub type M_Cmd_UnimportModule_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_UnimportModule_Args {
    pub flags: M_Cmd_UnimportModule_Args_flags,
    pub module: M_ModuleID,
}
#[test]
fn bindgen_test_layout_M_Cmd_UnimportModule_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_UnimportModule_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_UnimportModule_Args>(),
        8usize,
        concat!("Size of: ", stringify!(M_Cmd_UnimportModule_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_UnimportModule_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_UnimportModule_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_UnimportModule_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_UnimportModule_Args),
            "::",
            stringify!(module)
        )
    );
}
pub type M_Cmd_UnimportSlot_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_UnimportSlot_Args {
    pub flags: M_Cmd_UnimportSlot_Args_flags,
    pub module: M_ModuleID,
    pub slot: M_SlotID,
}
#[test]
fn bindgen_test_layout_M_Cmd_UnimportSlot_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_UnimportSlot_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_UnimportSlot_Args>(),
        12usize,
        concat!("Size of: ", stringify!(M_Cmd_UnimportSlot_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_UnimportSlot_Args>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_UnimportSlot_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_UnimportSlot_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_UnimportSlot_Args),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).slot) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_UnimportSlot_Args),
            "::",
            stringify!(slot)
        )
    );
}
pub type M_Cmd_UpdateMergedKey_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_UpdateMergedKey_Args {
    pub mkey: M_KeyID,
    pub flags: M_Cmd_UpdateMergedKey_Args_flags,
    pub n_addkeys: ::core::ffi::c_int,
    pub addkeys: M_vec_KeyID,
    pub n_delkeys: ::core::ffi::c_int,
    pub delkeys: M_vec_KeyID,
}
#[test]
fn bindgen_test_layout_M_Cmd_UpdateMergedKey_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_UpdateMergedKey_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_UpdateMergedKey_Args>(),
        40usize,
        concat!("Size of: ", stringify!(M_Cmd_UpdateMergedKey_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_UpdateMergedKey_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_UpdateMergedKey_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mkey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_UpdateMergedKey_Args),
            "::",
            stringify!(mkey)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_UpdateMergedKey_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_addkeys) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_UpdateMergedKey_Args),
            "::",
            stringify!(n_addkeys)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).addkeys) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_UpdateMergedKey_Args),
            "::",
            stringify!(addkeys)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_delkeys) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_UpdateMergedKey_Args),
            "::",
            stringify!(n_delkeys)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).delkeys) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_UpdateMergedKey_Args),
            "::",
            stringify!(delkeys)
        )
    );
}
impl Default for M_Cmd_UpdateMergedKey_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_UpgradeApplianceFirmware_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_UpgradeApplianceFirmware_Args {
    pub module: M_ModuleID,
    pub file: M_PathName,
    pub flags: M_Cmd_UpgradeApplianceFirmware_Args_flags,
}
#[test]
fn bindgen_test_layout_M_Cmd_UpgradeApplianceFirmware_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_UpgradeApplianceFirmware_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_UpgradeApplianceFirmware_Args>(),
        24usize,
        concat!("Size of: ", stringify!(M_Cmd_UpgradeApplianceFirmware_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_UpgradeApplianceFirmware_Args>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(M_Cmd_UpgradeApplianceFirmware_Args)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_UpgradeApplianceFirmware_Args),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).file) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_UpgradeApplianceFirmware_Args),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_UpgradeApplianceFirmware_Args),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for M_Cmd_UpgradeApplianceFirmware_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_Verify_Args_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_Verify_Args {
    pub flags: M_Cmd_Verify_Args_flags,
    pub key: M_KeyID,
    pub mech: M_Mech,
    pub plain: M_PlainText,
    pub sig: M_CipherText,
}
#[test]
fn bindgen_test_layout_M_Cmd_Verify_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_Verify_Args> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_Verify_Args>(),
        200usize,
        concat!("Size of: ", stringify!(M_Cmd_Verify_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_Verify_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_Verify_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_Verify_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_Verify_Args),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mech) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_Verify_Args),
            "::",
            stringify!(mech)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).plain) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_Verify_Args),
            "::",
            stringify!(plain)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sig) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_Verify_Args),
            "::",
            stringify!(sig)
        )
    );
}
impl Default for M_Cmd_Verify_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_Verify_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_Verify_Args {{ flags: {:?}, key: {:?}, mech: {:?}, plain: {:?}, sig: {:?} }}",
            self.flags, self.key, self.mech, self.plain, self.sig
        )
    }
}
pub type M_Cmd_VerifyCertificate_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_VerifyCertificate_Args {
    pub flags: M_Cmd_VerifyCertificate_Args_flags,
    pub module: M_ModuleID,
    pub type_: M_CertificateKind,
    pub warrant: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_Cmd_VerifyCertificate_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_VerifyCertificate_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_VerifyCertificate_Args>(),
        32usize,
        concat!("Size of: ", stringify!(M_Cmd_VerifyCertificate_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_VerifyCertificate_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_VerifyCertificate_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_VerifyCertificate_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_VerifyCertificate_Args),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_VerifyCertificate_Args),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).warrant) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_VerifyCertificate_Args),
            "::",
            stringify!(warrant)
        )
    );
}
impl Default for M_Cmd_VerifyCertificate_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_WriteFile_Args_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_WriteFile_Args {
    pub flags: M_Cmd_WriteFile_Args_flags,
    pub token: M_PhysToken,
    pub file: M_FileInfo,
    pub data: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_Cmd_WriteFile_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_WriteFile_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_WriteFile_Args>(),
        56usize,
        concat!("Size of: ", stringify!(M_Cmd_WriteFile_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_WriteFile_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_WriteFile_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_WriteFile_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).token) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_WriteFile_Args),
            "::",
            stringify!(token)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).file) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_WriteFile_Args),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_WriteFile_Args),
            "::",
            stringify!(data)
        )
    );
}
impl Default for M_Cmd_WriteFile_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_WriteFile_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_WriteFile_Args {{ flags: {:?}, token: {:?}, file: {:?}, data: {:?} }}",
            self.flags, self.token, self.file, self.data
        )
    }
}
pub type M_Cmd_WriteShare_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_WriteShare_Args {
    pub flags: M_Cmd_WriteShare_Args_flags,
    pub token: M_PhysToken,
    pub idkt: M_KeyID,
    pub i: M_Word,
    pub pin: *mut M_PIN,
    pub acl: *mut M_ACL,
}
#[test]
fn bindgen_test_layout_M_Cmd_WriteShare_Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_WriteShare_Args> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_WriteShare_Args>(),
        40usize,
        concat!("Size of: ", stringify!(M_Cmd_WriteShare_Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_WriteShare_Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_WriteShare_Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_WriteShare_Args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).token) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_WriteShare_Args),
            "::",
            stringify!(token)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).idkt) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_WriteShare_Args),
            "::",
            stringify!(idkt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).i) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_WriteShare_Args),
            "::",
            stringify!(i)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pin) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_WriteShare_Args),
            "::",
            stringify!(pin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).acl) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_WriteShare_Args),
            "::",
            stringify!(acl)
        )
    );
}
impl Default for M_Cmd_WriteShare_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_Cmd__Args {
    pub addremoteserverpermission: M_Cmd_AddRemoteServerPermission_Args,
    pub anonymousknetihash: M_Cmd_AnonymousKnetiHash_Args,
    pub applyfeaturefile: M_Cmd_ApplyFeatureFile_Args,
    pub bignumop: M_Cmd_BignumOp_Args,
    pub changesharegrouppin: M_Cmd_ChangeShareGroupPIN_Args,
    pub changesharepin: M_Cmd_ChangeSharePIN_Args,
    pub channelopen: M_Cmd_ChannelOpen_Args,
    pub channelupdate: M_Cmd_ChannelUpdate_Args,
    pub checkuseraction: M_Cmd_CheckUserAction_Args,
    pub checkworld: M_Cmd_CheckWorld_Args,
    pub clearunit: M_Cmd_ClearUnit_Args,
    pub clearunitex: M_Cmd_ClearUnitEx_Args,
    pub configurepoolmodule: M_Cmd_ConfigurePoolModule_Args,
    pub createbuffer: M_Cmd_CreateBuffer_Args,
    pub createclient: M_Cmd_CreateClient_Args,
    pub createseeworld: M_Cmd_CreateSEEWorld_Args,
    pub decrypt: M_Cmd_Decrypt_Args,
    pub derivekey: M_Cmd_DeriveKey_Args,
    pub destroy: M_Cmd_Destroy_Args,
    pub devtest: M_Cmd_DevTest_Args,
    pub duplicate: M_Cmd_Duplicate_Args,
    pub dynamicslotcreateassociation: M_Cmd_DynamicSlotCreateAssociation_Args,
    pub dynamicslotexchangeapdus: M_Cmd_DynamicSlotExchangeAPDUs_Args,
    pub dynamicslotsconfigure: M_Cmd_DynamicSlotsConfigure_Args,
    pub dynamicslotsconfigurequery: M_Cmd_DynamicSlotsConfigureQuery_Args,
    pub encrypt: M_Cmd_Encrypt_Args,
    pub erasefile: M_Cmd_EraseFile_Args,
    pub eraseshare: M_Cmd_EraseShare_Args,
    pub eraseworld: M_Cmd_EraseWorld_Args,
    pub executeseewill: M_Cmd_ExecuteSEEWill_Args,
    pub existingclient: M_Cmd_ExistingClient_Args,
    pub export: M_Cmd_Export_Args,
    pub exportmodule: M_Cmd_ExportModule_Args,
    pub exportslot: M_Cmd_ExportSlot_Args,
    pub ftchecksum: M_Cmd_FTChecksum_Args,
    pub ftdelete: M_Cmd_FTDelete_Args,
    pub ftlistdir: M_Cmd_FTListDir_Args,
    pub ftread: M_Cmd_FTRead_Args,
    pub ftsessionopen: M_Cmd_FTSessionOpen_Args,
    pub ftstartlistdir: M_Cmd_FTStartListDir_Args,
    pub ftstartread: M_Cmd_FTStartRead_Args,
    pub ftstartwrite: M_Cmd_FTStartWrite_Args,
    pub ftstat: M_Cmd_FTStat_Args,
    pub ftwrite: M_Cmd_FTWrite_Args,
    pub fail: M_Cmd_Fail_Args,
    pub faildriver: M_Cmd_FailDriver_Args,
    pub fastseejob: M_Cmd_FastSEEJob_Args,
    pub filecopy: M_Cmd_FileCopy_Args,
    pub filecreate: M_Cmd_FileCreate_Args,
    pub fileerase: M_Cmd_FileErase_Args,
    pub fileop: M_Cmd_FileOp_Args,
    pub firmwareauthenticate: M_Cmd_FirmwareAuthenticate_Args,
    pub foreigntokencmd: M_Cmd_ForeignTokenCmd_Args,
    pub foreigntokenopen: M_Cmd_ForeignTokenOpen_Args,
    pub formattoken: M_Cmd_FormatToken_Args,
    pub generateklf: M_Cmd_GenerateKLF_Args,
    pub generatekey: M_Cmd_GenerateKey_Args,
    pub generatekeypair: M_Cmd_GenerateKeyPair_Args,
    pub generatelogicaltoken: M_Cmd_GenerateLogicalToken_Args,
    pub generateprime: M_Cmd_GeneratePrime_Args,
    pub generaterandom: M_Cmd_GenerateRandom_Args,
    pub getacl: M_Cmd_GetACL_Args,
    pub getappdata: M_Cmd_GetAppData_Args,
    pub getappliancetime: M_Cmd_GetApplianceTime_Args,
    pub getapplianceupgradestatus: M_Cmd_GetApplianceUpgradeStatus_Args,
    pub getapplianceversion: M_Cmd_GetApplianceVersion_Args,
    pub getchallenge: M_Cmd_GetChallenge_Args,
    pub gethardwareerror: M_Cmd_GetHardwareError_Args,
    pub getklf: M_Cmd_GetKLF_Args,
    pub getklf2: M_Cmd_GetKLF2_Args,
    pub getkml: M_Cmd_GetKML_Args,
    pub getkmlist: M_Cmd_GetKMList_Args,
    pub getkeyinfo: M_Cmd_GetKeyInfo_Args,
    pub getkeyinfoex: M_Cmd_GetKeyInfoEx_Args,
    pub getknetipub: M_Cmd_GetKnetiPub_Args,
    pub getlogicaltokeninfo: M_Cmd_GetLogicalTokenInfo_Args,
    pub getlogicaltokeninfoex: M_Cmd_GetLogicalTokenInfoEx_Args,
    pub getmodulestate: M_Cmd_GetModuleState_Args,
    pub getmonitorloaderstate: M_Cmd_GetMonitorLoaderState_Args,
    pub getpoolinfo: M_Cmd_GetPoolInfo_Args,
    pub getpublishedobject: M_Cmd_GetPublishedObject_Args,
    pub getrtc: M_Cmd_GetRTC_Args,
    pub getserverconfig: M_Cmd_GetServerConfig_Args,
    pub getshareacl: M_Cmd_GetShareACL_Args,
    pub getslotinfo: M_Cmd_GetSlotInfo_Args,
    pub getslotlist: M_Cmd_GetSlotList_Args,
    pub getticket: M_Cmd_GetTicket_Args,
    pub getwhichmodule: M_Cmd_GetWhichModule_Args,
    pub getworldsigners: M_Cmd_GetWorldSigners_Args,
    pub hash: M_Cmd_Hash_Args,
    pub hotreset: M_Cmd_HotReset_Args,
    pub ioboardreprogram: M_Cmd_IOBoardReprogram_Args,
    pub impathgetinfo: M_Cmd_ImpathGetInfo_Args,
    pub impathkxbegin: M_Cmd_ImpathKXBegin_Args,
    pub impathkxfinish: M_Cmd_ImpathKXFinish_Args,
    pub impathreceive: M_Cmd_ImpathReceive_Args,
    pub impathsend: M_Cmd_ImpathSend_Args,
    pub import: M_Cmd_Import_Args,
    pub importmodule: M_Cmd_ImportModule_Args,
    pub importslot: M_Cmd_ImportSlot_Args,
    pub initialiseunit: M_Cmd_InitialiseUnit_Args,
    pub initialiseunitex: M_Cmd_InitialiseUnitEx_Args,
    pub insertsofttoken: M_Cmd_InsertSoftToken_Args,
    pub listremoteserverpermission: M_Cmd_ListRemoteServerPermission_Args,
    pub listremoteserverpermissionex: M_Cmd_ListRemoteServerPermissionEx_Args,
    pub loadblob: M_Cmd_LoadBlob_Args,
    pub loadbuffer: M_Cmd_LoadBuffer_Args,
    pub loadlogicaltoken: M_Cmd_LoadLogicalToken_Args,
    pub loadmonitor: M_Cmd_LoadMonitor_Args,
    pub loadraw: M_Cmd_LoadRaw_Args,
    pub maintenance: M_Cmd_Maintenance_Args,
    pub makeblob: M_Cmd_MakeBlob_Args,
    pub makeseewill: M_Cmd_MakeSEEWill_Args,
    pub mergekeyids: M_Cmd_MergeKeyIDs_Args,
    pub modexp: M_Cmd_ModExp_Args,
    pub modexpcrt: M_Cmd_ModExpCrt_Args,
    pub moduleinfo: M_Cmd_ModuleInfo_Args,
    pub nvmemalloc: M_Cmd_NVMemAlloc_Args,
    pub nvmemfree: M_Cmd_NVMemFree_Args,
    pub nvmemlist: M_Cmd_NVMemList_Args,
    pub nvmemop: M_Cmd_NVMemOp_Args,
    pub newclient: M_Cmd_NewClient_Args,
    pub newenquiry: M_Cmd_NewEnquiry_Args,
    pub noop: M_Cmd_NoOp_Args,
    pub pausefornotifications: M_Cmd_PauseForNotifications_Args,
    pub pollmodulestate: M_Cmd_PollModuleState_Args,
    pub pollslotlist: M_Cmd_PollSlotList_Args,
    pub productionsetup: M_Cmd_ProductionSetup_Args,
    pub programmingbegin: M_Cmd_ProgrammingBegin_Args,
    pub programmingbeginchunk: M_Cmd_ProgrammingBeginChunk_Args,
    pub programmingend: M_Cmd_ProgrammingEnd_Args,
    pub programmingendchunk: M_Cmd_ProgrammingEndChunk_Args,
    pub programminggetkeylist: M_Cmd_ProgrammingGetKeyList_Args,
    pub programmingloadblock: M_Cmd_ProgrammingLoadBlock_Args,
    pub querylongjobs: M_Cmd_QueryLongJobs_Args,
    pub rsaimmedsigndecrypt: M_Cmd_RSAImmedSignDecrypt_Args,
    pub rsaimmedverifyencrypt: M_Cmd_RSAImmedVerifyEncrypt_Args,
    pub rereadconfig: M_Cmd_ReReadConfig_Args,
    pub readfile: M_Cmd_ReadFile_Args,
    pub readshare: M_Cmd_ReadShare_Args,
    pub readsofttokenshare: M_Cmd_ReadSoftTokenShare_Args,
    pub receivekey: M_Cmd_ReceiveKey_Args,
    pub receiveshare: M_Cmd_ReceiveShare_Args,
    pub redeemticket: M_Cmd_RedeemTicket_Args,
    pub remotereboot: M_Cmd_RemoteReboot_Args,
    pub remoteslots: M_Cmd_RemoteSlots_Args,
    pub removekm: M_Cmd_RemoveKM_Args,
    pub removepublishedobject: M_Cmd_RemovePublishedObject_Args,
    pub removeremoteserverpermission: M_Cmd_RemoveRemoteServerPermission_Args,
    pub removesofttoken: M_Cmd_RemoveSoftToken_Args,
    pub reportworldstate: M_Cmd_ReportWorldState_Args,
    pub retryfailedmodule: M_Cmd_RetryFailedModule_Args,
    pub seejob: M_Cmd_SEEJob_Args,
    pub sendkey: M_Cmd_SendKey_Args,
    pub sendshare: M_Cmd_SendShare_Args,
    pub servernoop: M_Cmd_ServerNoOp_Args,
    pub serversendshare: M_Cmd_ServerSendShare_Args,
    pub setacl: M_Cmd_SetACL_Args,
    pub setappdata: M_Cmd_SetAppData_Args,
    pub setappliancetime: M_Cmd_SetApplianceTime_Args,
    pub setapplianceupgradestatus: M_Cmd_SetApplianceUpgradeStatus_Args,
    pub setkm: M_Cmd_SetKM_Args,
    pub setmaxnumclients: M_Cmd_SetMaxNumClients_Args,
    pub setnsoperms: M_Cmd_SetNSOPerms_Args,
    pub setprimaryslot: M_Cmd_SetPrimarySlot_Args,
    pub setpublishedobject: M_Cmd_SetPublishedObject_Args,
    pub setrtc: M_Cmd_SetRTC_Args,
    pub setseemachine: M_Cmd_SetSEEMachine_Args,
    pub sign: M_Cmd_Sign_Args,
    pub signmodulestate: M_Cmd_SignModuleState_Args,
    pub startupdateworld: M_Cmd_StartUpdateWorld_Args,
    pub statenumtree: M_Cmd_StatEnumTree_Args,
    pub statgetvalues: M_Cmd_StatGetValues_Args,
    pub staticfeatureenable: M_Cmd_StaticFeatureEnable_Args,
    pub traceseeworld: M_Cmd_TraceSEEWorld_Args,
    pub unimportmodule: M_Cmd_UnimportModule_Args,
    pub unimportslot: M_Cmd_UnimportSlot_Args,
    pub updatemergedkey: M_Cmd_UpdateMergedKey_Args,
    pub upgradeappliancefirmware: M_Cmd_UpgradeApplianceFirmware_Args,
    pub verify: M_Cmd_Verify_Args,
    pub verifycertificate: M_Cmd_VerifyCertificate_Args,
    pub writefile: M_Cmd_WriteFile_Args,
    pub writeshare: M_Cmd_WriteShare_Args,
}
#[test]
fn bindgen_test_layout_M_Cmd__Args() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd__Args> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd__Args>(),
        232usize,
        concat!("Size of: ", stringify!(M_Cmd__Args))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd__Args>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd__Args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).addremoteserverpermission) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(addremoteserverpermission)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).anonymousknetihash) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(anonymousknetihash)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).applyfeaturefile) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(applyfeaturefile)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bignumop) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(bignumop)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).changesharegrouppin) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(changesharegrouppin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).changesharepin) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(changesharepin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).channelopen) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(channelopen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).channelupdate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(channelupdate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).checkuseraction) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(checkuseraction)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).checkworld) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(checkworld)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).clearunit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(clearunit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).clearunitex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(clearunitex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).configurepoolmodule) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(configurepoolmodule)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).createbuffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(createbuffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).createclient) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(createclient)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).createseeworld) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(createseeworld)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).decrypt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(decrypt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).derivekey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(derivekey)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).destroy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).devtest) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(devtest)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).duplicate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(duplicate)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).dynamicslotcreateassociation) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(dynamicslotcreateassociation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dynamicslotexchangeapdus) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(dynamicslotexchangeapdus)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dynamicslotsconfigure) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(dynamicslotsconfigure)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dynamicslotsconfigurequery) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(dynamicslotsconfigurequery)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).encrypt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(encrypt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).erasefile) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(erasefile)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).eraseshare) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(eraseshare)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).eraseworld) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(eraseworld)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).executeseewill) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(executeseewill)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).existingclient) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(existingclient)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).export) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(export)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).exportmodule) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(exportmodule)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).exportslot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(exportslot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ftchecksum) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(ftchecksum)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ftdelete) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(ftdelete)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ftlistdir) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(ftlistdir)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ftread) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(ftread)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ftsessionopen) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(ftsessionopen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ftstartlistdir) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(ftstartlistdir)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ftstartread) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(ftstartread)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ftstartwrite) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(ftstartwrite)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ftstat) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(ftstat)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ftwrite) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(ftwrite)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fail) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(fail)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).faildriver) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(faildriver)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fastseejob) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(fastseejob)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).filecopy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(filecopy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).filecreate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(filecreate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fileerase) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(fileerase)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fileop) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(fileop)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).firmwareauthenticate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(firmwareauthenticate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).foreigntokencmd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(foreigntokencmd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).foreigntokenopen) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(foreigntokenopen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).formattoken) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(formattoken)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).generateklf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(generateklf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).generatekey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(generatekey)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).generatekeypair) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(generatekeypair)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).generatelogicaltoken) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(generatelogicaltoken)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).generateprime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(generateprime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).generaterandom) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(generaterandom)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getacl) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(getacl)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getappdata) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(getappdata)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getappliancetime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(getappliancetime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getapplianceupgradestatus) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(getapplianceupgradestatus)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getapplianceversion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(getapplianceversion)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getchallenge) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(getchallenge)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gethardwareerror) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(gethardwareerror)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getklf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(getklf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getklf2) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(getklf2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getkml) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(getkml)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getkmlist) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(getkmlist)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getkeyinfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(getkeyinfo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getkeyinfoex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(getkeyinfoex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getknetipub) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(getknetipub)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getlogicaltokeninfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(getlogicaltokeninfo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getlogicaltokeninfoex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(getlogicaltokeninfoex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getmodulestate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(getmodulestate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getmonitorloaderstate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(getmonitorloaderstate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getpoolinfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(getpoolinfo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getpublishedobject) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(getpublishedobject)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getrtc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(getrtc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getserverconfig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(getserverconfig)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getshareacl) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(getshareacl)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getslotinfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(getslotinfo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getslotlist) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(getslotlist)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getticket) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(getticket)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getwhichmodule) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(getwhichmodule)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getworldsigners) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(getworldsigners)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hash) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hotreset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(hotreset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ioboardreprogram) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(ioboardreprogram)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).impathgetinfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(impathgetinfo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).impathkxbegin) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(impathkxbegin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).impathkxfinish) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(impathkxfinish)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).impathreceive) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(impathreceive)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).impathsend) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(impathsend)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).import) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(import)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).importmodule) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(importmodule)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).importslot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(importslot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).initialiseunit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(initialiseunit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).initialiseunitex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(initialiseunitex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).insertsofttoken) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(insertsofttoken)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).listremoteserverpermission) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(listremoteserverpermission)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).listremoteserverpermissionex) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(listremoteserverpermissionex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).loadblob) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(loadblob)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).loadbuffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(loadbuffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).loadlogicaltoken) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(loadlogicaltoken)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).loadmonitor) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(loadmonitor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).loadraw) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(loadraw)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).maintenance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(maintenance)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).makeblob) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(makeblob)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).makeseewill) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(makeseewill)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mergekeyids) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(mergekeyids)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).modexp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(modexp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).modexpcrt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(modexpcrt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).moduleinfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(moduleinfo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nvmemalloc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(nvmemalloc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nvmemfree) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(nvmemfree)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nvmemlist) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(nvmemlist)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nvmemop) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(nvmemop)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).newclient) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(newclient)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).newenquiry) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(newenquiry)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).noop) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(noop)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pausefornotifications) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(pausefornotifications)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pollmodulestate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(pollmodulestate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pollslotlist) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(pollslotlist)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).productionsetup) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(productionsetup)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).programmingbegin) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(programmingbegin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).programmingbeginchunk) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(programmingbeginchunk)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).programmingend) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(programmingend)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).programmingendchunk) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(programmingendchunk)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).programminggetkeylist) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(programminggetkeylist)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).programmingloadblock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(programmingloadblock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).querylongjobs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(querylongjobs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rsaimmedsigndecrypt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(rsaimmedsigndecrypt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rsaimmedverifyencrypt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(rsaimmedverifyencrypt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rereadconfig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(rereadconfig)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).readfile) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(readfile)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).readshare) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(readshare)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).readsofttokenshare) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(readsofttokenshare)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).receivekey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(receivekey)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).receiveshare) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(receiveshare)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).redeemticket) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(redeemticket)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).remotereboot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(remotereboot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).remoteslots) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(remoteslots)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).removekm) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(removekm)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).removepublishedobject) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(removepublishedobject)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).removeremoteserverpermission) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(removeremoteserverpermission)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).removesofttoken) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(removesofttoken)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reportworldstate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(reportworldstate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).retryfailedmodule) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(retryfailedmodule)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).seejob) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(seejob)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sendkey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(sendkey)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sendshare) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(sendshare)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).servernoop) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(servernoop)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).serversendshare) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(serversendshare)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).setacl) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(setacl)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).setappdata) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(setappdata)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).setappliancetime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(setappliancetime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).setapplianceupgradestatus) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(setapplianceupgradestatus)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).setkm) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(setkm)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).setmaxnumclients) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(setmaxnumclients)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).setnsoperms) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(setnsoperms)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).setprimaryslot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(setprimaryslot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).setpublishedobject) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(setpublishedobject)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).setrtc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(setrtc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).setseemachine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(setseemachine)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sign) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(sign)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).signmodulestate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(signmodulestate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).startupdateworld) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(startupdateworld)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).statenumtree) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(statenumtree)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).statgetvalues) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(statgetvalues)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).staticfeatureenable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(staticfeatureenable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).traceseeworld) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(traceseeworld)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unimportmodule) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(unimportmodule)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unimportslot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(unimportslot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).updatemergedkey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(updatemergedkey)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).upgradeappliancefirmware) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(upgradeappliancefirmware)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).verify) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(verify)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).verifycertificate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(verifycertificate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).writefile) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(writefile)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).writeshare) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Args),
            "::",
            stringify!(writeshare)
        )
    );
}
impl Default for M_Cmd__Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd__Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Cmd__Args {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Command {
    pub tag: M_Tag,
    pub cmd: M_Cmd,
    pub status: M_MustBeZeroWord,
    pub flags: M_Command_flags,
    pub state: *mut M_StateList,
    pub args: M_Cmd__Args,
    pub certs: *mut M_CertificateList,
    pub extractstate: *mut M_ExtractStateParams,
}
#[test]
fn bindgen_test_layout_M_Command() {
    const UNINIT: ::core::mem::MaybeUninit<M_Command> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Command>(),
        272usize,
        concat!("Size of: ", stringify!(M_Command))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Command>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Command))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tag) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Command),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Command),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Command),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Command),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Command),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).args) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Command),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).certs) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Command),
            "::",
            stringify!(certs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).extractstate) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Command),
            "::",
            stringify!(extractstate)
        )
    );
}
impl Default for M_Command {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Command {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_Command {{ tag: {:?}, cmd: {:?}, status: {:?}, flags: {:?}, state: {:?}, args: {:?}, certs: {:?}, extractstate: {:?} }}" , self . tag , self . cmd , self . status , self . flags , self . state , self . args , self . certs , self . extractstate)
    }
}
pub type M_StateMap_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_StateMap {
    pub flags: M_StateMap_flags,
    pub keyID: M_KeyID,
    pub state: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_StateMap() {
    const UNINIT: ::core::mem::MaybeUninit<M_StateMap> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_StateMap>(),
        24usize,
        concat!("Size of: ", stringify!(M_StateMap))
    );
    assert_eq!(
        ::core::mem::align_of::<M_StateMap>(),
        8usize,
        concat!("Alignment of ", stringify!(M_StateMap))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_StateMap),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).keyID) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_StateMap),
            "::",
            stringify!(keyID)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_StateMap),
            "::",
            stringify!(state)
        )
    );
}
impl Default for M_StateMap {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_StateMapHook = M_StateMap;
pub type M_vec_StateMapHook = *mut M_StateMapHook;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_StateList {
    pub n_statemap: ::core::ffi::c_int,
    pub statemap: M_vec_StateMapHook,
}
#[test]
fn bindgen_test_layout_M_StateList() {
    const UNINIT: ::core::mem::MaybeUninit<M_StateList> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_StateList>(),
        16usize,
        concat!("Size of: ", stringify!(M_StateList))
    );
    assert_eq!(
        ::core::mem::align_of::<M_StateList>(),
        8usize,
        concat!("Alignment of ", stringify!(M_StateList))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_statemap) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_StateList),
            "::",
            stringify!(n_statemap)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).statemap) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_StateList),
            "::",
            stringify!(statemap)
        )
    );
}
impl Default for M_StateList {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_StackOpVal {
    pub op: M_StackOp,
    pub val: M_Word,
}
#[test]
fn bindgen_test_layout_M_StackOpVal() {
    const UNINIT: ::core::mem::MaybeUninit<M_StackOpVal> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_StackOpVal>(),
        8usize,
        concat!("Size of: ", stringify!(M_StackOpVal))
    );
    assert_eq!(
        ::core::mem::align_of::<M_StackOpVal>(),
        4usize,
        concat!("Alignment of ", stringify!(M_StackOpVal))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).op) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_StackOpVal),
            "::",
            stringify!(op)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).val) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_StackOpVal),
            "::",
            stringify!(val)
        )
    );
}
impl Default for M_StackOpVal {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_ShareInfo {
    pub hkm: M_KMHash,
    pub hkt: M_ShortHash,
    pub i: M_Word,
}
#[test]
fn bindgen_test_layout_M_ShareInfo() {
    const UNINIT: ::core::mem::MaybeUninit<M_ShareInfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_ShareInfo>(),
        36usize,
        concat!("Size of: ", stringify!(M_ShareInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<M_ShareInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(M_ShareInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hkm) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ShareInfo),
            "::",
            stringify!(hkm)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hkt) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ShareInfo),
            "::",
            stringify!(hkt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).i) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ShareInfo),
            "::",
            stringify!(i)
        )
    );
}
impl Default for M_ShareInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_ShareInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_ShareInfo {{ hkm: {:?}, hkt: {:?}, i: {:?} }}",
            self.hkm, self.hkt, self.i
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_EncryptionParams {
    pub key: M_KeyID,
    pub iv: M_IV,
}
#[test]
fn bindgen_test_layout_M_EncryptionParams() {
    const UNINIT: ::core::mem::MaybeUninit<M_EncryptionParams> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_EncryptionParams>(),
        56usize,
        concat!("Size of: ", stringify!(M_EncryptionParams))
    );
    assert_eq!(
        ::core::mem::align_of::<M_EncryptionParams>(),
        8usize,
        concat!("Alignment of ", stringify!(M_EncryptionParams))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EncryptionParams),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iv) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EncryptionParams),
            "::",
            stringify!(iv)
        )
    );
}
impl Default for M_EncryptionParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_EncryptionParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_EncryptionParams {{ key: {:?}, iv: {:?} }}",
            self.key, self.iv
        )
    }
}
pub type M_PermissionGroup_flags = M_Word;
pub type M_vec_UseLimit = *mut M_UseLimit;
pub type M_vec_Action = *mut M_Action;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_PermissionGroup {
    pub flags: M_PermissionGroup_flags,
    pub n_limits: ::core::ffi::c_int,
    pub limits: M_vec_UseLimit,
    pub n_actions: ::core::ffi::c_int,
    pub actions: M_vec_Action,
    pub certifier: *mut M_KeyHash,
    pub certmech: *mut M_KeyHashAndMech,
    pub moduleserial: *mut M_ASCIIString,
}
#[test]
fn bindgen_test_layout_M_PermissionGroup() {
    const UNINIT: ::core::mem::MaybeUninit<M_PermissionGroup> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_PermissionGroup>(),
        56usize,
        concat!("Size of: ", stringify!(M_PermissionGroup))
    );
    assert_eq!(
        ::core::mem::align_of::<M_PermissionGroup>(),
        8usize,
        concat!("Alignment of ", stringify!(M_PermissionGroup))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_PermissionGroup),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_limits) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_PermissionGroup),
            "::",
            stringify!(n_limits)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).limits) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_PermissionGroup),
            "::",
            stringify!(limits)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_actions) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_PermissionGroup),
            "::",
            stringify!(n_actions)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).actions) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_PermissionGroup),
            "::",
            stringify!(actions)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).certifier) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(M_PermissionGroup),
            "::",
            stringify!(certifier)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).certmech) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(M_PermissionGroup),
            "::",
            stringify!(certmech)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).moduleserial) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(M_PermissionGroup),
            "::",
            stringify!(moduleserial)
        )
    );
}
impl Default for M_PermissionGroup {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_ImpathWarrantType_KLF2_Data {
    pub root: M_KeyData,
    pub warrant: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_ImpathWarrantType_KLF2_Data() {
    const UNINIT: ::core::mem::MaybeUninit<M_ImpathWarrantType_KLF2_Data> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_ImpathWarrantType_KLF2_Data>(),
        144usize,
        concat!("Size of: ", stringify!(M_ImpathWarrantType_KLF2_Data))
    );
    assert_eq!(
        ::core::mem::align_of::<M_ImpathWarrantType_KLF2_Data>(),
        8usize,
        concat!("Alignment of ", stringify!(M_ImpathWarrantType_KLF2_Data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).root) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ImpathWarrantType_KLF2_Data),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).warrant) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ImpathWarrantType_KLF2_Data),
            "::",
            stringify!(warrant)
        )
    );
}
impl Default for M_ImpathWarrantType_KLF2_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_ImpathWarrantType_KLF2_Data {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_ImpathWarrantType_KLF2_Data {{ root: {:?}, warrant: {:?} }}",
            self.root, self.warrant
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_ImpathWarrantType__Data {
    pub klf2: M_ImpathWarrantType_KLF2_Data,
}
#[test]
fn bindgen_test_layout_M_ImpathWarrantType__Data() {
    const UNINIT: ::core::mem::MaybeUninit<M_ImpathWarrantType__Data> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_ImpathWarrantType__Data>(),
        144usize,
        concat!("Size of: ", stringify!(M_ImpathWarrantType__Data))
    );
    assert_eq!(
        ::core::mem::align_of::<M_ImpathWarrantType__Data>(),
        8usize,
        concat!("Alignment of ", stringify!(M_ImpathWarrantType__Data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).klf2) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ImpathWarrantType__Data),
            "::",
            stringify!(klf2)
        )
    );
}
impl Default for M_ImpathWarrantType__Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_ImpathWarrantType__Data {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_ImpathWarrantType__Data {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_ImpathWarrant {
    pub type_: M_ImpathWarrantType,
    pub warrant: M_ImpathWarrantType__Data,
}
#[test]
fn bindgen_test_layout_M_ImpathWarrant() {
    const UNINIT: ::core::mem::MaybeUninit<M_ImpathWarrant> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_ImpathWarrant>(),
        152usize,
        concat!("Size of: ", stringify!(M_ImpathWarrant))
    );
    assert_eq!(
        ::core::mem::align_of::<M_ImpathWarrant>(),
        8usize,
        concat!("Alignment of ", stringify!(M_ImpathWarrant))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ImpathWarrant),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).warrant) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ImpathWarrant),
            "::",
            stringify!(warrant)
        )
    );
}
impl Default for M_ImpathWarrant {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_ImpathWarrant {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_ImpathWarrant {{ type: {:?}, warrant: {:?} }}",
            self.type_, self.warrant
        )
    }
}
pub type M_MakeBlobFile_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_MakeBlobFile {
    pub flags: M_MakeBlobFile_flags,
    pub kacl: M_KeyID,
    pub file: M_FileSpec,
}
#[test]
fn bindgen_test_layout_M_MakeBlobFile() {
    const UNINIT: ::core::mem::MaybeUninit<M_MakeBlobFile> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_MakeBlobFile>(),
        48usize,
        concat!("Size of: ", stringify!(M_MakeBlobFile))
    );
    assert_eq!(
        ::core::mem::align_of::<M_MakeBlobFile>(),
        4usize,
        concat!("Alignment of ", stringify!(M_MakeBlobFile))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_MakeBlobFile),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kacl) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_MakeBlobFile),
            "::",
            stringify!(kacl)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).file) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_MakeBlobFile),
            "::",
            stringify!(file)
        )
    );
}
impl Default for M_MakeBlobFile {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_MakeBlobFile {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_MakeBlobFile {{ flags: {:?}, kacl: {:?}, file: {:?} }}",
            self.flags, self.kacl, self.file
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_RemoteSlotParams {
    pub lm: M_RemoteModule,
    pub lslot: M_SlotID,
    pub rm: M_RemoteModule,
    pub rslot: M_RemoteSlotID,
    pub sendcert: M_CertificateList,
}
#[test]
fn bindgen_test_layout_M_RemoteSlotParams() {
    const UNINIT: ::core::mem::MaybeUninit<M_RemoteSlotParams> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_RemoteSlotParams>(),
        160usize,
        concat!("Size of: ", stringify!(M_RemoteSlotParams))
    );
    assert_eq!(
        ::core::mem::align_of::<M_RemoteSlotParams>(),
        8usize,
        concat!("Alignment of ", stringify!(M_RemoteSlotParams))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lm) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_RemoteSlotParams),
            "::",
            stringify!(lm)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lslot) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(M_RemoteSlotParams),
            "::",
            stringify!(lslot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rm) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(M_RemoteSlotParams),
            "::",
            stringify!(rm)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rslot) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(M_RemoteSlotParams),
            "::",
            stringify!(rslot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sendcert) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(M_RemoteSlotParams),
            "::",
            stringify!(sendcert)
        )
    );
}
impl Default for M_RemoteSlotParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_ExtractStateParams {
    pub format: M_BlobFormat,
    pub blobkey: M_BlobFormat__MkBlobParams,
}
#[test]
fn bindgen_test_layout_M_ExtractStateParams() {
    const UNINIT: ::core::mem::MaybeUninit<M_ExtractStateParams> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_ExtractStateParams>(),
        24usize,
        concat!("Size of: ", stringify!(M_ExtractStateParams))
    );
    assert_eq!(
        ::core::mem::align_of::<M_ExtractStateParams>(),
        4usize,
        concat!("Alignment of ", stringify!(M_ExtractStateParams))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ExtractStateParams),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).blobkey) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ExtractStateParams),
            "::",
            stringify!(blobkey)
        )
    );
}
impl Default for M_ExtractStateParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_ExtractStateParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_ExtractStateParams {{ format: {:?}, blobkey: {:?} }}",
            self.format, self.blobkey
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_UseLim_Auth_Details {
    pub id: M_LimitID,
    pub max: M_Word,
}
#[test]
fn bindgen_test_layout_M_UseLim_Auth_Details() {
    const UNINIT: ::core::mem::MaybeUninit<M_UseLim_Auth_Details> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_UseLim_Auth_Details>(),
        24usize,
        concat!("Size of: ", stringify!(M_UseLim_Auth_Details))
    );
    assert_eq!(
        ::core::mem::align_of::<M_UseLim_Auth_Details>(),
        4usize,
        concat!("Alignment of ", stringify!(M_UseLim_Auth_Details))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_UseLim_Auth_Details),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(M_UseLim_Auth_Details),
            "::",
            stringify!(max)
        )
    );
}
impl Default for M_UseLim_Auth_Details {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_UseLim_Auth_Details {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_UseLim_Auth_Details {{ id: {:?}, max: {:?} }}",
            self.id, self.max
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_UseLim_Global_Details {
    pub id: M_LimitID,
    pub max: M_Word,
}
#[test]
fn bindgen_test_layout_M_UseLim_Global_Details() {
    const UNINIT: ::core::mem::MaybeUninit<M_UseLim_Global_Details> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_UseLim_Global_Details>(),
        24usize,
        concat!("Size of: ", stringify!(M_UseLim_Global_Details))
    );
    assert_eq!(
        ::core::mem::align_of::<M_UseLim_Global_Details>(),
        4usize,
        concat!("Alignment of ", stringify!(M_UseLim_Global_Details))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_UseLim_Global_Details),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(M_UseLim_Global_Details),
            "::",
            stringify!(max)
        )
    );
}
impl Default for M_UseLim_Global_Details {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_UseLim_Global_Details {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_UseLim_Global_Details {{ id: {:?}, max: {:?} }}",
            self.id, self.max
        )
    }
}
pub type M_UseLim_NonVolatile_Details_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_UseLim_NonVolatile_Details {
    pub flags: M_UseLim_NonVolatile_Details_flags,
    pub file: M_FileID,
    pub range: M_NVMemRange,
    pub maxlo: M_Word,
    pub maxhi: M_Word,
    pub prefetch: M_Word,
}
#[test]
fn bindgen_test_layout_M_UseLim_NonVolatile_Details() {
    const UNINIT: ::core::mem::MaybeUninit<M_UseLim_NonVolatile_Details> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_UseLim_NonVolatile_Details>(),
        36usize,
        concat!("Size of: ", stringify!(M_UseLim_NonVolatile_Details))
    );
    assert_eq!(
        ::core::mem::align_of::<M_UseLim_NonVolatile_Details>(),
        4usize,
        concat!("Alignment of ", stringify!(M_UseLim_NonVolatile_Details))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_UseLim_NonVolatile_Details),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).file) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_UseLim_NonVolatile_Details),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).range) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_UseLim_NonVolatile_Details),
            "::",
            stringify!(range)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).maxlo) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_UseLim_NonVolatile_Details),
            "::",
            stringify!(maxlo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).maxhi) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(M_UseLim_NonVolatile_Details),
            "::",
            stringify!(maxhi)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prefetch) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(M_UseLim_NonVolatile_Details),
            "::",
            stringify!(prefetch)
        )
    );
}
impl Default for M_UseLim_NonVolatile_Details {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_UseLim_NonVolatile_Details {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_UseLim_NonVolatile_Details {{ flags: {:?}, file: {:?}, range: {:?}, maxlo: {:?}, maxhi: {:?}, prefetch: {:?} }}" , self . flags , self . file , self . range , self . maxlo , self . maxhi , self . prefetch)
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_UseLim_Time_Details {
    pub seconds: M_Word,
}
#[test]
fn bindgen_test_layout_M_UseLim_Time_Details() {
    const UNINIT: ::core::mem::MaybeUninit<M_UseLim_Time_Details> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_UseLim_Time_Details>(),
        4usize,
        concat!("Size of: ", stringify!(M_UseLim_Time_Details))
    );
    assert_eq!(
        ::core::mem::align_of::<M_UseLim_Time_Details>(),
        4usize,
        concat!("Alignment of ", stringify!(M_UseLim_Time_Details))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).seconds) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_UseLim_Time_Details),
            "::",
            stringify!(seconds)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_UseLim__Details {
    pub auth: M_UseLim_Auth_Details,
    pub global: M_UseLim_Global_Details,
    pub nonvolatile: M_UseLim_NonVolatile_Details,
    pub time: M_UseLim_Time_Details,
}
#[test]
fn bindgen_test_layout_M_UseLim__Details() {
    const UNINIT: ::core::mem::MaybeUninit<M_UseLim__Details> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_UseLim__Details>(),
        36usize,
        concat!("Size of: ", stringify!(M_UseLim__Details))
    );
    assert_eq!(
        ::core::mem::align_of::<M_UseLim__Details>(),
        4usize,
        concat!("Alignment of ", stringify!(M_UseLim__Details))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).auth) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_UseLim__Details),
            "::",
            stringify!(auth)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).global) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_UseLim__Details),
            "::",
            stringify!(global)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nonvolatile) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_UseLim__Details),
            "::",
            stringify!(nonvolatile)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_UseLim__Details),
            "::",
            stringify!(time)
        )
    );
}
impl Default for M_UseLim__Details {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_UseLim__Details {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_UseLim__Details {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_UseLimit {
    pub type_: M_UseLim,
    pub details: M_UseLim__Details,
}
#[test]
fn bindgen_test_layout_M_UseLimit() {
    const UNINIT: ::core::mem::MaybeUninit<M_UseLimit> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_UseLimit>(),
        40usize,
        concat!("Size of: ", stringify!(M_UseLimit))
    );
    assert_eq!(
        ::core::mem::align_of::<M_UseLimit>(),
        4usize,
        concat!("Alignment of ", stringify!(M_UseLimit))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_UseLimit),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).details) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_UseLimit),
            "::",
            stringify!(details)
        )
    );
}
impl Default for M_UseLimit {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_UseLimit {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_UseLimit {{ type: {:?}, details: {:?} }}",
            self.type_, self.details
        )
    }
}
pub type M_Act_DeriveKey_Details_flags = M_Word;
pub type M_vec_KeyRoleID = *mut M_KeyRoleID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Act_DeriveKey_Details {
    pub flags: M_Act_DeriveKey_Details_flags,
    pub role: M_DeriveRole,
    pub mech: M_DeriveMech,
    pub n_otherkeys: ::core::ffi::c_int,
    pub otherkeys: M_vec_KeyRoleID,
    pub params: *mut M_DKMechParams,
}
#[test]
fn bindgen_test_layout_M_Act_DeriveKey_Details() {
    const UNINIT: ::core::mem::MaybeUninit<M_Act_DeriveKey_Details> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Act_DeriveKey_Details>(),
        32usize,
        concat!("Size of: ", stringify!(M_Act_DeriveKey_Details))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Act_DeriveKey_Details>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Act_DeriveKey_Details))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Act_DeriveKey_Details),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).role) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Act_DeriveKey_Details),
            "::",
            stringify!(role)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mech) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Act_DeriveKey_Details),
            "::",
            stringify!(mech)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_otherkeys) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Act_DeriveKey_Details),
            "::",
            stringify!(n_otherkeys)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).otherkeys) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Act_DeriveKey_Details),
            "::",
            stringify!(otherkeys)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).params) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Act_DeriveKey_Details),
            "::",
            stringify!(params)
        )
    );
}
impl Default for M_Act_DeriveKey_Details {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Act_DeriveKeyEx_Details_flags = M_Word;
pub type M_vec_KeyRoleIDEx = *mut M_KeyRoleIDEx;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Act_DeriveKeyEx_Details {
    pub flags: M_Act_DeriveKeyEx_Details_flags,
    pub role: M_DeriveRole,
    pub mech: M_DeriveMech,
    pub n_otherkeys: ::core::ffi::c_int,
    pub otherkeys: M_vec_KeyRoleIDEx,
    pub params: *mut M_DKMechParams,
}
#[test]
fn bindgen_test_layout_M_Act_DeriveKeyEx_Details() {
    const UNINIT: ::core::mem::MaybeUninit<M_Act_DeriveKeyEx_Details> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Act_DeriveKeyEx_Details>(),
        32usize,
        concat!("Size of: ", stringify!(M_Act_DeriveKeyEx_Details))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Act_DeriveKeyEx_Details>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Act_DeriveKeyEx_Details))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Act_DeriveKeyEx_Details),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).role) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Act_DeriveKeyEx_Details),
            "::",
            stringify!(role)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mech) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Act_DeriveKeyEx_Details),
            "::",
            stringify!(mech)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_otherkeys) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Act_DeriveKeyEx_Details),
            "::",
            stringify!(n_otherkeys)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).otherkeys) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Act_DeriveKeyEx_Details),
            "::",
            stringify!(otherkeys)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).params) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Act_DeriveKeyEx_Details),
            "::",
            stringify!(params)
        )
    );
}
impl Default for M_Act_DeriveKeyEx_Details {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Act_FeatureEnable_Details_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Act_FeatureEnable_Details {
    pub flags: M_Act_FeatureEnable_Details_flags,
}
#[test]
fn bindgen_test_layout_M_Act_FeatureEnable_Details() {
    const UNINIT: ::core::mem::MaybeUninit<M_Act_FeatureEnable_Details> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Act_FeatureEnable_Details>(),
        4usize,
        concat!("Size of: ", stringify!(M_Act_FeatureEnable_Details))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Act_FeatureEnable_Details>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Act_FeatureEnable_Details))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Act_FeatureEnable_Details),
            "::",
            stringify!(flags)
        )
    );
}
pub type M_Act_FileCopy_Details_flags = M_Word;
pub type M_FileDeviceFlags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Act_FileCopy_Details {
    pub flags: M_Act_FileCopy_Details_flags,
    pub to: M_FileDeviceFlags,
    pub from: M_FileDeviceFlags,
}
#[test]
fn bindgen_test_layout_M_Act_FileCopy_Details() {
    const UNINIT: ::core::mem::MaybeUninit<M_Act_FileCopy_Details> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Act_FileCopy_Details>(),
        12usize,
        concat!("Size of: ", stringify!(M_Act_FileCopy_Details))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Act_FileCopy_Details>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Act_FileCopy_Details))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Act_FileCopy_Details),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).to) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Act_FileCopy_Details),
            "::",
            stringify!(to)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).from) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Act_FileCopy_Details),
            "::",
            stringify!(from)
        )
    );
}
pub type M_Act_MakeArchiveBlob_Details_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Act_MakeArchiveBlob_Details {
    pub flags: M_Act_MakeArchiveBlob_Details_flags,
    pub mech: M_Mech,
    pub kahash: *mut M_KeyHash,
    pub blobfile: *mut M_MakeBlobFilePerms,
}
#[test]
fn bindgen_test_layout_M_Act_MakeArchiveBlob_Details() {
    const UNINIT: ::core::mem::MaybeUninit<M_Act_MakeArchiveBlob_Details> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Act_MakeArchiveBlob_Details>(),
        24usize,
        concat!("Size of: ", stringify!(M_Act_MakeArchiveBlob_Details))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Act_MakeArchiveBlob_Details>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Act_MakeArchiveBlob_Details))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Act_MakeArchiveBlob_Details),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mech) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Act_MakeArchiveBlob_Details),
            "::",
            stringify!(mech)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kahash) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Act_MakeArchiveBlob_Details),
            "::",
            stringify!(kahash)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).blobfile) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Act_MakeArchiveBlob_Details),
            "::",
            stringify!(blobfile)
        )
    );
}
impl Default for M_Act_MakeArchiveBlob_Details {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Act_MakeBlob_Details_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Act_MakeBlob_Details {
    pub flags: M_Act_MakeBlob_Details_flags,
    pub kmhash: *mut M_KMHash,
    pub kthash: *mut M_TokenHash,
    pub ktparams: *mut M_TokenParams,
    pub blobfile: *mut M_MakeBlobFilePerms,
}
#[test]
fn bindgen_test_layout_M_Act_MakeBlob_Details() {
    const UNINIT: ::core::mem::MaybeUninit<M_Act_MakeBlob_Details> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Act_MakeBlob_Details>(),
        40usize,
        concat!("Size of: ", stringify!(M_Act_MakeBlob_Details))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Act_MakeBlob_Details>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Act_MakeBlob_Details))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Act_MakeBlob_Details),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kmhash) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Act_MakeBlob_Details),
            "::",
            stringify!(kmhash)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kthash) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Act_MakeBlob_Details),
            "::",
            stringify!(kthash)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ktparams) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Act_MakeBlob_Details),
            "::",
            stringify!(ktparams)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).blobfile) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Act_MakeBlob_Details),
            "::",
            stringify!(blobfile)
        )
    );
}
impl Default for M_Act_MakeBlob_Details {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Act_NSOPermissions_Details {
    pub perms: M_NSOPerms,
}
#[test]
fn bindgen_test_layout_M_Act_NSOPermissions_Details() {
    const UNINIT: ::core::mem::MaybeUninit<M_Act_NSOPermissions_Details> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Act_NSOPermissions_Details>(),
        4usize,
        concat!("Size of: ", stringify!(M_Act_NSOPermissions_Details))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Act_NSOPermissions_Details>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Act_NSOPermissions_Details))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).perms) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Act_NSOPermissions_Details),
            "::",
            stringify!(perms)
        )
    );
}
pub type M_Act_NVMemOpPerms_Details_perms = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Act_NVMemOpPerms_Details {
    pub perms: M_Act_NVMemOpPerms_Details_perms,
    pub subrange: *mut M_NVMemRange,
    pub exactrange: *mut M_NVMemRange,
    pub incdeclimit: *mut M_Word,
}
#[test]
fn bindgen_test_layout_M_Act_NVMemOpPerms_Details() {
    const UNINIT: ::core::mem::MaybeUninit<M_Act_NVMemOpPerms_Details> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Act_NVMemOpPerms_Details>(),
        32usize,
        concat!("Size of: ", stringify!(M_Act_NVMemOpPerms_Details))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Act_NVMemOpPerms_Details>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Act_NVMemOpPerms_Details))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).perms) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Act_NVMemOpPerms_Details),
            "::",
            stringify!(perms)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).subrange) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Act_NVMemOpPerms_Details),
            "::",
            stringify!(subrange)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).exactrange) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Act_NVMemOpPerms_Details),
            "::",
            stringify!(exactrange)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).incdeclimit) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Act_NVMemOpPerms_Details),
            "::",
            stringify!(incdeclimit)
        )
    );
}
impl Default for M_Act_NVMemOpPerms_Details {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Act_NVMemUseLimit_Details_flags = M_Word;
pub type M_vec_KeyHash = *mut M_KeyHash;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Act_NVMemUseLimit_Details {
    pub flags: M_Act_NVMemUseLimit_Details_flags,
    pub range: M_NVMemRange,
    pub n_hks: ::core::ffi::c_int,
    pub hks: M_vec_KeyHash,
}
#[test]
fn bindgen_test_layout_M_Act_NVMemUseLimit_Details() {
    const UNINIT: ::core::mem::MaybeUninit<M_Act_NVMemUseLimit_Details> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Act_NVMemUseLimit_Details>(),
        24usize,
        concat!("Size of: ", stringify!(M_Act_NVMemUseLimit_Details))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Act_NVMemUseLimit_Details>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Act_NVMemUseLimit_Details))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Act_NVMemUseLimit_Details),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).range) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Act_NVMemUseLimit_Details),
            "::",
            stringify!(range)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_hks) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Act_NVMemUseLimit_Details),
            "::",
            stringify!(n_hks)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hks) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Act_NVMemUseLimit_Details),
            "::",
            stringify!(hks)
        )
    );
}
impl Default for M_Act_NVMemUseLimit_Details {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Act_OpPermissions_Details_perms = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Act_OpPermissions_Details {
    pub perms: M_Act_OpPermissions_Details_perms,
}
#[test]
fn bindgen_test_layout_M_Act_OpPermissions_Details() {
    const UNINIT: ::core::mem::MaybeUninit<M_Act_OpPermissions_Details> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Act_OpPermissions_Details>(),
        4usize,
        concat!("Size of: ", stringify!(M_Act_OpPermissions_Details))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Act_OpPermissions_Details>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Act_OpPermissions_Details))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).perms) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Act_OpPermissions_Details),
            "::",
            stringify!(perms)
        )
    );
}
pub type M_ReadShareDetails_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_ReadShareDetails {
    pub flags: M_ReadShareDetails_flags,
}
#[test]
fn bindgen_test_layout_M_ReadShareDetails() {
    const UNINIT: ::core::mem::MaybeUninit<M_ReadShareDetails> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_ReadShareDetails>(),
        4usize,
        concat!("Size of: ", stringify!(M_ReadShareDetails))
    );
    assert_eq!(
        ::core::mem::align_of::<M_ReadShareDetails>(),
        4usize,
        concat!("Alignment of ", stringify!(M_ReadShareDetails))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ReadShareDetails),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Act_ReadShare_Details {
    pub rsd: M_ReadShareDetails,
}
#[test]
fn bindgen_test_layout_M_Act_ReadShare_Details() {
    const UNINIT: ::core::mem::MaybeUninit<M_Act_ReadShare_Details> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Act_ReadShare_Details>(),
        4usize,
        concat!("Size of: ", stringify!(M_Act_ReadShare_Details))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Act_ReadShare_Details>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Act_ReadShare_Details))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rsd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Act_ReadShare_Details),
            "::",
            stringify!(rsd)
        )
    );
}
pub type M_Act_SendKey_Details_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Act_SendKey_Details {
    pub flags: M_Act_SendKey_Details_flags,
    pub rm: *mut M_RemoteModule,
}
#[test]
fn bindgen_test_layout_M_Act_SendKey_Details() {
    const UNINIT: ::core::mem::MaybeUninit<M_Act_SendKey_Details> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Act_SendKey_Details>(),
        16usize,
        concat!("Size of: ", stringify!(M_Act_SendKey_Details))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Act_SendKey_Details>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Act_SendKey_Details))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Act_SendKey_Details),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rm) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Act_SendKey_Details),
            "::",
            stringify!(rm)
        )
    );
}
impl Default for M_Act_SendKey_Details {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Act_SendShare_Details_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Act_SendShare_Details {
    pub flags: M_Act_SendShare_Details_flags,
    pub rm: *mut M_RemoteModule,
    pub rsd: *mut M_ReadShareDetails,
}
#[test]
fn bindgen_test_layout_M_Act_SendShare_Details() {
    const UNINIT: ::core::mem::MaybeUninit<M_Act_SendShare_Details> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Act_SendShare_Details>(),
        24usize,
        concat!("Size of: ", stringify!(M_Act_SendShare_Details))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Act_SendShare_Details>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Act_SendShare_Details))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Act_SendShare_Details),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rm) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Act_SendShare_Details),
            "::",
            stringify!(rm)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rsd) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Act_SendShare_Details),
            "::",
            stringify!(rsd)
        )
    );
}
impl Default for M_Act_SendShare_Details {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Act_StaticFeatureEnable_Details {
    pub info: M_FeatureInfo,
}
#[test]
fn bindgen_test_layout_M_Act_StaticFeatureEnable_Details() {
    const UNINIT: ::core::mem::MaybeUninit<M_Act_StaticFeatureEnable_Details> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Act_StaticFeatureEnable_Details>(),
        12usize,
        concat!("Size of: ", stringify!(M_Act_StaticFeatureEnable_Details))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Act_StaticFeatureEnable_Details>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(M_Act_StaticFeatureEnable_Details)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Act_StaticFeatureEnable_Details),
            "::",
            stringify!(info)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Act_UserAction_Details {
    pub allow: M_UserActionInfo,
}
#[test]
fn bindgen_test_layout_M_Act_UserAction_Details() {
    const UNINIT: ::core::mem::MaybeUninit<M_Act_UserAction_Details> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Act_UserAction_Details>(),
        40usize,
        concat!("Size of: ", stringify!(M_Act_UserAction_Details))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Act_UserAction_Details>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Act_UserAction_Details))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).allow) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Act_UserAction_Details),
            "::",
            stringify!(allow)
        )
    );
}
impl Default for M_Act_UserAction_Details {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Act_UserAction_Details {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Act_UserAction_Details {{ allow: {:?} }}", self.allow)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_Act__Details {
    pub derivekey: M_Act_DeriveKey_Details,
    pub derivekeyex: M_Act_DeriveKeyEx_Details,
    pub featureenable: M_Act_FeatureEnable_Details,
    pub filecopy: M_Act_FileCopy_Details,
    pub makearchiveblob: M_Act_MakeArchiveBlob_Details,
    pub makeblob: M_Act_MakeBlob_Details,
    pub nsopermissions: M_Act_NSOPermissions_Details,
    pub nvmemopperms: M_Act_NVMemOpPerms_Details,
    pub nvmemuselimit: M_Act_NVMemUseLimit_Details,
    pub oppermissions: M_Act_OpPermissions_Details,
    pub readshare: M_Act_ReadShare_Details,
    pub sendkey: M_Act_SendKey_Details,
    pub sendshare: M_Act_SendShare_Details,
    pub staticfeatureenable: M_Act_StaticFeatureEnable_Details,
    pub useraction: M_Act_UserAction_Details,
}
#[test]
fn bindgen_test_layout_M_Act__Details() {
    const UNINIT: ::core::mem::MaybeUninit<M_Act__Details> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Act__Details>(),
        40usize,
        concat!("Size of: ", stringify!(M_Act__Details))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Act__Details>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Act__Details))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).derivekey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Act__Details),
            "::",
            stringify!(derivekey)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).derivekeyex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Act__Details),
            "::",
            stringify!(derivekeyex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).featureenable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Act__Details),
            "::",
            stringify!(featureenable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).filecopy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Act__Details),
            "::",
            stringify!(filecopy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).makearchiveblob) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Act__Details),
            "::",
            stringify!(makearchiveblob)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).makeblob) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Act__Details),
            "::",
            stringify!(makeblob)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nsopermissions) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Act__Details),
            "::",
            stringify!(nsopermissions)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nvmemopperms) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Act__Details),
            "::",
            stringify!(nvmemopperms)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nvmemuselimit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Act__Details),
            "::",
            stringify!(nvmemuselimit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).oppermissions) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Act__Details),
            "::",
            stringify!(oppermissions)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).readshare) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Act__Details),
            "::",
            stringify!(readshare)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sendkey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Act__Details),
            "::",
            stringify!(sendkey)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sendshare) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Act__Details),
            "::",
            stringify!(sendshare)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).staticfeatureenable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Act__Details),
            "::",
            stringify!(staticfeatureenable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).useraction) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Act__Details),
            "::",
            stringify!(useraction)
        )
    );
}
impl Default for M_Act__Details {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Act__Details {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Act__Details {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Action {
    pub type_: M_Act,
    pub details: M_Act__Details,
}
#[test]
fn bindgen_test_layout_M_Action() {
    const UNINIT: ::core::mem::MaybeUninit<M_Action> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Action>(),
        48usize,
        concat!("Size of: ", stringify!(M_Action))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Action>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Action))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Action),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).details) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Action),
            "::",
            stringify!(details)
        )
    );
}
impl Default for M_Action {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Action {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Action {{ type: {:?}, details: {:?} }}",
            self.type_, self.details
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_KeyRoleID {
    pub role: M_DeriveRole,
    pub hash: M_KeyHash,
}
#[test]
fn bindgen_test_layout_M_KeyRoleID() {
    const UNINIT: ::core::mem::MaybeUninit<M_KeyRoleID> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_KeyRoleID>(),
        24usize,
        concat!("Size of: ", stringify!(M_KeyRoleID))
    );
    assert_eq!(
        ::core::mem::align_of::<M_KeyRoleID>(),
        4usize,
        concat!("Alignment of ", stringify!(M_KeyRoleID))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).role) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyRoleID),
            "::",
            stringify!(role)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hash) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyRoleID),
            "::",
            stringify!(hash)
        )
    );
}
impl Default for M_KeyRoleID {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_KeyRoleID {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_KeyRoleID {{ role: {:?}, hash: {:?} }}",
            self.role, self.hash
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_KeyRoleIDEx {
    pub role: M_DeriveRole,
    pub hash: M_KeyHashEx,
}
#[test]
fn bindgen_test_layout_M_KeyRoleIDEx() {
    const UNINIT: ::core::mem::MaybeUninit<M_KeyRoleIDEx> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_KeyRoleIDEx>(),
        72usize,
        concat!("Size of: ", stringify!(M_KeyRoleIDEx))
    );
    assert_eq!(
        ::core::mem::align_of::<M_KeyRoleIDEx>(),
        4usize,
        concat!("Alignment of ", stringify!(M_KeyRoleIDEx))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).role) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyRoleIDEx),
            "::",
            stringify!(role)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hash) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_KeyRoleIDEx),
            "::",
            stringify!(hash)
        )
    );
}
impl Default for M_KeyRoleIDEx {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_KeyRoleIDEx {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_KeyRoleIDEx {{ role: {:?}, hash: {:?} }}",
            self.role, self.hash
        )
    }
}
pub type M_MakeBlobFilePerms_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_MakeBlobFilePerms {
    pub flags: M_MakeBlobFilePerms_flags,
    pub devs: *mut M_FileDeviceFlags,
    pub aclhash: *mut M_KeyHash,
}
#[test]
fn bindgen_test_layout_M_MakeBlobFilePerms() {
    const UNINIT: ::core::mem::MaybeUninit<M_MakeBlobFilePerms> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_MakeBlobFilePerms>(),
        24usize,
        concat!("Size of: ", stringify!(M_MakeBlobFilePerms))
    );
    assert_eq!(
        ::core::mem::align_of::<M_MakeBlobFilePerms>(),
        8usize,
        concat!("Alignment of ", stringify!(M_MakeBlobFilePerms))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_MakeBlobFilePerms),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).devs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_MakeBlobFilePerms),
            "::",
            stringify!(devs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).aclhash) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_MakeBlobFilePerms),
            "::",
            stringify!(aclhash)
        )
    );
}
impl Default for M_MakeBlobFilePerms {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Reply_flags = M_Word;
pub type M_Cmd_ANLogEvent_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ANLogEvent_Reply {
    pub flags: M_Cmd_ANLogEvent_Reply_flags,
    pub text: M_ASCIIString,
}
#[test]
fn bindgen_test_layout_M_Cmd_ANLogEvent_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ANLogEvent_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ANLogEvent_Reply>(),
        16usize,
        concat!("Size of: ", stringify!(M_Cmd_ANLogEvent_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ANLogEvent_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_ANLogEvent_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ANLogEvent_Reply),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).text) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ANLogEvent_Reply),
            "::",
            stringify!(text)
        )
    );
}
impl Default for M_Cmd_ANLogEvent_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_ANModuleChangeEvent_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_ANModuleChangeEvent_Reply {
    pub flags: M_Cmd_ANModuleChangeEvent_Reply_flags,
    pub module: M_ModuleID,
}
#[test]
fn bindgen_test_layout_M_Cmd_ANModuleChangeEvent_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ANModuleChangeEvent_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ANModuleChangeEvent_Reply>(),
        8usize,
        concat!("Size of: ", stringify!(M_Cmd_ANModuleChangeEvent_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ANModuleChangeEvent_Reply>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_ANModuleChangeEvent_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ANModuleChangeEvent_Reply),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ANModuleChangeEvent_Reply),
            "::",
            stringify!(module)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_ANRemoteModuleDisconnected_Reply {
    pub st: M_Status,
    pub einfo: M_Status__ErrorInfo,
}
#[test]
fn bindgen_test_layout_M_Cmd_ANRemoteModuleDisconnected_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ANRemoteModuleDisconnected_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ANRemoteModuleDisconnected_Reply>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(M_Cmd_ANRemoteModuleDisconnected_Reply)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ANRemoteModuleDisconnected_Reply>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(M_Cmd_ANRemoteModuleDisconnected_Reply)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).st) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ANRemoteModuleDisconnected_Reply),
            "::",
            stringify!(st)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).einfo) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ANRemoteModuleDisconnected_Reply),
            "::",
            stringify!(einfo)
        )
    );
}
impl Default for M_Cmd_ANRemoteModuleDisconnected_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_ANRemoteModuleDisconnected_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_ANRemoteModuleDisconnected_Reply {{ st: {:?}, einfo: {:?} }}",
            self.st, self.einfo
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_ANRemoteSlotDisconnected_Reply {
    pub slot: M_PhysToken,
    pub st: M_Status,
    pub einfo: M_Status__ErrorInfo,
}
#[test]
fn bindgen_test_layout_M_Cmd_ANRemoteSlotDisconnected_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ANRemoteSlotDisconnected_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ANRemoteSlotDisconnected_Reply>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(M_Cmd_ANRemoteSlotDisconnected_Reply)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ANRemoteSlotDisconnected_Reply>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(M_Cmd_ANRemoteSlotDisconnected_Reply)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).slot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ANRemoteSlotDisconnected_Reply),
            "::",
            stringify!(slot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).st) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ANRemoteSlotDisconnected_Reply),
            "::",
            stringify!(st)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).einfo) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ANRemoteSlotDisconnected_Reply),
            "::",
            stringify!(einfo)
        )
    );
}
impl Default for M_Cmd_ANRemoteSlotDisconnected_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_ANRemoteSlotDisconnected_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_ANRemoteSlotDisconnected_Reply {{ slot: {:?}, st: {:?}, einfo: {:?} }}",
            self.slot, self.st, self.einfo
        )
    }
}
pub type M_Cmd_ANSendAuditLogEvent_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ANSendAuditLogEvent_Reply {
    pub flags: M_Cmd_ANSendAuditLogEvent_Reply_flags,
    pub text: M_ASCIIString,
}
#[test]
fn bindgen_test_layout_M_Cmd_ANSendAuditLogEvent_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ANSendAuditLogEvent_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ANSendAuditLogEvent_Reply>(),
        16usize,
        concat!("Size of: ", stringify!(M_Cmd_ANSendAuditLogEvent_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ANSendAuditLogEvent_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_ANSendAuditLogEvent_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ANSendAuditLogEvent_Reply),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).text) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ANSendAuditLogEvent_Reply),
            "::",
            stringify!(text)
        )
    );
}
impl Default for M_Cmd_ANSendAuditLogEvent_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_ANSlotChangeEvent_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_ANSlotChangeEvent_Reply {
    pub flags: M_Cmd_ANSlotChangeEvent_Reply_flags,
    pub slot: M_PhysToken,
}
#[test]
fn bindgen_test_layout_M_Cmd_ANSlotChangeEvent_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ANSlotChangeEvent_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ANSlotChangeEvent_Reply>(),
        16usize,
        concat!("Size of: ", stringify!(M_Cmd_ANSlotChangeEvent_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ANSlotChangeEvent_Reply>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_ANSlotChangeEvent_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ANSlotChangeEvent_Reply),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).slot) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ANSlotChangeEvent_Reply),
            "::",
            stringify!(slot)
        )
    );
}
pub type M_Cmd_ANSlotsConfigurationChangeEvent_Reply_flags = M_Word;
pub type M_vec_SlotListData = *mut M_SlotListData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ANSlotsConfigurationChangeEvent_Reply {
    pub flags: M_Cmd_ANSlotsConfigurationChangeEvent_Reply_flags,
    pub n_slots: ::core::ffi::c_int,
    pub slots: M_vec_SlotListData,
}
#[test]
fn bindgen_test_layout_M_Cmd_ANSlotsConfigurationChangeEvent_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ANSlotsConfigurationChangeEvent_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ANSlotsConfigurationChangeEvent_Reply>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(M_Cmd_ANSlotsConfigurationChangeEvent_Reply)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ANSlotsConfigurationChangeEvent_Reply>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(M_Cmd_ANSlotsConfigurationChangeEvent_Reply)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ANSlotsConfigurationChangeEvent_Reply),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_slots) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ANSlotsConfigurationChangeEvent_Reply),
            "::",
            stringify!(n_slots)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).slots) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ANSlotsConfigurationChangeEvent_Reply),
            "::",
            stringify!(slots)
        )
    );
}
impl Default for M_Cmd_ANSlotsConfigurationChangeEvent_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_AddRemoteServerPermission_Reply {
    pub permid: M_Word,
}
#[test]
fn bindgen_test_layout_M_Cmd_AddRemoteServerPermission_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_AddRemoteServerPermission_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_AddRemoteServerPermission_Reply>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(M_Cmd_AddRemoteServerPermission_Reply)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_AddRemoteServerPermission_Reply>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(M_Cmd_AddRemoteServerPermission_Reply)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).permid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_AddRemoteServerPermission_Reply),
            "::",
            stringify!(permid)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_AnonymousKnetiHash_Reply {
    pub esn: M_ASCIIString,
    pub kneti: M_KeyHash,
}
#[test]
fn bindgen_test_layout_M_Cmd_AnonymousKnetiHash_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_AnonymousKnetiHash_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_AnonymousKnetiHash_Reply>(),
        32usize,
        concat!("Size of: ", stringify!(M_Cmd_AnonymousKnetiHash_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_AnonymousKnetiHash_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_AnonymousKnetiHash_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).esn) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_AnonymousKnetiHash_Reply),
            "::",
            stringify!(esn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kneti) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_AnonymousKnetiHash_Reply),
            "::",
            stringify!(kneti)
        )
    );
}
impl Default for M_Cmd_AnonymousKnetiHash_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_AnonymousKnetiHash_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_AnonymousKnetiHash_Reply {{ esn: {:?}, kneti: {:?} }}",
            self.esn, self.kneti
        )
    }
}
pub type M_Cmd_ApplyFeatureFile_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_ApplyFeatureFile_Reply {
    pub flags: M_Cmd_ApplyFeatureFile_Reply_flags,
}
#[test]
fn bindgen_test_layout_M_Cmd_ApplyFeatureFile_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ApplyFeatureFile_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ApplyFeatureFile_Reply>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_ApplyFeatureFile_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ApplyFeatureFile_Reply>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_ApplyFeatureFile_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ApplyFeatureFile_Reply),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_BignumOp_Reply {
    pub n_stackout: ::core::ffi::c_int,
    pub stackout: M_vec_Bignum,
}
#[test]
fn bindgen_test_layout_M_Cmd_BignumOp_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_BignumOp_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_BignumOp_Reply>(),
        16usize,
        concat!("Size of: ", stringify!(M_Cmd_BignumOp_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_BignumOp_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_BignumOp_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_stackout) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_BignumOp_Reply),
            "::",
            stringify!(n_stackout)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stackout) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_BignumOp_Reply),
            "::",
            stringify!(stackout)
        )
    );
}
impl Default for M_Cmd_BignumOp_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_ChannelOpen_Reply_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_ChannelOpen_Reply {
    pub flags: M_Cmd_ChannelOpen_Reply_flags,
    pub idch: M_KeyID,
    pub new_iv: *mut M_IV,
    pub openinfo: M_ChannelOpenInfo,
}
#[test]
fn bindgen_test_layout_M_Cmd_ChannelOpen_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ChannelOpen_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ChannelOpen_Reply>(),
        24usize,
        concat!("Size of: ", stringify!(M_Cmd_ChannelOpen_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ChannelOpen_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_ChannelOpen_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ChannelOpen_Reply),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).idch) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ChannelOpen_Reply),
            "::",
            stringify!(idch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).new_iv) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ChannelOpen_Reply),
            "::",
            stringify!(new_iv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).openinfo) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ChannelOpen_Reply),
            "::",
            stringify!(openinfo)
        )
    );
}
impl Default for M_Cmd_ChannelOpen_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_ChannelOpen_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_ChannelOpen_Reply {{ flags: {:?}, idch: {:?}, new_iv: {:?}, openinfo: {:?} }}",
            self.flags, self.idch, self.new_iv, self.openinfo
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ChannelUpdate_Reply {
    pub output: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_Cmd_ChannelUpdate_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ChannelUpdate_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ChannelUpdate_Reply>(),
        16usize,
        concat!("Size of: ", stringify!(M_Cmd_ChannelUpdate_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ChannelUpdate_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_ChannelUpdate_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).output) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ChannelUpdate_Reply),
            "::",
            stringify!(output)
        )
    );
}
impl Default for M_Cmd_ChannelUpdate_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_CheckWorld_Reply {
    pub age: M_Word,
    pub flags: M_Word,
}
#[test]
fn bindgen_test_layout_M_Cmd_CheckWorld_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_CheckWorld_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_CheckWorld_Reply>(),
        8usize,
        concat!("Size of: ", stringify!(M_Cmd_CheckWorld_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_CheckWorld_Reply>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_CheckWorld_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).age) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_CheckWorld_Reply),
            "::",
            stringify!(age)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_CheckWorld_Reply),
            "::",
            stringify!(flags)
        )
    );
}
pub type M_Cmd_ConfigurePoolModule_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_ConfigurePoolModule_Reply {
    pub flags: M_Cmd_ConfigurePoolModule_Reply_flags,
}
#[test]
fn bindgen_test_layout_M_Cmd_ConfigurePoolModule_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ConfigurePoolModule_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ConfigurePoolModule_Reply>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_ConfigurePoolModule_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ConfigurePoolModule_Reply>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_ConfigurePoolModule_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ConfigurePoolModule_Reply),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_CreateBuffer_Reply {
    pub id: M_KeyID,
}
#[test]
fn bindgen_test_layout_M_Cmd_CreateBuffer_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_CreateBuffer_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_CreateBuffer_Reply>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_CreateBuffer_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_CreateBuffer_Reply>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_CreateBuffer_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_CreateBuffer_Reply),
            "::",
            stringify!(id)
        )
    );
}
pub type M_Cmd_CreateClient_Reply_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_CreateClient_Reply {
    pub flags: M_Cmd_CreateClient_Reply_flags,
    pub client: M_ClientID,
}
#[test]
fn bindgen_test_layout_M_Cmd_CreateClient_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_CreateClient_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_CreateClient_Reply>(),
        24usize,
        concat!("Size of: ", stringify!(M_Cmd_CreateClient_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_CreateClient_Reply>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_CreateClient_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_CreateClient_Reply),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).client) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_CreateClient_Reply),
            "::",
            stringify!(client)
        )
    );
}
impl Default for M_Cmd_CreateClient_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_CreateClient_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_CreateClient_Reply {{ flags: {:?}, client: {:?} }}",
            self.flags, self.client
        )
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_CreateSEEWorld_Reply {
    pub initstatus: M_Word,
    pub worldid: M_KeyID,
}
#[test]
fn bindgen_test_layout_M_Cmd_CreateSEEWorld_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_CreateSEEWorld_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_CreateSEEWorld_Reply>(),
        8usize,
        concat!("Size of: ", stringify!(M_Cmd_CreateSEEWorld_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_CreateSEEWorld_Reply>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_CreateSEEWorld_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).initstatus) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_CreateSEEWorld_Reply),
            "::",
            stringify!(initstatus)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).worldid) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_CreateSEEWorld_Reply),
            "::",
            stringify!(worldid)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_Decrypt_Reply {
    pub plain: M_PlainText,
}
#[test]
fn bindgen_test_layout_M_Cmd_Decrypt_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_Decrypt_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_Decrypt_Reply>(),
        72usize,
        concat!("Size of: ", stringify!(M_Cmd_Decrypt_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_Decrypt_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_Decrypt_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).plain) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_Decrypt_Reply),
            "::",
            stringify!(plain)
        )
    );
}
impl Default for M_Cmd_Decrypt_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_Decrypt_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Cmd_Decrypt_Reply {{ plain: {:?} }}", self.plain)
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_DeriveKey_Reply {
    pub key: M_KeyID,
}
#[test]
fn bindgen_test_layout_M_Cmd_DeriveKey_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_DeriveKey_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_DeriveKey_Reply>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_DeriveKey_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_DeriveKey_Reply>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_DeriveKey_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_DeriveKey_Reply),
            "::",
            stringify!(key)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_DevTest_Reply {
    pub info: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_Cmd_DevTest_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_DevTest_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_DevTest_Reply>(),
        16usize,
        concat!("Size of: ", stringify!(M_Cmd_DevTest_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_DevTest_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_DevTest_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_DevTest_Reply),
            "::",
            stringify!(info)
        )
    );
}
impl Default for M_Cmd_DevTest_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_Duplicate_Reply {
    pub newkey: M_KeyID,
}
#[test]
fn bindgen_test_layout_M_Cmd_Duplicate_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_Duplicate_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_Duplicate_Reply>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_Duplicate_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_Duplicate_Reply>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_Duplicate_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).newkey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_Duplicate_Reply),
            "::",
            stringify!(newkey)
        )
    );
}
pub type M_Cmd_DynamicSlotCreateAssociation_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_DynamicSlotCreateAssociation_Reply {
    pub flags: M_Cmd_DynamicSlotCreateAssociation_Reply_flags,
    pub slotassociation: M_SlotAssociationID,
}
#[test]
fn bindgen_test_layout_M_Cmd_DynamicSlotCreateAssociation_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_DynamicSlotCreateAssociation_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_DynamicSlotCreateAssociation_Reply>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(M_Cmd_DynamicSlotCreateAssociation_Reply)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_DynamicSlotCreateAssociation_Reply>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(M_Cmd_DynamicSlotCreateAssociation_Reply)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_DynamicSlotCreateAssociation_Reply),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).slotassociation) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_DynamicSlotCreateAssociation_Reply),
            "::",
            stringify!(slotassociation)
        )
    );
}
pub type M_Cmd_DynamicSlotExchangeAPDUs_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_DynamicSlotExchangeAPDUs_Reply {
    pub flags: M_Cmd_DynamicSlotExchangeAPDUs_Reply_flags,
    pub payload: *mut M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_Cmd_DynamicSlotExchangeAPDUs_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_DynamicSlotExchangeAPDUs_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_DynamicSlotExchangeAPDUs_Reply>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(M_Cmd_DynamicSlotExchangeAPDUs_Reply)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_DynamicSlotExchangeAPDUs_Reply>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(M_Cmd_DynamicSlotExchangeAPDUs_Reply)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_DynamicSlotExchangeAPDUs_Reply),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).payload) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_DynamicSlotExchangeAPDUs_Reply),
            "::",
            stringify!(payload)
        )
    );
}
impl Default for M_Cmd_DynamicSlotExchangeAPDUs_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_DynamicSlotsConfigureQuery_Reply {
    pub maxcardidle: M_Word,
    pub maxroundtrip: M_Word,
}
#[test]
fn bindgen_test_layout_M_Cmd_DynamicSlotsConfigureQuery_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_DynamicSlotsConfigureQuery_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_DynamicSlotsConfigureQuery_Reply>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(M_Cmd_DynamicSlotsConfigureQuery_Reply)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_DynamicSlotsConfigureQuery_Reply>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(M_Cmd_DynamicSlotsConfigureQuery_Reply)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).maxcardidle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_DynamicSlotsConfigureQuery_Reply),
            "::",
            stringify!(maxcardidle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).maxroundtrip) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_DynamicSlotsConfigureQuery_Reply),
            "::",
            stringify!(maxroundtrip)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_Encrypt_Reply {
    pub cipher: M_CipherText,
}
#[test]
fn bindgen_test_layout_M_Cmd_Encrypt_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_Encrypt_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_Encrypt_Reply>(),
        112usize,
        concat!("Size of: ", stringify!(M_Cmd_Encrypt_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_Encrypt_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_Encrypt_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cipher) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_Encrypt_Reply),
            "::",
            stringify!(cipher)
        )
    );
}
impl Default for M_Cmd_Encrypt_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_Encrypt_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Cmd_Encrypt_Reply {{ cipher: {:?} }}", self.cipher)
    }
}
pub type M_Cmd_EraseWorld_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_EraseWorld_Reply {
    pub flags: M_Cmd_EraseWorld_Reply_flags,
}
#[test]
fn bindgen_test_layout_M_Cmd_EraseWorld_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_EraseWorld_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_EraseWorld_Reply>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_EraseWorld_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_EraseWorld_Reply>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_EraseWorld_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_EraseWorld_Reply),
            "::",
            stringify!(flags)
        )
    );
}
pub type M_Cmd_ExistingClient_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_ExistingClient_Reply {
    pub flags: M_Cmd_ExistingClient_Reply_flags,
}
#[test]
fn bindgen_test_layout_M_Cmd_ExistingClient_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ExistingClient_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ExistingClient_Reply>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_ExistingClient_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ExistingClient_Reply>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_ExistingClient_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ExistingClient_Reply),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_Export_Reply {
    pub data: M_KeyData,
}
#[test]
fn bindgen_test_layout_M_Cmd_Export_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_Export_Reply> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_Export_Reply>(),
        128usize,
        concat!("Size of: ", stringify!(M_Cmd_Export_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_Export_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_Export_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_Export_Reply),
            "::",
            stringify!(data)
        )
    );
}
impl Default for M_Cmd_Export_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_Export_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Cmd_Export_Reply {{ data: {:?} }}", self.data)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_GetSlotList_Reply {
    pub n_slots: ::core::ffi::c_int,
    pub slots: M_vec_SlotListData,
}
#[test]
fn bindgen_test_layout_M_Cmd_GetSlotList_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GetSlotList_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GetSlotList_Reply>(),
        16usize,
        concat!("Size of: ", stringify!(M_Cmd_GetSlotList_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GetSlotList_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_GetSlotList_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_slots) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetSlotList_Reply),
            "::",
            stringify!(n_slots)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).slots) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetSlotList_Reply),
            "::",
            stringify!(slots)
        )
    );
}
impl Default for M_Cmd_GetSlotList_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_NewEnquiry_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_EnqVer_Five_Data {
    pub one: M_EnquiryDataOne,
    pub two: M_EnquiryDataTwo,
    pub three: M_EnquiryDataThree,
    pub four: M_EnquiryDataFour,
    pub five: M_EnquiryDataFive,
}
#[test]
fn bindgen_test_layout_M_EnqVer_Five_Data() {
    const UNINIT: ::core::mem::MaybeUninit<M_EnqVer_Five_Data> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_EnqVer_Five_Data>(),
        96usize,
        concat!("Size of: ", stringify!(M_EnqVer_Five_Data))
    );
    assert_eq!(
        ::core::mem::align_of::<M_EnqVer_Five_Data>(),
        8usize,
        concat!("Alignment of ", stringify!(M_EnqVer_Five_Data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).one) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnqVer_Five_Data),
            "::",
            stringify!(one)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).two) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnqVer_Five_Data),
            "::",
            stringify!(two)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).three) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnqVer_Five_Data),
            "::",
            stringify!(three)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).four) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnqVer_Five_Data),
            "::",
            stringify!(four)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).five) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnqVer_Five_Data),
            "::",
            stringify!(five)
        )
    );
}
impl Default for M_EnqVer_Five_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_EnqVer_Four_Data {
    pub one: M_EnquiryDataOne,
    pub two: M_EnquiryDataTwo,
    pub three: M_EnquiryDataThree,
    pub four: M_EnquiryDataFour,
}
#[test]
fn bindgen_test_layout_M_EnqVer_Four_Data() {
    const UNINIT: ::core::mem::MaybeUninit<M_EnqVer_Four_Data> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_EnqVer_Four_Data>(),
        72usize,
        concat!("Size of: ", stringify!(M_EnqVer_Four_Data))
    );
    assert_eq!(
        ::core::mem::align_of::<M_EnqVer_Four_Data>(),
        8usize,
        concat!("Alignment of ", stringify!(M_EnqVer_Four_Data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).one) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnqVer_Four_Data),
            "::",
            stringify!(one)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).two) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnqVer_Four_Data),
            "::",
            stringify!(two)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).three) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnqVer_Four_Data),
            "::",
            stringify!(three)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).four) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnqVer_Four_Data),
            "::",
            stringify!(four)
        )
    );
}
impl Default for M_EnqVer_Four_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_EnqVer_One_Data {
    pub one: M_EnquiryDataOne,
}
#[test]
fn bindgen_test_layout_M_EnqVer_One_Data() {
    const UNINIT: ::core::mem::MaybeUninit<M_EnqVer_One_Data> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_EnqVer_One_Data>(),
        56usize,
        concat!("Size of: ", stringify!(M_EnqVer_One_Data))
    );
    assert_eq!(
        ::core::mem::align_of::<M_EnqVer_One_Data>(),
        8usize,
        concat!("Alignment of ", stringify!(M_EnqVer_One_Data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).one) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnqVer_One_Data),
            "::",
            stringify!(one)
        )
    );
}
impl Default for M_EnqVer_One_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_EnqVer_Six_Data {
    pub one: M_EnquiryDataOne,
    pub two: M_EnquiryDataTwo,
    pub three: M_EnquiryDataThree,
    pub four: M_EnquiryDataFour,
    pub five: M_EnquiryDataFive,
    pub six: M_EnquiryDataSix,
}
#[test]
fn bindgen_test_layout_M_EnqVer_Six_Data() {
    const UNINIT: ::core::mem::MaybeUninit<M_EnqVer_Six_Data> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_EnqVer_Six_Data>(),
        216usize,
        concat!("Size of: ", stringify!(M_EnqVer_Six_Data))
    );
    assert_eq!(
        ::core::mem::align_of::<M_EnqVer_Six_Data>(),
        8usize,
        concat!("Alignment of ", stringify!(M_EnqVer_Six_Data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).one) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnqVer_Six_Data),
            "::",
            stringify!(one)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).two) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnqVer_Six_Data),
            "::",
            stringify!(two)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).three) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnqVer_Six_Data),
            "::",
            stringify!(three)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).four) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnqVer_Six_Data),
            "::",
            stringify!(four)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).five) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnqVer_Six_Data),
            "::",
            stringify!(five)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).six) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnqVer_Six_Data),
            "::",
            stringify!(six)
        )
    );
}
impl Default for M_EnqVer_Six_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_EnqVer_Three_Data {
    pub one: M_EnquiryDataOne,
    pub two: M_EnquiryDataTwo,
    pub three: M_EnquiryDataThree,
}
#[test]
fn bindgen_test_layout_M_EnqVer_Three_Data() {
    const UNINIT: ::core::mem::MaybeUninit<M_EnqVer_Three_Data> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_EnqVer_Three_Data>(),
        72usize,
        concat!("Size of: ", stringify!(M_EnqVer_Three_Data))
    );
    assert_eq!(
        ::core::mem::align_of::<M_EnqVer_Three_Data>(),
        8usize,
        concat!("Alignment of ", stringify!(M_EnqVer_Three_Data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).one) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnqVer_Three_Data),
            "::",
            stringify!(one)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).two) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnqVer_Three_Data),
            "::",
            stringify!(two)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).three) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnqVer_Three_Data),
            "::",
            stringify!(three)
        )
    );
}
impl Default for M_EnqVer_Three_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_EnqVer_Two_Data {
    pub one: M_EnquiryDataOne,
    pub two: M_EnquiryDataTwo,
}
#[test]
fn bindgen_test_layout_M_EnqVer_Two_Data() {
    const UNINIT: ::core::mem::MaybeUninit<M_EnqVer_Two_Data> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_EnqVer_Two_Data>(),
        64usize,
        concat!("Size of: ", stringify!(M_EnqVer_Two_Data))
    );
    assert_eq!(
        ::core::mem::align_of::<M_EnqVer_Two_Data>(),
        8usize,
        concat!("Alignment of ", stringify!(M_EnqVer_Two_Data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).one) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnqVer_Two_Data),
            "::",
            stringify!(one)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).two) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnqVer_Two_Data),
            "::",
            stringify!(two)
        )
    );
}
impl Default for M_EnqVer_Two_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_EnqVer__Data {
    pub five: M_EnqVer_Five_Data,
    pub four: M_EnqVer_Four_Data,
    pub one: M_EnqVer_One_Data,
    pub six: M_EnqVer_Six_Data,
    pub three: M_EnqVer_Three_Data,
    pub two: M_EnqVer_Two_Data,
}
#[test]
fn bindgen_test_layout_M_EnqVer__Data() {
    const UNINIT: ::core::mem::MaybeUninit<M_EnqVer__Data> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_EnqVer__Data>(),
        216usize,
        concat!("Size of: ", stringify!(M_EnqVer__Data))
    );
    assert_eq!(
        ::core::mem::align_of::<M_EnqVer__Data>(),
        8usize,
        concat!("Alignment of ", stringify!(M_EnqVer__Data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).five) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnqVer__Data),
            "::",
            stringify!(five)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).four) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnqVer__Data),
            "::",
            stringify!(four)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).one) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnqVer__Data),
            "::",
            stringify!(one)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).six) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnqVer__Data),
            "::",
            stringify!(six)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).three) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnqVer__Data),
            "::",
            stringify!(three)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).two) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_EnqVer__Data),
            "::",
            stringify!(two)
        )
    );
}
impl Default for M_EnqVer__Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_EnqVer__Data {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_EnqVer__Data {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_NewEnquiry_Reply {
    pub flags: M_Cmd_NewEnquiry_Reply_flags,
    pub module: M_ModuleID,
    pub version: M_EnqVer,
    pub data: M_EnqVer__Data,
}
#[test]
fn bindgen_test_layout_M_Cmd_NewEnquiry_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_NewEnquiry_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_NewEnquiry_Reply>(),
        232usize,
        concat!("Size of: ", stringify!(M_Cmd_NewEnquiry_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_NewEnquiry_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_NewEnquiry_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_NewEnquiry_Reply),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_NewEnquiry_Reply),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_NewEnquiry_Reply),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_NewEnquiry_Reply),
            "::",
            stringify!(data)
        )
    );
}
impl Default for M_Cmd_NewEnquiry_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_NewEnquiry_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_NewEnquiry_Reply {{ flags: {:?}, module: {:?}, version: {:?}, data: {:?} }}",
            self.flags, self.module, self.version, self.data
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_ExportModule_Reply {
    pub getslotlist: M_Cmd_GetSlotList_Reply,
    pub newenquiry: M_Cmd_NewEnquiry_Reply,
}
#[test]
fn bindgen_test_layout_M_Cmd_ExportModule_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ExportModule_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ExportModule_Reply>(),
        248usize,
        concat!("Size of: ", stringify!(M_Cmd_ExportModule_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ExportModule_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_ExportModule_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getslotlist) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ExportModule_Reply),
            "::",
            stringify!(getslotlist)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).newenquiry) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ExportModule_Reply),
            "::",
            stringify!(newenquiry)
        )
    );
}
impl Default for M_Cmd_ExportModule_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_ExportModule_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_ExportModule_Reply {{ getslotlist: {:?}, newenquiry: {:?} }}",
            self.getslotlist, self.newenquiry
        )
    }
}
pub type M_SlotListData_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_SlotListData {
    pub type_: M_SlotType,
    pub flags: M_SlotListData_flags,
    pub token: M_PhysToken,
    pub exdata: M_SlotType__SlotExData,
}
#[test]
fn bindgen_test_layout_M_SlotListData() {
    const UNINIT: ::core::mem::MaybeUninit<M_SlotListData> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_SlotListData>(),
        56usize,
        concat!("Size of: ", stringify!(M_SlotListData))
    );
    assert_eq!(
        ::core::mem::align_of::<M_SlotListData>(),
        8usize,
        concat!("Alignment of ", stringify!(M_SlotListData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_SlotListData),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_SlotListData),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).token) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_SlotListData),
            "::",
            stringify!(token)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).exdata) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_SlotListData),
            "::",
            stringify!(exdata)
        )
    );
}
impl Default for M_SlotListData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_SlotListData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_SlotListData {{ type: {:?}, flags: {:?}, token: {:?}, exdata: {:?} }}",
            self.type_, self.flags, self.token, self.exdata
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_PollSlotData {
    pub changeevents: M_Word,
    pub sld: M_SlotListData,
}
#[test]
fn bindgen_test_layout_M_PollSlotData() {
    const UNINIT: ::core::mem::MaybeUninit<M_PollSlotData> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_PollSlotData>(),
        64usize,
        concat!("Size of: ", stringify!(M_PollSlotData))
    );
    assert_eq!(
        ::core::mem::align_of::<M_PollSlotData>(),
        8usize,
        concat!("Alignment of ", stringify!(M_PollSlotData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).changeevents) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_PollSlotData),
            "::",
            stringify!(changeevents)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sld) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_PollSlotData),
            "::",
            stringify!(sld)
        )
    );
}
impl Default for M_PollSlotData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_PollSlotData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_PollSlotData {{ changeevents: {:?}, sld: {:?} }}",
            self.changeevents, self.sld
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_ExportSlot_Reply {
    pub psd: M_PollSlotData,
}
#[test]
fn bindgen_test_layout_M_Cmd_ExportSlot_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ExportSlot_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ExportSlot_Reply>(),
        64usize,
        concat!("Size of: ", stringify!(M_Cmd_ExportSlot_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ExportSlot_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_ExportSlot_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).psd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ExportSlot_Reply),
            "::",
            stringify!(psd)
        )
    );
}
impl Default for M_Cmd_ExportSlot_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_ExportSlot_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Cmd_ExportSlot_Reply {{ psd: {:?} }}", self.psd)
    }
}
pub type M_Cmd_FTChecksum_Reply_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_FTChecksum_Reply {
    pub checksum: M_CipherText,
    pub flags: M_Cmd_FTChecksum_Reply_flags,
}
#[test]
fn bindgen_test_layout_M_Cmd_FTChecksum_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_FTChecksum_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_FTChecksum_Reply>(),
        120usize,
        concat!("Size of: ", stringify!(M_Cmd_FTChecksum_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_FTChecksum_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_FTChecksum_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).checksum) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FTChecksum_Reply),
            "::",
            stringify!(checksum)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FTChecksum_Reply),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for M_Cmd_FTChecksum_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_FTChecksum_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_FTChecksum_Reply {{ checksum: {:?}, flags: {:?} }}",
            self.checksum, self.flags
        )
    }
}
pub type M_Cmd_FTDelete_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_FTDelete_Reply {
    pub flags: M_Cmd_FTDelete_Reply_flags,
}
#[test]
fn bindgen_test_layout_M_Cmd_FTDelete_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_FTDelete_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_FTDelete_Reply>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_FTDelete_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_FTDelete_Reply>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_FTDelete_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FTDelete_Reply),
            "::",
            stringify!(flags)
        )
    );
}
pub type M_vec_HostFileDesc = *mut M_HostFileDesc;
pub type M_Cmd_FTListDir_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_FTListDir_Reply {
    pub n_files: ::core::ffi::c_int,
    pub files: M_vec_HostFileDesc,
    pub flags: M_Cmd_FTListDir_Reply_flags,
}
#[test]
fn bindgen_test_layout_M_Cmd_FTListDir_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_FTListDir_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_FTListDir_Reply>(),
        24usize,
        concat!("Size of: ", stringify!(M_Cmd_FTListDir_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_FTListDir_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_FTListDir_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_files) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FTListDir_Reply),
            "::",
            stringify!(n_files)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).files) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FTListDir_Reply),
            "::",
            stringify!(files)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FTListDir_Reply),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for M_Cmd_FTListDir_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_FTRead_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_FTRead_Reply {
    pub chunk: M_ByteBlock,
    pub flags: M_Cmd_FTRead_Reply_flags,
}
#[test]
fn bindgen_test_layout_M_Cmd_FTRead_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_FTRead_Reply> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_FTRead_Reply>(),
        24usize,
        concat!("Size of: ", stringify!(M_Cmd_FTRead_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_FTRead_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_FTRead_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chunk) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FTRead_Reply),
            "::",
            stringify!(chunk)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FTRead_Reply),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for M_Cmd_FTRead_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_FTSessionOpen_Reply {
    pub id: M_FTSessionID,
}
#[test]
fn bindgen_test_layout_M_Cmd_FTSessionOpen_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_FTSessionOpen_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_FTSessionOpen_Reply>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_FTSessionOpen_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_FTSessionOpen_Reply>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_FTSessionOpen_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FTSessionOpen_Reply),
            "::",
            stringify!(id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_FTStartListDir_Reply {
    pub id: M_FileTransferID,
    pub ftlistdir: M_Cmd_FTListDir_Reply,
}
#[test]
fn bindgen_test_layout_M_Cmd_FTStartListDir_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_FTStartListDir_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_FTStartListDir_Reply>(),
        32usize,
        concat!("Size of: ", stringify!(M_Cmd_FTStartListDir_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_FTStartListDir_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_FTStartListDir_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FTStartListDir_Reply),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ftlistdir) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FTStartListDir_Reply),
            "::",
            stringify!(ftlistdir)
        )
    );
}
impl Default for M_Cmd_FTStartListDir_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_HostFileDesc {
    pub name: M_FileName,
    pub size: M_Word,
    pub flags: M_HostFileFlags,
}
#[test]
fn bindgen_test_layout_M_HostFileDesc() {
    const UNINIT: ::core::mem::MaybeUninit<M_HostFileDesc> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_HostFileDesc>(),
        16usize,
        concat!("Size of: ", stringify!(M_HostFileDesc))
    );
    assert_eq!(
        ::core::mem::align_of::<M_HostFileDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(M_HostFileDesc))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_HostFileDesc),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_HostFileDesc),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(M_HostFileDesc),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for M_HostFileDesc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_FTStartRead_Reply {
    pub id: M_FileTransferID,
    pub desc: M_HostFileDesc,
    pub ftread: M_Cmd_FTRead_Reply,
}
#[test]
fn bindgen_test_layout_M_Cmd_FTStartRead_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_FTStartRead_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_FTStartRead_Reply>(),
        48usize,
        concat!("Size of: ", stringify!(M_Cmd_FTStartRead_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_FTStartRead_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_FTStartRead_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FTStartRead_Reply),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).desc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FTStartRead_Reply),
            "::",
            stringify!(desc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ftread) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FTStartRead_Reply),
            "::",
            stringify!(ftread)
        )
    );
}
impl Default for M_Cmd_FTStartRead_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_FTStartWrite_Reply {
    pub id: M_FileTransferID,
}
#[test]
fn bindgen_test_layout_M_Cmd_FTStartWrite_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_FTStartWrite_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_FTStartWrite_Reply>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_FTStartWrite_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_FTStartWrite_Reply>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_FTStartWrite_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FTStartWrite_Reply),
            "::",
            stringify!(id)
        )
    );
}
pub type M_Cmd_FTStat_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_FTStat_Reply {
    pub flags: M_Cmd_FTStat_Reply_flags,
    pub desc: M_HostFileDesc,
}
#[test]
fn bindgen_test_layout_M_Cmd_FTStat_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_FTStat_Reply> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_FTStat_Reply>(),
        24usize,
        concat!("Size of: ", stringify!(M_Cmd_FTStat_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_FTStat_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_FTStat_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FTStat_Reply),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).desc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FTStat_Reply),
            "::",
            stringify!(desc)
        )
    );
}
impl Default for M_Cmd_FTStat_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_FailDriver_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_FailDriver_Reply {
    pub flags: M_Cmd_FailDriver_Reply_flags,
}
#[test]
fn bindgen_test_layout_M_Cmd_FailDriver_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_FailDriver_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_FailDriver_Reply>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_FailDriver_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_FailDriver_Reply>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_FailDriver_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FailDriver_Reply),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_FastSEEJob_Reply {
    pub seereply: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_Cmd_FastSEEJob_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_FastSEEJob_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_FastSEEJob_Reply>(),
        16usize,
        concat!("Size of: ", stringify!(M_Cmd_FastSEEJob_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_FastSEEJob_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_FastSEEJob_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).seereply) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FastSEEJob_Reply),
            "::",
            stringify!(seereply)
        )
    );
}
impl Default for M_Cmd_FastSEEJob_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_NVMemOpType_GetACL_OpRes {
    pub acl: M_ACL,
}
#[test]
fn bindgen_test_layout_M_NVMemOpType_GetACL_OpRes() {
    const UNINIT: ::core::mem::MaybeUninit<M_NVMemOpType_GetACL_OpRes> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_NVMemOpType_GetACL_OpRes>(),
        16usize,
        concat!("Size of: ", stringify!(M_NVMemOpType_GetACL_OpRes))
    );
    assert_eq!(
        ::core::mem::align_of::<M_NVMemOpType_GetACL_OpRes>(),
        8usize,
        concat!("Alignment of ", stringify!(M_NVMemOpType_GetACL_OpRes))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).acl) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_NVMemOpType_GetACL_OpRes),
            "::",
            stringify!(acl)
        )
    );
}
impl Default for M_NVMemOpType_GetACL_OpRes {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_NVMemOpType_Read_OpRes {
    pub data: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_NVMemOpType_Read_OpRes() {
    const UNINIT: ::core::mem::MaybeUninit<M_NVMemOpType_Read_OpRes> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_NVMemOpType_Read_OpRes>(),
        16usize,
        concat!("Size of: ", stringify!(M_NVMemOpType_Read_OpRes))
    );
    assert_eq!(
        ::core::mem::align_of::<M_NVMemOpType_Read_OpRes>(),
        8usize,
        concat!("Alignment of ", stringify!(M_NVMemOpType_Read_OpRes))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_NVMemOpType_Read_OpRes),
            "::",
            stringify!(data)
        )
    );
}
impl Default for M_NVMemOpType_Read_OpRes {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_NVMemOpType__OpRes {
    pub getacl: M_NVMemOpType_GetACL_OpRes,
    pub read: M_NVMemOpType_Read_OpRes,
}
#[test]
fn bindgen_test_layout_M_NVMemOpType__OpRes() {
    const UNINIT: ::core::mem::MaybeUninit<M_NVMemOpType__OpRes> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_NVMemOpType__OpRes>(),
        16usize,
        concat!("Size of: ", stringify!(M_NVMemOpType__OpRes))
    );
    assert_eq!(
        ::core::mem::align_of::<M_NVMemOpType__OpRes>(),
        8usize,
        concat!("Alignment of ", stringify!(M_NVMemOpType__OpRes))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getacl) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_NVMemOpType__OpRes),
            "::",
            stringify!(getacl)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_NVMemOpType__OpRes),
            "::",
            stringify!(read)
        )
    );
}
impl Default for M_NVMemOpType__OpRes {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_NVMemOpType__OpRes {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_NVMemOpType__OpRes {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_FileOp_Reply {
    pub op: M_NVMemOpType,
    pub res: M_NVMemOpType__OpRes,
}
#[test]
fn bindgen_test_layout_M_Cmd_FileOp_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_FileOp_Reply> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_FileOp_Reply>(),
        24usize,
        concat!("Size of: ", stringify!(M_Cmd_FileOp_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_FileOp_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_FileOp_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).op) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FileOp_Reply),
            "::",
            stringify!(op)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).res) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FileOp_Reply),
            "::",
            stringify!(res)
        )
    );
}
impl Default for M_Cmd_FileOp_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_FileOp_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_FileOp_Reply {{ op: {:?}, res: {:?} }}",
            self.op, self.res
        )
    }
}
pub type M_Cmd_FirmwareAuthenticate_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_FwAuthType_NFFHMAC1_Resp {
    pub mac: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_FwAuthType_NFFHMAC1_Resp() {
    const UNINIT: ::core::mem::MaybeUninit<M_FwAuthType_NFFHMAC1_Resp> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_FwAuthType_NFFHMAC1_Resp>(),
        16usize,
        concat!("Size of: ", stringify!(M_FwAuthType_NFFHMAC1_Resp))
    );
    assert_eq!(
        ::core::mem::align_of::<M_FwAuthType_NFFHMAC1_Resp>(),
        8usize,
        concat!("Alignment of ", stringify!(M_FwAuthType_NFFHMAC1_Resp))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mac) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_FwAuthType_NFFHMAC1_Resp),
            "::",
            stringify!(mac)
        )
    );
}
impl Default for M_FwAuthType_NFFHMAC1_Resp {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_FwAuthType_PRNG1_Resp {
    pub data: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_FwAuthType_PRNG1_Resp() {
    const UNINIT: ::core::mem::MaybeUninit<M_FwAuthType_PRNG1_Resp> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_FwAuthType_PRNG1_Resp>(),
        16usize,
        concat!("Size of: ", stringify!(M_FwAuthType_PRNG1_Resp))
    );
    assert_eq!(
        ::core::mem::align_of::<M_FwAuthType_PRNG1_Resp>(),
        8usize,
        concat!("Alignment of ", stringify!(M_FwAuthType_PRNG1_Resp))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_FwAuthType_PRNG1_Resp),
            "::",
            stringify!(data)
        )
    );
}
impl Default for M_FwAuthType_PRNG1_Resp {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_FwAuthType__Resp {
    pub nffhmac1: M_FwAuthType_NFFHMAC1_Resp,
    pub prng1: M_FwAuthType_PRNG1_Resp,
}
#[test]
fn bindgen_test_layout_M_FwAuthType__Resp() {
    const UNINIT: ::core::mem::MaybeUninit<M_FwAuthType__Resp> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_FwAuthType__Resp>(),
        16usize,
        concat!("Size of: ", stringify!(M_FwAuthType__Resp))
    );
    assert_eq!(
        ::core::mem::align_of::<M_FwAuthType__Resp>(),
        8usize,
        concat!("Alignment of ", stringify!(M_FwAuthType__Resp))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nffhmac1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_FwAuthType__Resp),
            "::",
            stringify!(nffhmac1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prng1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_FwAuthType__Resp),
            "::",
            stringify!(prng1)
        )
    );
}
impl Default for M_FwAuthType__Resp {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_FwAuthType__Resp {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_FwAuthType__Resp {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_FirmwareAuthenticate_Reply {
    pub flags: M_Cmd_FirmwareAuthenticate_Reply_flags,
    pub type_: M_FwAuthType,
    pub response: M_FwAuthType__Resp,
}
#[test]
fn bindgen_test_layout_M_Cmd_FirmwareAuthenticate_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_FirmwareAuthenticate_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_FirmwareAuthenticate_Reply>(),
        24usize,
        concat!("Size of: ", stringify!(M_Cmd_FirmwareAuthenticate_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_FirmwareAuthenticate_Reply>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(M_Cmd_FirmwareAuthenticate_Reply)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FirmwareAuthenticate_Reply),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FirmwareAuthenticate_Reply),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).response) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_FirmwareAuthenticate_Reply),
            "::",
            stringify!(response)
        )
    );
}
impl Default for M_Cmd_FirmwareAuthenticate_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_FirmwareAuthenticate_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_FirmwareAuthenticate_Reply {{ flags: {:?}, type: {:?}, response: {:?} }}",
            self.flags, self.type_, self.response
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_PhysTokenType_ISO7816_Reply {
    pub dataout: M_ByteBlock,
    pub sw1sw2: M_Word,
}
#[test]
fn bindgen_test_layout_M_PhysTokenType_ISO7816_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_PhysTokenType_ISO7816_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_PhysTokenType_ISO7816_Reply>(),
        24usize,
        concat!("Size of: ", stringify!(M_PhysTokenType_ISO7816_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_PhysTokenType_ISO7816_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_PhysTokenType_ISO7816_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dataout) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_PhysTokenType_ISO7816_Reply),
            "::",
            stringify!(dataout)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sw1sw2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_PhysTokenType_ISO7816_Reply),
            "::",
            stringify!(sw1sw2)
        )
    );
}
impl Default for M_PhysTokenType_ISO7816_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_PhysTokenType__Reply {
    pub iso7816: M_PhysTokenType_ISO7816_Reply,
}
#[test]
fn bindgen_test_layout_M_PhysTokenType__Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_PhysTokenType__Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_PhysTokenType__Reply>(),
        24usize,
        concat!("Size of: ", stringify!(M_PhysTokenType__Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_PhysTokenType__Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_PhysTokenType__Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iso7816) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_PhysTokenType__Reply),
            "::",
            stringify!(iso7816)
        )
    );
}
impl Default for M_PhysTokenType__Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_PhysTokenType__Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_PhysTokenType__Reply {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_ForeignTokenCmd_Reply {
    pub type_: M_PhysTokenType,
    pub reply: M_PhysTokenType__Reply,
}
#[test]
fn bindgen_test_layout_M_Cmd_ForeignTokenCmd_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ForeignTokenCmd_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ForeignTokenCmd_Reply>(),
        32usize,
        concat!("Size of: ", stringify!(M_Cmd_ForeignTokenCmd_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ForeignTokenCmd_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_ForeignTokenCmd_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ForeignTokenCmd_Reply),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reply) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ForeignTokenCmd_Reply),
            "::",
            stringify!(reply)
        )
    );
}
impl Default for M_Cmd_ForeignTokenCmd_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_ForeignTokenCmd_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_ForeignTokenCmd_Reply {{ type: {:?}, reply: {:?} }}",
            self.type_, self.reply
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_PhysTokenType_ISO7816_Info {
    pub atr: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_PhysTokenType_ISO7816_Info() {
    const UNINIT: ::core::mem::MaybeUninit<M_PhysTokenType_ISO7816_Info> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_PhysTokenType_ISO7816_Info>(),
        16usize,
        concat!("Size of: ", stringify!(M_PhysTokenType_ISO7816_Info))
    );
    assert_eq!(
        ::core::mem::align_of::<M_PhysTokenType_ISO7816_Info>(),
        8usize,
        concat!("Alignment of ", stringify!(M_PhysTokenType_ISO7816_Info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).atr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_PhysTokenType_ISO7816_Info),
            "::",
            stringify!(atr)
        )
    );
}
impl Default for M_PhysTokenType_ISO7816_Info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_PhysTokenType__Info {
    pub iso7816: M_PhysTokenType_ISO7816_Info,
}
#[test]
fn bindgen_test_layout_M_PhysTokenType__Info() {
    const UNINIT: ::core::mem::MaybeUninit<M_PhysTokenType__Info> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_PhysTokenType__Info>(),
        16usize,
        concat!("Size of: ", stringify!(M_PhysTokenType__Info))
    );
    assert_eq!(
        ::core::mem::align_of::<M_PhysTokenType__Info>(),
        8usize,
        concat!("Alignment of ", stringify!(M_PhysTokenType__Info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iso7816) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_PhysTokenType__Info),
            "::",
            stringify!(iso7816)
        )
    );
}
impl Default for M_PhysTokenType__Info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_PhysTokenType__Info {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_PhysTokenType__Info {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_ForeignTokenOpen_Reply {
    pub lock: M_KeyID,
    pub type_: M_PhysTokenType,
    pub info: M_PhysTokenType__Info,
}
#[test]
fn bindgen_test_layout_M_Cmd_ForeignTokenOpen_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ForeignTokenOpen_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ForeignTokenOpen_Reply>(),
        24usize,
        concat!("Size of: ", stringify!(M_Cmd_ForeignTokenOpen_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ForeignTokenOpen_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_ForeignTokenOpen_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ForeignTokenOpen_Reply),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ForeignTokenOpen_Reply),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ForeignTokenOpen_Reply),
            "::",
            stringify!(info)
        )
    );
}
impl Default for M_Cmd_ForeignTokenOpen_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_ForeignTokenOpen_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_ForeignTokenOpen_Reply {{ lock: {:?}, type: {:?}, info: {:?} }}",
            self.lock, self.type_, self.info
        )
    }
}
pub type M_Cmd_GenerateKey_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_GenerateKey_Reply {
    pub flags: M_Cmd_GenerateKey_Reply_flags,
    pub key: M_KeyID,
    pub cert: *mut M_ModuleCert,
}
#[test]
fn bindgen_test_layout_M_Cmd_GenerateKey_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GenerateKey_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GenerateKey_Reply>(),
        16usize,
        concat!("Size of: ", stringify!(M_Cmd_GenerateKey_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GenerateKey_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_GenerateKey_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GenerateKey_Reply),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GenerateKey_Reply),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cert) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GenerateKey_Reply),
            "::",
            stringify!(cert)
        )
    );
}
impl Default for M_Cmd_GenerateKey_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_GenerateKeyPair_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_GenerateKeyPair_Reply {
    pub flags: M_Cmd_GenerateKeyPair_Reply_flags,
    pub keypriv: M_KeyID,
    pub keypub: M_KeyID,
    pub certpriv: *mut M_ModuleCert,
    pub certpub: *mut M_ModuleCert,
}
#[test]
fn bindgen_test_layout_M_Cmd_GenerateKeyPair_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GenerateKeyPair_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GenerateKeyPair_Reply>(),
        32usize,
        concat!("Size of: ", stringify!(M_Cmd_GenerateKeyPair_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GenerateKeyPair_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_GenerateKeyPair_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GenerateKeyPair_Reply),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).keypriv) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GenerateKeyPair_Reply),
            "::",
            stringify!(keypriv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).keypub) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GenerateKeyPair_Reply),
            "::",
            stringify!(keypub)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).certpriv) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GenerateKeyPair_Reply),
            "::",
            stringify!(certpriv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).certpub) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GenerateKeyPair_Reply),
            "::",
            stringify!(certpub)
        )
    );
}
impl Default for M_Cmd_GenerateKeyPair_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_GenerateLogicalToken_Reply {
    pub idkt: M_KeyID,
    pub hkt: M_TokenHash,
}
#[test]
fn bindgen_test_layout_M_Cmd_GenerateLogicalToken_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GenerateLogicalToken_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GenerateLogicalToken_Reply>(),
        24usize,
        concat!("Size of: ", stringify!(M_Cmd_GenerateLogicalToken_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GenerateLogicalToken_Reply>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(M_Cmd_GenerateLogicalToken_Reply)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).idkt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GenerateLogicalToken_Reply),
            "::",
            stringify!(idkt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hkt) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GenerateLogicalToken_Reply),
            "::",
            stringify!(hkt)
        )
    );
}
impl Default for M_Cmd_GenerateLogicalToken_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_GenerateLogicalToken_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_GenerateLogicalToken_Reply {{ idkt: {:?}, hkt: {:?} }}",
            self.idkt, self.hkt
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_GeneratePrime_Reply {
    pub r: M_Bignum,
}
#[test]
fn bindgen_test_layout_M_Cmd_GeneratePrime_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GeneratePrime_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GeneratePrime_Reply>(),
        8usize,
        concat!("Size of: ", stringify!(M_Cmd_GeneratePrime_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GeneratePrime_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_GeneratePrime_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).r) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GeneratePrime_Reply),
            "::",
            stringify!(r)
        )
    );
}
impl Default for M_Cmd_GeneratePrime_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_GenerateRandom_Reply {
    pub data: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_Cmd_GenerateRandom_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GenerateRandom_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GenerateRandom_Reply>(),
        16usize,
        concat!("Size of: ", stringify!(M_Cmd_GenerateRandom_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GenerateRandom_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_GenerateRandom_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GenerateRandom_Reply),
            "::",
            stringify!(data)
        )
    );
}
impl Default for M_Cmd_GenerateRandom_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_nest_ACL = M_ACL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_GetACL_Reply {
    pub acl: M_nest_ACL,
}
#[test]
fn bindgen_test_layout_M_Cmd_GetACL_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GetACL_Reply> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GetACL_Reply>(),
        16usize,
        concat!("Size of: ", stringify!(M_Cmd_GetACL_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GetACL_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_GetACL_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).acl) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetACL_Reply),
            "::",
            stringify!(acl)
        )
    );
}
impl Default for M_Cmd_GetACL_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_GetAppData_Reply {
    pub appdata: M_AppData,
}
#[test]
fn bindgen_test_layout_M_Cmd_GetAppData_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GetAppData_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GetAppData_Reply>(),
        64usize,
        concat!("Size of: ", stringify!(M_Cmd_GetAppData_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GetAppData_Reply>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_GetAppData_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).appdata) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetAppData_Reply),
            "::",
            stringify!(appdata)
        )
    );
}
impl Default for M_Cmd_GetAppData_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_GetAppData_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_GetAppData_Reply {{ appdata: {:?} }}",
            self.appdata
        )
    }
}
pub type M_Cmd_GetApplianceTime_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_GetApplianceTime_Reply {
    pub time: M_RTCTime,
    pub flags: M_Cmd_GetApplianceTime_Reply_flags,
}
#[test]
fn bindgen_test_layout_M_Cmd_GetApplianceTime_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GetApplianceTime_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GetApplianceTime_Reply>(),
        20usize,
        concat!("Size of: ", stringify!(M_Cmd_GetApplianceTime_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GetApplianceTime_Reply>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_GetApplianceTime_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetApplianceTime_Reply),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetApplianceTime_Reply),
            "::",
            stringify!(flags)
        )
    );
}
pub type M_Cmd_GetApplianceUpgradeStatus_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_GetApplianceUpgradeStatus_Reply {
    pub error: M_Status,
    pub stage: M_UpgradeState,
    pub flags: M_Cmd_GetApplianceUpgradeStatus_Reply_flags,
}
#[test]
fn bindgen_test_layout_M_Cmd_GetApplianceUpgradeStatus_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GetApplianceUpgradeStatus_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GetApplianceUpgradeStatus_Reply>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(M_Cmd_GetApplianceUpgradeStatus_Reply)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GetApplianceUpgradeStatus_Reply>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(M_Cmd_GetApplianceUpgradeStatus_Reply)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).error) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetApplianceUpgradeStatus_Reply),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stage) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetApplianceUpgradeStatus_Reply),
            "::",
            stringify!(stage)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetApplianceUpgradeStatus_Reply),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for M_Cmd_GetApplianceUpgradeStatus_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_GetApplianceVersion_Reply {
    pub version: M_ASCIIString,
}
#[test]
fn bindgen_test_layout_M_Cmd_GetApplianceVersion_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GetApplianceVersion_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GetApplianceVersion_Reply>(),
        8usize,
        concat!("Size of: ", stringify!(M_Cmd_GetApplianceVersion_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GetApplianceVersion_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_GetApplianceVersion_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetApplianceVersion_Reply),
            "::",
            stringify!(version)
        )
    );
}
impl Default for M_Cmd_GetApplianceVersion_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_GetChallenge_Reply {
    pub nonce: M_Nonce,
}
#[test]
fn bindgen_test_layout_M_Cmd_GetChallenge_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GetChallenge_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GetChallenge_Reply>(),
        20usize,
        concat!("Size of: ", stringify!(M_Cmd_GetChallenge_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GetChallenge_Reply>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_GetChallenge_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nonce) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetChallenge_Reply),
            "::",
            stringify!(nonce)
        )
    );
}
impl Default for M_Cmd_GetChallenge_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_GetChallenge_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Cmd_GetChallenge_Reply {{ nonce: {:?} }}", self.nonce)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_GetClientHash_Reply {
    pub hclientid: M_Hash,
}
#[test]
fn bindgen_test_layout_M_Cmd_GetClientHash_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GetClientHash_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GetClientHash_Reply>(),
        20usize,
        concat!("Size of: ", stringify!(M_Cmd_GetClientHash_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GetClientHash_Reply>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_GetClientHash_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hclientid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetClientHash_Reply),
            "::",
            stringify!(hclientid)
        )
    );
}
impl Default for M_Cmd_GetClientHash_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_GetClientHash_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_GetClientHash_Reply {{ hclientid: {:?} }}",
            self.hclientid
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_GetHardwareError_Reply {
    pub report: M_ASCIIString,
}
#[test]
fn bindgen_test_layout_M_Cmd_GetHardwareError_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GetHardwareError_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GetHardwareError_Reply>(),
        8usize,
        concat!("Size of: ", stringify!(M_Cmd_GetHardwareError_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GetHardwareError_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_GetHardwareError_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).report) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetHardwareError_Reply),
            "::",
            stringify!(report)
        )
    );
}
impl Default for M_Cmd_GetHardwareError_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_GetKLF_Reply {
    pub idka: M_KeyID,
}
#[test]
fn bindgen_test_layout_M_Cmd_GetKLF_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GetKLF_Reply> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GetKLF_Reply>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_GetKLF_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GetKLF_Reply>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_GetKLF_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).idka) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetKLF_Reply),
            "::",
            stringify!(idka)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_GetKLF2_Reply {
    pub idka: M_KeyID,
}
#[test]
fn bindgen_test_layout_M_Cmd_GetKLF2_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GetKLF2_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GetKLF2_Reply>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_GetKLF2_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GetKLF2_Reply>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_GetKLF2_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).idka) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetKLF2_Reply),
            "::",
            stringify!(idka)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_GetKML_Reply {
    pub idka: M_KeyID,
}
#[test]
fn bindgen_test_layout_M_Cmd_GetKML_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GetKML_Reply> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GetKML_Reply>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_GetKML_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GetKML_Reply>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_GetKML_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).idka) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetKML_Reply),
            "::",
            stringify!(idka)
        )
    );
}
pub type M_Cmd_GetKMList_Reply_flags = M_Word;
pub type M_vec_KMHash = *mut M_KMHash;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_GetKMList_Reply {
    pub flags: M_Cmd_GetKMList_Reply_flags,
    pub hknso: M_KeyHash,
    pub n_hkms: ::core::ffi::c_int,
    pub hkms: M_vec_KMHash,
}
#[test]
fn bindgen_test_layout_M_Cmd_GetKMList_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GetKMList_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GetKMList_Reply>(),
        40usize,
        concat!("Size of: ", stringify!(M_Cmd_GetKMList_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GetKMList_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_GetKMList_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetKMList_Reply),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hknso) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetKMList_Reply),
            "::",
            stringify!(hknso)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_hkms) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetKMList_Reply),
            "::",
            stringify!(n_hkms)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hkms) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetKMList_Reply),
            "::",
            stringify!(hkms)
        )
    );
}
impl Default for M_Cmd_GetKMList_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_GetKMList_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_GetKMList_Reply {{ flags: {:?}, hknso: {:?}, n_hkms: {:?}, hkms: {:?} }}",
            self.flags, self.hknso, self.n_hkms, self.hkms
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_GetKeyInfo_Reply {
    pub type_: M_KeyType,
    pub hash: M_KeyHash,
}
#[test]
fn bindgen_test_layout_M_Cmd_GetKeyInfo_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GetKeyInfo_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GetKeyInfo_Reply>(),
        24usize,
        concat!("Size of: ", stringify!(M_Cmd_GetKeyInfo_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GetKeyInfo_Reply>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_GetKeyInfo_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetKeyInfo_Reply),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hash) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetKeyInfo_Reply),
            "::",
            stringify!(hash)
        )
    );
}
impl Default for M_Cmd_GetKeyInfo_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_GetKeyInfo_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_GetKeyInfo_Reply {{ type: {:?}, hash: {:?} }}",
            self.type_, self.hash
        )
    }
}
pub type M_Cmd_GetKeyInfoEx_Reply_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_GetKeyInfoEx_Reply {
    pub ver: M_Word,
    pub flags: M_Cmd_GetKeyInfoEx_Reply_flags,
    pub type_: M_KeyType,
    pub length: M_Word,
    pub hash: M_KeyHash,
    pub hashex: M_KeyHashEx,
}
#[test]
fn bindgen_test_layout_M_Cmd_GetKeyInfoEx_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GetKeyInfoEx_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GetKeyInfoEx_Reply>(),
        104usize,
        concat!("Size of: ", stringify!(M_Cmd_GetKeyInfoEx_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GetKeyInfoEx_Reply>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_GetKeyInfoEx_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ver) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetKeyInfoEx_Reply),
            "::",
            stringify!(ver)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetKeyInfoEx_Reply),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetKeyInfoEx_Reply),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetKeyInfoEx_Reply),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hash) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetKeyInfoEx_Reply),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hashex) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetKeyInfoEx_Reply),
            "::",
            stringify!(hashex)
        )
    );
}
impl Default for M_Cmd_GetKeyInfoEx_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_GetKeyInfoEx_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_Cmd_GetKeyInfoEx_Reply {{ ver: {:?}, flags: {:?}, type: {:?}, length: {:?}, hash: {:?}, hashex: {:?} }}" , self . ver , self . flags , self . type_ , self . length , self . hash , self . hashex)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_GetKnetiPub_Reply {
    pub kneti: M_KeyData,
}
#[test]
fn bindgen_test_layout_M_Cmd_GetKnetiPub_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GetKnetiPub_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GetKnetiPub_Reply>(),
        128usize,
        concat!("Size of: ", stringify!(M_Cmd_GetKnetiPub_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GetKnetiPub_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_GetKnetiPub_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kneti) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetKnetiPub_Reply),
            "::",
            stringify!(kneti)
        )
    );
}
impl Default for M_Cmd_GetKnetiPub_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_GetKnetiPub_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Cmd_GetKnetiPub_Reply {{ kneti: {:?} }}", self.kneti)
    }
}
pub type M_vec_LogTokenShareInfo = *mut M_LogTokenShareInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_GetLogicalTokenInfo_Reply {
    pub state: M_LogTokenState,
    pub hkt: M_TokenHash,
    pub n_shares: ::core::ffi::c_int,
    pub shares: M_vec_LogTokenShareInfo,
    pub sharesneeded: M_Word,
}
#[test]
fn bindgen_test_layout_M_Cmd_GetLogicalTokenInfo_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GetLogicalTokenInfo_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GetLogicalTokenInfo_Reply>(),
        48usize,
        concat!("Size of: ", stringify!(M_Cmd_GetLogicalTokenInfo_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GetLogicalTokenInfo_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_GetLogicalTokenInfo_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetLogicalTokenInfo_Reply),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hkt) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetLogicalTokenInfo_Reply),
            "::",
            stringify!(hkt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_shares) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetLogicalTokenInfo_Reply),
            "::",
            stringify!(n_shares)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).shares) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetLogicalTokenInfo_Reply),
            "::",
            stringify!(shares)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sharesneeded) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetLogicalTokenInfo_Reply),
            "::",
            stringify!(sharesneeded)
        )
    );
}
impl Default for M_Cmd_GetLogicalTokenInfo_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_GetLogicalTokenInfo_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_Cmd_GetLogicalTokenInfo_Reply {{ state: {:?}, hkt: {:?}, n_shares: {:?}, shares: {:?}, sharesneeded: {:?} }}" , self . state , self . hkt , self . n_shares , self . shares , self . sharesneeded)
    }
}
pub type M_Cmd_GetLogicalTokenInfoEx_Reply_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_GetLogicalTokenInfoEx_Reply {
    pub ver: M_Word,
    pub flags: M_Cmd_GetLogicalTokenInfoEx_Reply_flags,
    pub state: M_LogTokenState,
    pub hkt: M_TokenHash,
    pub hkm: M_KMHash,
    pub n_shares: ::core::ffi::c_int,
    pub shares: M_vec_LogTokenShareInfo,
    pub sharesneeded: M_Word,
    pub age: M_Word,
    pub timelimit: M_Word,
}
#[test]
fn bindgen_test_layout_M_Cmd_GetLogicalTokenInfoEx_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GetLogicalTokenInfoEx_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GetLogicalTokenInfoEx_Reply>(),
        80usize,
        concat!("Size of: ", stringify!(M_Cmd_GetLogicalTokenInfoEx_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GetLogicalTokenInfoEx_Reply>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(M_Cmd_GetLogicalTokenInfoEx_Reply)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ver) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetLogicalTokenInfoEx_Reply),
            "::",
            stringify!(ver)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetLogicalTokenInfoEx_Reply),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetLogicalTokenInfoEx_Reply),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hkt) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetLogicalTokenInfoEx_Reply),
            "::",
            stringify!(hkt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hkm) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetLogicalTokenInfoEx_Reply),
            "::",
            stringify!(hkm)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_shares) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetLogicalTokenInfoEx_Reply),
            "::",
            stringify!(n_shares)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).shares) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetLogicalTokenInfoEx_Reply),
            "::",
            stringify!(shares)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sharesneeded) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetLogicalTokenInfoEx_Reply),
            "::",
            stringify!(sharesneeded)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).age) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetLogicalTokenInfoEx_Reply),
            "::",
            stringify!(age)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timelimit) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetLogicalTokenInfoEx_Reply),
            "::",
            stringify!(timelimit)
        )
    );
}
impl Default for M_Cmd_GetLogicalTokenInfoEx_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_GetLogicalTokenInfoEx_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_Cmd_GetLogicalTokenInfoEx_Reply {{ ver: {:?}, flags: {:?}, state: {:?}, hkt: {:?}, hkm: {:?}, n_shares: {:?}, shares: {:?}, sharesneeded: {:?}, age: {:?}, timelimit: {:?} }}" , self . ver , self . flags , self . state , self . hkt , self . hkm , self . n_shares , self . shares , self . sharesneeded , self . age , self . timelimit)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_GetModuleState_Reply {
    pub state: M_ModuleAttribList,
}
#[test]
fn bindgen_test_layout_M_Cmd_GetModuleState_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GetModuleState_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GetModuleState_Reply>(),
        16usize,
        concat!("Size of: ", stringify!(M_Cmd_GetModuleState_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GetModuleState_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_GetModuleState_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetModuleState_Reply),
            "::",
            stringify!(state)
        )
    );
}
impl Default for M_Cmd_GetModuleState_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_GetMonitorLoaderState_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_GetMonitorLoaderState_Reply {
    pub state: M_MonitorLoaderState,
    pub flags: M_Cmd_GetMonitorLoaderState_Reply_flags,
}
#[test]
fn bindgen_test_layout_M_Cmd_GetMonitorLoaderState_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GetMonitorLoaderState_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GetMonitorLoaderState_Reply>(),
        8usize,
        concat!("Size of: ", stringify!(M_Cmd_GetMonitorLoaderState_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GetMonitorLoaderState_Reply>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(M_Cmd_GetMonitorLoaderState_Reply)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetMonitorLoaderState_Reply),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetMonitorLoaderState_Reply),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for M_Cmd_GetMonitorLoaderState_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_GetPoolInfo_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_GetPoolInfo_Reply {
    pub flags: M_Cmd_GetPoolInfo_Reply_flags,
    pub info: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_Cmd_GetPoolInfo_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GetPoolInfo_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GetPoolInfo_Reply>(),
        24usize,
        concat!("Size of: ", stringify!(M_Cmd_GetPoolInfo_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GetPoolInfo_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_GetPoolInfo_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetPoolInfo_Reply),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetPoolInfo_Reply),
            "::",
            stringify!(info)
        )
    );
}
impl Default for M_Cmd_GetPoolInfo_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_GetPublishedObject_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_GetPublishedObject_Reply {
    pub flags: M_Cmd_GetPublishedObject_Reply_flags,
    pub object: *mut M_KeyID,
    pub data: *mut M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_Cmd_GetPublishedObject_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GetPublishedObject_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GetPublishedObject_Reply>(),
        24usize,
        concat!("Size of: ", stringify!(M_Cmd_GetPublishedObject_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GetPublishedObject_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_GetPublishedObject_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetPublishedObject_Reply),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).object) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetPublishedObject_Reply),
            "::",
            stringify!(object)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetPublishedObject_Reply),
            "::",
            stringify!(data)
        )
    );
}
impl Default for M_Cmd_GetPublishedObject_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_GetRTC_Reply {
    pub time: M_RTCTime,
}
#[test]
fn bindgen_test_layout_M_Cmd_GetRTC_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GetRTC_Reply> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GetRTC_Reply>(),
        16usize,
        concat!("Size of: ", stringify!(M_Cmd_GetRTC_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GetRTC_Reply>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_GetRTC_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetRTC_Reply),
            "::",
            stringify!(time)
        )
    );
}
pub type M_Cmd_GetServerConfig_Reply_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_GetServerConfig_Reply {
    pub flags: M_Cmd_GetServerConfig_Reply_flags,
    pub v: M_Word,
    pub maxnumclients: M_Word,
    pub addr: M_NetworkAddress,
    pub addr_ipv6: M_NetworkAddress,
}
#[test]
fn bindgen_test_layout_M_Cmd_GetServerConfig_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GetServerConfig_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GetServerConfig_Reply>(),
        80usize,
        concat!("Size of: ", stringify!(M_Cmd_GetServerConfig_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GetServerConfig_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_GetServerConfig_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetServerConfig_Reply),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).v) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetServerConfig_Reply),
            "::",
            stringify!(v)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).maxnumclients) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetServerConfig_Reply),
            "::",
            stringify!(maxnumclients)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).addr) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetServerConfig_Reply),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).addr_ipv6) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetServerConfig_Reply),
            "::",
            stringify!(addr_ipv6)
        )
    );
}
impl Default for M_Cmd_GetServerConfig_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_GetServerConfig_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_Cmd_GetServerConfig_Reply {{ flags: {:?}, v: {:?}, maxnumclients: {:?}, addr: {:?}, addr_ipv6: {:?} }}" , self . flags , self . v , self . maxnumclients , self . addr , self . addr_ipv6)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_GetShareACL_Reply {
    pub acl: M_ACL,
}
#[test]
fn bindgen_test_layout_M_Cmd_GetShareACL_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GetShareACL_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GetShareACL_Reply>(),
        16usize,
        concat!("Size of: ", stringify!(M_Cmd_GetShareACL_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GetShareACL_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_GetShareACL_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).acl) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetShareACL_Reply),
            "::",
            stringify!(acl)
        )
    );
}
impl Default for M_Cmd_GetShareACL_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_GetSlotInfo_Reply_flags = M_Word;
pub type M_vec_TokenInfo = *mut M_TokenInfo;
pub type M_vec_FileInfo = *mut M_FileInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_TokenUniqueID {
    pub bytes: [::core::ffi::c_uchar; 8usize],
    pub words: [M_Word; 2usize],
}
#[test]
fn bindgen_test_layout_M_TokenUniqueID() {
    const UNINIT: ::core::mem::MaybeUninit<M_TokenUniqueID> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_TokenUniqueID>(),
        8usize,
        concat!("Size of: ", stringify!(M_TokenUniqueID))
    );
    assert_eq!(
        ::core::mem::align_of::<M_TokenUniqueID>(),
        4usize,
        concat!("Alignment of ", stringify!(M_TokenUniqueID))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_TokenUniqueID),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).words) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_TokenUniqueID),
            "::",
            stringify!(words)
        )
    );
}
impl Default for M_TokenUniqueID {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_TokenUniqueID {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_TokenUniqueID {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_GetSlotInfo_Reply {
    pub ic: M_Word,
    pub flags: M_Cmd_GetSlotInfo_Reply_flags,
    pub n_tokens: ::core::ffi::c_int,
    pub tokens: M_vec_TokenInfo,
    pub n_files: ::core::ffi::c_int,
    pub files: M_vec_FileInfo,
    pub freespace: M_Word,
    pub auth_key: M_KMHash,
    pub tokenserial: *mut M_TokenUniqueID,
}
#[test]
fn bindgen_test_layout_M_Cmd_GetSlotInfo_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GetSlotInfo_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GetSlotInfo_Reply>(),
        72usize,
        concat!("Size of: ", stringify!(M_Cmd_GetSlotInfo_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GetSlotInfo_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_GetSlotInfo_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetSlotInfo_Reply),
            "::",
            stringify!(ic)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetSlotInfo_Reply),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_tokens) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetSlotInfo_Reply),
            "::",
            stringify!(n_tokens)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tokens) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetSlotInfo_Reply),
            "::",
            stringify!(tokens)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_files) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetSlotInfo_Reply),
            "::",
            stringify!(n_files)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).files) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetSlotInfo_Reply),
            "::",
            stringify!(files)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).freespace) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetSlotInfo_Reply),
            "::",
            stringify!(freespace)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).auth_key) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetSlotInfo_Reply),
            "::",
            stringify!(auth_key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tokenserial) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetSlotInfo_Reply),
            "::",
            stringify!(tokenserial)
        )
    );
}
impl Default for M_Cmd_GetSlotInfo_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_GetSlotInfo_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_Cmd_GetSlotInfo_Reply {{ ic: {:?}, flags: {:?}, n_tokens: {:?}, tokens: {:?}, n_files: {:?}, files: {:?}, freespace: {:?}, auth_key: {:?}, tokenserial: {:?} }}" , self . ic , self . flags , self . n_tokens , self . tokens , self . n_files , self . files , self . freespace , self . auth_key , self . tokenserial)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_GetTicket_Reply {
    pub ticket: M_nest_Ticket,
}
#[test]
fn bindgen_test_layout_M_Cmd_GetTicket_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GetTicket_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GetTicket_Reply>(),
        16usize,
        concat!("Size of: ", stringify!(M_Cmd_GetTicket_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GetTicket_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_GetTicket_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ticket) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetTicket_Reply),
            "::",
            stringify!(ticket)
        )
    );
}
impl Default for M_Cmd_GetTicket_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_GetWhichModule_Reply {
    pub n_module: ::core::ffi::c_int,
    pub module: M_vec_ModuleID,
}
#[test]
fn bindgen_test_layout_M_Cmd_GetWhichModule_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GetWhichModule_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GetWhichModule_Reply>(),
        16usize,
        concat!("Size of: ", stringify!(M_Cmd_GetWhichModule_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GetWhichModule_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_GetWhichModule_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_module) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetWhichModule_Reply),
            "::",
            stringify!(n_module)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetWhichModule_Reply),
            "::",
            stringify!(module)
        )
    );
}
impl Default for M_Cmd_GetWhichModule_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_GetWorldSigners_Reply {
    pub n_sigs: ::core::ffi::c_int,
    pub sigs: M_vec_KeyHashAndMech,
}
#[test]
fn bindgen_test_layout_M_Cmd_GetWorldSigners_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_GetWorldSigners_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_GetWorldSigners_Reply>(),
        16usize,
        concat!("Size of: ", stringify!(M_Cmd_GetWorldSigners_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_GetWorldSigners_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_GetWorldSigners_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_sigs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetWorldSigners_Reply),
            "::",
            stringify!(n_sigs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sigs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_GetWorldSigners_Reply),
            "::",
            stringify!(sigs)
        )
    );
}
impl Default for M_Cmd_GetWorldSigners_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_Hash_Reply {
    pub sig: M_CipherText,
}
#[test]
fn bindgen_test_layout_M_Cmd_Hash_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_Hash_Reply> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_Hash_Reply>(),
        112usize,
        concat!("Size of: ", stringify!(M_Cmd_Hash_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_Hash_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_Hash_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_Hash_Reply),
            "::",
            stringify!(sig)
        )
    );
}
impl Default for M_Cmd_Hash_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_Hash_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Cmd_Hash_Reply {{ sig: {:?} }}", self.sig)
    }
}
pub type M_Cmd_IOBoardReprogram_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_IOBoardReprogram_Reply {
    pub flags: M_Cmd_IOBoardReprogram_Reply_flags,
}
#[test]
fn bindgen_test_layout_M_Cmd_IOBoardReprogram_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_IOBoardReprogram_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_IOBoardReprogram_Reply>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_IOBoardReprogram_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_IOBoardReprogram_Reply>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_IOBoardReprogram_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_IOBoardReprogram_Reply),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_ImpathInfo {
    pub v: M_Word,
    pub state: M_ImpathState,
    pub rm: M_RemoteModule,
}
#[test]
fn bindgen_test_layout_M_ImpathInfo() {
    const UNINIT: ::core::mem::MaybeUninit<M_ImpathInfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_ImpathInfo>(),
        72usize,
        concat!("Size of: ", stringify!(M_ImpathInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<M_ImpathInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(M_ImpathInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).v) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ImpathInfo),
            "::",
            stringify!(v)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ImpathInfo),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rm) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ImpathInfo),
            "::",
            stringify!(rm)
        )
    );
}
impl Default for M_ImpathInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ImpathGetInfo_Reply {
    pub info: M_ImpathInfo,
}
#[test]
fn bindgen_test_layout_M_Cmd_ImpathGetInfo_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ImpathGetInfo_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ImpathGetInfo_Reply>(),
        72usize,
        concat!("Size of: ", stringify!(M_Cmd_ImpathGetInfo_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ImpathGetInfo_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_ImpathGetInfo_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ImpathGetInfo_Reply),
            "::",
            stringify!(info)
        )
    );
}
impl Default for M_Cmd_ImpathGetInfo_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ImpathKXBegin_Reply {
    pub imp: M_ImpathID,
    pub kx: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_Cmd_ImpathKXBegin_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ImpathKXBegin_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ImpathKXBegin_Reply>(),
        24usize,
        concat!("Size of: ", stringify!(M_Cmd_ImpathKXBegin_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ImpathKXBegin_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_ImpathKXBegin_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).imp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ImpathKXBegin_Reply),
            "::",
            stringify!(imp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kx) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ImpathKXBegin_Reply),
            "::",
            stringify!(kx)
        )
    );
}
impl Default for M_Cmd_ImpathKXBegin_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ImpathReceive_Reply {
    pub data: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_Cmd_ImpathReceive_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ImpathReceive_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ImpathReceive_Reply>(),
        16usize,
        concat!("Size of: ", stringify!(M_Cmd_ImpathReceive_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ImpathReceive_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_ImpathReceive_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ImpathReceive_Reply),
            "::",
            stringify!(data)
        )
    );
}
impl Default for M_Cmd_ImpathReceive_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ImpathSend_Reply {
    pub cipher: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_Cmd_ImpathSend_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ImpathSend_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ImpathSend_Reply>(),
        16usize,
        concat!("Size of: ", stringify!(M_Cmd_ImpathSend_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ImpathSend_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_ImpathSend_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cipher) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ImpathSend_Reply),
            "::",
            stringify!(cipher)
        )
    );
}
impl Default for M_Cmd_ImpathSend_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_Import_Reply {
    pub key: M_KeyID,
}
#[test]
fn bindgen_test_layout_M_Cmd_Import_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_Import_Reply> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_Import_Reply>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_Import_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_Import_Reply>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_Import_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_Import_Reply),
            "::",
            stringify!(key)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_ImportSlot_Reply {
    pub slot: M_SlotID,
}
#[test]
fn bindgen_test_layout_M_Cmd_ImportSlot_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ImportSlot_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ImportSlot_Reply>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_ImportSlot_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ImportSlot_Reply>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_ImportSlot_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).slot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ImportSlot_Reply),
            "::",
            stringify!(slot)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_InsertSoftToken_Reply {
    pub ic: M_Word,
}
#[test]
fn bindgen_test_layout_M_Cmd_InsertSoftToken_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_InsertSoftToken_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_InsertSoftToken_Reply>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_InsertSoftToken_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_InsertSoftToken_Reply>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_InsertSoftToken_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_InsertSoftToken_Reply),
            "::",
            stringify!(ic)
        )
    );
}
pub type M_vec_RemoteServerPermission = *mut M_RemoteServerPermission;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ListRemoteServerPermission_Reply {
    pub n_permission: ::core::ffi::c_int,
    pub permission: M_vec_RemoteServerPermission,
}
#[test]
fn bindgen_test_layout_M_Cmd_ListRemoteServerPermission_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ListRemoteServerPermission_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ListRemoteServerPermission_Reply>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(M_Cmd_ListRemoteServerPermission_Reply)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ListRemoteServerPermission_Reply>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(M_Cmd_ListRemoteServerPermission_Reply)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_permission) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ListRemoteServerPermission_Reply),
            "::",
            stringify!(n_permission)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).permission) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ListRemoteServerPermission_Reply),
            "::",
            stringify!(permission)
        )
    );
}
impl Default for M_Cmd_ListRemoteServerPermission_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_ListRemoteServerPermissionEx_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ListRemoteServerPermissionEx_Reply {
    pub flags: M_Cmd_ListRemoteServerPermissionEx_Reply_flags,
    pub remaining: M_Word,
    pub n_permission: ::core::ffi::c_int,
    pub permission: M_vec_RemoteServerPermission,
}
#[test]
fn bindgen_test_layout_M_Cmd_ListRemoteServerPermissionEx_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ListRemoteServerPermissionEx_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ListRemoteServerPermissionEx_Reply>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(M_Cmd_ListRemoteServerPermissionEx_Reply)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ListRemoteServerPermissionEx_Reply>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(M_Cmd_ListRemoteServerPermissionEx_Reply)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ListRemoteServerPermissionEx_Reply),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).remaining) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ListRemoteServerPermissionEx_Reply),
            "::",
            stringify!(remaining)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_permission) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ListRemoteServerPermissionEx_Reply),
            "::",
            stringify!(n_permission)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).permission) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ListRemoteServerPermissionEx_Reply),
            "::",
            stringify!(permission)
        )
    );
}
impl Default for M_Cmd_ListRemoteServerPermissionEx_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_LoadBlob_Reply {
    pub idka: M_KeyID,
}
#[test]
fn bindgen_test_layout_M_Cmd_LoadBlob_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_LoadBlob_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_LoadBlob_Reply>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_LoadBlob_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_LoadBlob_Reply>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_LoadBlob_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).idka) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_LoadBlob_Reply),
            "::",
            stringify!(idka)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_LoadLogicalToken_Reply {
    pub idkt: M_KeyID,
}
#[test]
fn bindgen_test_layout_M_Cmd_LoadLogicalToken_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_LoadLogicalToken_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_LoadLogicalToken_Reply>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_LoadLogicalToken_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_LoadLogicalToken_Reply>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_LoadLogicalToken_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).idkt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_LoadLogicalToken_Reply),
            "::",
            stringify!(idkt)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_MakeBlob_Reply {
    pub blob: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_Cmd_MakeBlob_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_MakeBlob_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_MakeBlob_Reply>(),
        16usize,
        concat!("Size of: ", stringify!(M_Cmd_MakeBlob_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_MakeBlob_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_MakeBlob_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).blob) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_MakeBlob_Reply),
            "::",
            stringify!(blob)
        )
    );
}
impl Default for M_Cmd_MakeBlob_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_MergeKeyIDs_Reply {
    pub newkey: M_KeyID,
}
#[test]
fn bindgen_test_layout_M_Cmd_MergeKeyIDs_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_MergeKeyIDs_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_MergeKeyIDs_Reply>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_MergeKeyIDs_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_MergeKeyIDs_Reply>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_MergeKeyIDs_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).newkey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_MergeKeyIDs_Reply),
            "::",
            stringify!(newkey)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ModExp_Reply {
    pub r: M_Bignum,
}
#[test]
fn bindgen_test_layout_M_Cmd_ModExp_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ModExp_Reply> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ModExp_Reply>(),
        8usize,
        concat!("Size of: ", stringify!(M_Cmd_ModExp_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ModExp_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_ModExp_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).r) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ModExp_Reply),
            "::",
            stringify!(r)
        )
    );
}
impl Default for M_Cmd_ModExp_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_InfoFormat_HardwareRev1_Info_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_InfoFormat_HardwareRev1_Info {
    pub flags: M_InfoFormat_HardwareRev1_Info_flags,
    pub base_code: M_Word,
    pub io_code: M_Word,
    pub scsi_id: M_Word,
    pub links: M_Word,
    pub n_cpus: M_Word,
    pub ram_size: M_Word,
}
#[test]
fn bindgen_test_layout_M_InfoFormat_HardwareRev1_Info() {
    const UNINIT: ::core::mem::MaybeUninit<M_InfoFormat_HardwareRev1_Info> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_InfoFormat_HardwareRev1_Info>(),
        28usize,
        concat!("Size of: ", stringify!(M_InfoFormat_HardwareRev1_Info))
    );
    assert_eq!(
        ::core::mem::align_of::<M_InfoFormat_HardwareRev1_Info>(),
        4usize,
        concat!("Alignment of ", stringify!(M_InfoFormat_HardwareRev1_Info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_InfoFormat_HardwareRev1_Info),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base_code) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_InfoFormat_HardwareRev1_Info),
            "::",
            stringify!(base_code)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).io_code) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_InfoFormat_HardwareRev1_Info),
            "::",
            stringify!(io_code)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).scsi_id) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(M_InfoFormat_HardwareRev1_Info),
            "::",
            stringify!(scsi_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).links) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_InfoFormat_HardwareRev1_Info),
            "::",
            stringify!(links)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_cpus) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(M_InfoFormat_HardwareRev1_Info),
            "::",
            stringify!(n_cpus)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ram_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_InfoFormat_HardwareRev1_Info),
            "::",
            stringify!(ram_size)
        )
    );
}
pub type M_vec_DeviceID = *mut M_DeviceID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_InfoFormat_HardwareRev2_Info {
    pub n_devices: ::core::ffi::c_int,
    pub devices: M_vec_DeviceID,
}
#[test]
fn bindgen_test_layout_M_InfoFormat_HardwareRev2_Info() {
    const UNINIT: ::core::mem::MaybeUninit<M_InfoFormat_HardwareRev2_Info> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_InfoFormat_HardwareRev2_Info>(),
        16usize,
        concat!("Size of: ", stringify!(M_InfoFormat_HardwareRev2_Info))
    );
    assert_eq!(
        ::core::mem::align_of::<M_InfoFormat_HardwareRev2_Info>(),
        8usize,
        concat!("Alignment of ", stringify!(M_InfoFormat_HardwareRev2_Info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_devices) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_InfoFormat_HardwareRev2_Info),
            "::",
            stringify!(n_devices)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).devices) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_InfoFormat_HardwareRev2_Info),
            "::",
            stringify!(devices)
        )
    );
}
impl Default for M_InfoFormat_HardwareRev2_Info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_InfoFormat__Info {
    pub hardwarerev1: M_InfoFormat_HardwareRev1_Info,
    pub hardwarerev2: M_InfoFormat_HardwareRev2_Info,
}
#[test]
fn bindgen_test_layout_M_InfoFormat__Info() {
    const UNINIT: ::core::mem::MaybeUninit<M_InfoFormat__Info> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_InfoFormat__Info>(),
        32usize,
        concat!("Size of: ", stringify!(M_InfoFormat__Info))
    );
    assert_eq!(
        ::core::mem::align_of::<M_InfoFormat__Info>(),
        8usize,
        concat!("Alignment of ", stringify!(M_InfoFormat__Info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hardwarerev1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_InfoFormat__Info),
            "::",
            stringify!(hardwarerev1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hardwarerev2) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_InfoFormat__Info),
            "::",
            stringify!(hardwarerev2)
        )
    );
}
impl Default for M_InfoFormat__Info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_InfoFormat__Info {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_InfoFormat__Info {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_ModuleInfo_Reply {
    pub format: M_InfoFormat,
    pub info: M_InfoFormat__Info,
}
#[test]
fn bindgen_test_layout_M_Cmd_ModuleInfo_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ModuleInfo_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ModuleInfo_Reply>(),
        40usize,
        concat!("Size of: ", stringify!(M_Cmd_ModuleInfo_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ModuleInfo_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_ModuleInfo_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ModuleInfo_Reply),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ModuleInfo_Reply),
            "::",
            stringify!(info)
        )
    );
}
impl Default for M_Cmd_ModuleInfo_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_ModuleInfo_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_ModuleInfo_Reply {{ format: {:?}, info: {:?} }}",
            self.format, self.info
        )
    }
}
pub type M_Cmd_NVMemList_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_NVMemList_Reply {
    pub flags: M_Cmd_NVMemList_Reply_flags,
    pub n_infos: ::core::ffi::c_int,
    pub infos: M_vec_FileInfo,
}
#[test]
fn bindgen_test_layout_M_Cmd_NVMemList_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_NVMemList_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_NVMemList_Reply>(),
        16usize,
        concat!("Size of: ", stringify!(M_Cmd_NVMemList_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_NVMemList_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_NVMemList_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_NVMemList_Reply),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_infos) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_NVMemList_Reply),
            "::",
            stringify!(n_infos)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).infos) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_NVMemList_Reply),
            "::",
            stringify!(infos)
        )
    );
}
impl Default for M_Cmd_NVMemList_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_NVMemOp_Reply {
    pub op: M_NVMemOpType,
    pub res: M_NVMemOpType__OpRes,
}
#[test]
fn bindgen_test_layout_M_Cmd_NVMemOp_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_NVMemOp_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_NVMemOp_Reply>(),
        24usize,
        concat!("Size of: ", stringify!(M_Cmd_NVMemOp_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_NVMemOp_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_NVMemOp_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).op) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_NVMemOp_Reply),
            "::",
            stringify!(op)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).res) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_NVMemOp_Reply),
            "::",
            stringify!(res)
        )
    );
}
impl Default for M_Cmd_NVMemOp_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_NVMemOp_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_NVMemOp_Reply {{ op: {:?}, res: {:?} }}",
            self.op, self.res
        )
    }
}
pub type M_Cmd_NewClient_Reply_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_NewClient_Reply {
    pub flags: M_Cmd_NewClient_Reply_flags,
    pub client: M_ClientID,
}
#[test]
fn bindgen_test_layout_M_Cmd_NewClient_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_NewClient_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_NewClient_Reply>(),
        24usize,
        concat!("Size of: ", stringify!(M_Cmd_NewClient_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_NewClient_Reply>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_NewClient_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_NewClient_Reply),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).client) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_NewClient_Reply),
            "::",
            stringify!(client)
        )
    );
}
impl Default for M_Cmd_NewClient_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_NewClient_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_NewClient_Reply {{ flags: {:?}, client: {:?} }}",
            self.flags, self.client
        )
    }
}
pub type M_Cmd_PauseForNotifications_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_PauseForNotifications_Reply {
    pub flags: M_Cmd_PauseForNotifications_Reply_flags,
}
#[test]
fn bindgen_test_layout_M_Cmd_PauseForNotifications_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_PauseForNotifications_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_PauseForNotifications_Reply>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_PauseForNotifications_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_PauseForNotifications_Reply>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(M_Cmd_PauseForNotifications_Reply)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_PauseForNotifications_Reply),
            "::",
            stringify!(flags)
        )
    );
}
pub type M_Cmd_PollModuleState_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_PollModuleState_Reply {
    pub version: M_Word,
    pub flags: M_Cmd_PollModuleState_Reply_flags,
    pub stateevents: M_Word,
    pub nvmemevents: M_Word,
    pub rtcadjusts: M_Word,
}
#[test]
fn bindgen_test_layout_M_Cmd_PollModuleState_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_PollModuleState_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_PollModuleState_Reply>(),
        20usize,
        concat!("Size of: ", stringify!(M_Cmd_PollModuleState_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_PollModuleState_Reply>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_PollModuleState_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_PollModuleState_Reply),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_PollModuleState_Reply),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stateevents) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_PollModuleState_Reply),
            "::",
            stringify!(stateevents)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nvmemevents) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_PollModuleState_Reply),
            "::",
            stringify!(nvmemevents)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rtcadjusts) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_PollModuleState_Reply),
            "::",
            stringify!(rtcadjusts)
        )
    );
}
pub type M_Cmd_PollSlotList_Reply_flags = M_Word;
pub type M_vec_PollSlotData = *mut M_PollSlotData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_PollSlotList_Reply {
    pub flags: M_Cmd_PollSlotList_Reply_flags,
    pub n_slots: ::core::ffi::c_int,
    pub slots: M_vec_PollSlotData,
}
#[test]
fn bindgen_test_layout_M_Cmd_PollSlotList_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_PollSlotList_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_PollSlotList_Reply>(),
        16usize,
        concat!("Size of: ", stringify!(M_Cmd_PollSlotList_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_PollSlotList_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_PollSlotList_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_PollSlotList_Reply),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_slots) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_PollSlotList_Reply),
            "::",
            stringify!(n_slots)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).slots) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_PollSlotList_Reply),
            "::",
            stringify!(slots)
        )
    );
}
impl Default for M_Cmd_PollSlotList_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_ProductionSetup_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_ProductionSetup_Reply {
    pub flags: M_Cmd_ProductionSetup_Reply_flags,
}
#[test]
fn bindgen_test_layout_M_Cmd_ProductionSetup_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ProductionSetup_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ProductionSetup_Reply>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_ProductionSetup_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ProductionSetup_Reply>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_ProductionSetup_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ProductionSetup_Reply),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_ProgrammingBeginChunk_Reply {
    pub maxblocksize: M_Word,
}
#[test]
fn bindgen_test_layout_M_Cmd_ProgrammingBeginChunk_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ProgrammingBeginChunk_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ProgrammingBeginChunk_Reply>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_ProgrammingBeginChunk_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ProgrammingBeginChunk_Reply>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(M_Cmd_ProgrammingBeginChunk_Reply)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).maxblocksize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ProgrammingBeginChunk_Reply),
            "::",
            stringify!(maxblocksize)
        )
    );
}
pub type M_Cmd_ProgrammingEndChunk_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_ProgrammingEndChunk_Reply {
    pub flags: M_Cmd_ProgrammingEndChunk_Reply_flags,
}
#[test]
fn bindgen_test_layout_M_Cmd_ProgrammingEndChunk_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ProgrammingEndChunk_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ProgrammingEndChunk_Reply>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_ProgrammingEndChunk_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ProgrammingEndChunk_Reply>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_ProgrammingEndChunk_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ProgrammingEndChunk_Reply),
            "::",
            stringify!(flags)
        )
    );
}
pub type M_vec_ProgrammingKeyListEntry = *mut M_ProgrammingKeyListEntry;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ProgrammingGetKeyList_Reply {
    pub vsn: M_Word,
    pub n_kfcs: ::core::ffi::c_int,
    pub kfcs: M_vec_ProgrammingKeyListEntry,
    pub n_kfis: ::core::ffi::c_int,
    pub kfis: M_vec_ProgrammingKeyListEntry,
}
#[test]
fn bindgen_test_layout_M_Cmd_ProgrammingGetKeyList_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ProgrammingGetKeyList_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ProgrammingGetKeyList_Reply>(),
        32usize,
        concat!("Size of: ", stringify!(M_Cmd_ProgrammingGetKeyList_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ProgrammingGetKeyList_Reply>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(M_Cmd_ProgrammingGetKeyList_Reply)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vsn) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ProgrammingGetKeyList_Reply),
            "::",
            stringify!(vsn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_kfcs) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ProgrammingGetKeyList_Reply),
            "::",
            stringify!(n_kfcs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kfcs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ProgrammingGetKeyList_Reply),
            "::",
            stringify!(kfcs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_kfis) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ProgrammingGetKeyList_Reply),
            "::",
            stringify!(n_kfis)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kfis) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ProgrammingGetKeyList_Reply),
            "::",
            stringify!(kfis)
        )
    );
}
impl Default for M_Cmd_ProgrammingGetKeyList_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_QueryLongJobs_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_QueryLongJobs_Reply {
    pub flags: M_Cmd_QueryLongJobs_Reply_flags,
    pub n_tags: ::core::ffi::c_int,
    pub tags: M_vec_Word,
}
#[test]
fn bindgen_test_layout_M_Cmd_QueryLongJobs_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_QueryLongJobs_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_QueryLongJobs_Reply>(),
        16usize,
        concat!("Size of: ", stringify!(M_Cmd_QueryLongJobs_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_QueryLongJobs_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_QueryLongJobs_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_QueryLongJobs_Reply),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_tags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_QueryLongJobs_Reply),
            "::",
            stringify!(n_tags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_QueryLongJobs_Reply),
            "::",
            stringify!(tags)
        )
    );
}
impl Default for M_Cmd_QueryLongJobs_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_RSAImmedSignDecrypt_Reply {
    pub r: M_Bignum,
}
#[test]
fn bindgen_test_layout_M_Cmd_RSAImmedSignDecrypt_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_RSAImmedSignDecrypt_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_RSAImmedSignDecrypt_Reply>(),
        8usize,
        concat!("Size of: ", stringify!(M_Cmd_RSAImmedSignDecrypt_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_RSAImmedSignDecrypt_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_RSAImmedSignDecrypt_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).r) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_RSAImmedSignDecrypt_Reply),
            "::",
            stringify!(r)
        )
    );
}
impl Default for M_Cmd_RSAImmedSignDecrypt_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_ReReadConfig_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_ReReadConfig_Reply {
    pub flags: M_Cmd_ReReadConfig_Reply_flags,
}
#[test]
fn bindgen_test_layout_M_Cmd_ReReadConfig_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ReReadConfig_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ReReadConfig_Reply>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_ReReadConfig_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ReReadConfig_Reply>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_ReReadConfig_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ReReadConfig_Reply),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ReadFile_Reply {
    pub data: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_Cmd_ReadFile_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ReadFile_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ReadFile_Reply>(),
        16usize,
        concat!("Size of: ", stringify!(M_Cmd_ReadFile_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ReadFile_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_ReadFile_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ReadFile_Reply),
            "::",
            stringify!(data)
        )
    );
}
impl Default for M_Cmd_ReadFile_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_ReadShare_Reply {
    pub sharesleft: M_Word,
}
#[test]
fn bindgen_test_layout_M_Cmd_ReadShare_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ReadShare_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ReadShare_Reply>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_ReadShare_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ReadShare_Reply>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_ReadShare_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sharesleft) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ReadShare_Reply),
            "::",
            stringify!(sharesleft)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_ReadSoftTokenShare_Reply {
    pub sharesleft: M_Word,
}
#[test]
fn bindgen_test_layout_M_Cmd_ReadSoftTokenShare_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ReadSoftTokenShare_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ReadSoftTokenShare_Reply>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_ReadSoftTokenShare_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ReadSoftTokenShare_Reply>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_ReadSoftTokenShare_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sharesleft) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ReadSoftTokenShare_Reply),
            "::",
            stringify!(sharesleft)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_ReceiveKey_Reply {
    pub idka: M_KeyID,
}
#[test]
fn bindgen_test_layout_M_Cmd_ReceiveKey_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ReceiveKey_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ReceiveKey_Reply>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_ReceiveKey_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ReceiveKey_Reply>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_ReceiveKey_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).idka) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ReceiveKey_Reply),
            "::",
            stringify!(idka)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_ReceiveShare_Reply {
    pub sharesleft: M_Word,
}
#[test]
fn bindgen_test_layout_M_Cmd_ReceiveShare_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ReceiveShare_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ReceiveShare_Reply>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_ReceiveShare_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ReceiveShare_Reply>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_ReceiveShare_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sharesleft) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ReceiveShare_Reply),
            "::",
            stringify!(sharesleft)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_RedeemTicket_Reply {
    pub obj: M_KeyID,
}
#[test]
fn bindgen_test_layout_M_Cmd_RedeemTicket_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_RedeemTicket_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_RedeemTicket_Reply>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_RedeemTicket_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_RedeemTicket_Reply>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_RedeemTicket_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).obj) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_RedeemTicket_Reply),
            "::",
            stringify!(obj)
        )
    );
}
pub type M_Cmd_RemoteReboot_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_RemoteReboot_Reply {
    pub flags: M_Cmd_RemoteReboot_Reply_flags,
}
#[test]
fn bindgen_test_layout_M_Cmd_RemoteReboot_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_RemoteReboot_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_RemoteReboot_Reply>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_RemoteReboot_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_RemoteReboot_Reply>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_RemoteReboot_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_RemoteReboot_Reply),
            "::",
            stringify!(flags)
        )
    );
}
pub type M_Cmd_RemoteSlots_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_RemoteSlots_Reply {
    pub flags: M_Cmd_RemoteSlots_Reply_flags,
}
#[test]
fn bindgen_test_layout_M_Cmd_RemoteSlots_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_RemoteSlots_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_RemoteSlots_Reply>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_RemoteSlots_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_RemoteSlots_Reply>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_RemoteSlots_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_RemoteSlots_Reply),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_RemoveSoftToken_Reply {
    pub data: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_Cmd_RemoveSoftToken_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_RemoveSoftToken_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_RemoveSoftToken_Reply>(),
        16usize,
        concat!("Size of: ", stringify!(M_Cmd_RemoveSoftToken_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_RemoveSoftToken_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_RemoveSoftToken_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_RemoveSoftToken_Reply),
            "::",
            stringify!(data)
        )
    );
}
impl Default for M_Cmd_RemoveSoftToken_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_ReportWorldState_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_ReportWorldState_Reply {
    pub flags: M_Cmd_ReportWorldState_Reply_flags,
}
#[test]
fn bindgen_test_layout_M_Cmd_ReportWorldState_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ReportWorldState_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ReportWorldState_Reply>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_ReportWorldState_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ReportWorldState_Reply>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_ReportWorldState_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ReportWorldState_Reply),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_SEEJob_Reply {
    pub seereply: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_Cmd_SEEJob_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_SEEJob_Reply> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_SEEJob_Reply>(),
        16usize,
        concat!("Size of: ", stringify!(M_Cmd_SEEJob_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_SEEJob_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_SEEJob_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).seereply) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_SEEJob_Reply),
            "::",
            stringify!(seereply)
        )
    );
}
impl Default for M_Cmd_SEEJob_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_SendKey_Reply {
    pub blob: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_Cmd_SendKey_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_SendKey_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_SendKey_Reply>(),
        16usize,
        concat!("Size of: ", stringify!(M_Cmd_SendKey_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_SendKey_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_SendKey_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).blob) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_SendKey_Reply),
            "::",
            stringify!(blob)
        )
    );
}
impl Default for M_Cmd_SendKey_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_SendShare_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_SendShare_Reply {
    pub flags: M_Cmd_SendShare_Reply_flags,
    pub share: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_Cmd_SendShare_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_SendShare_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_SendShare_Reply>(),
        24usize,
        concat!("Size of: ", stringify!(M_Cmd_SendShare_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_SendShare_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_SendShare_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_SendShare_Reply),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).share) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_SendShare_Reply),
            "::",
            stringify!(share)
        )
    );
}
impl Default for M_Cmd_SendShare_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ServerNoOp_Reply {
    pub payload: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_Cmd_ServerNoOp_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ServerNoOp_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ServerNoOp_Reply>(),
        16usize,
        concat!("Size of: ", stringify!(M_Cmd_ServerNoOp_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ServerNoOp_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_ServerNoOp_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).payload) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ServerNoOp_Reply),
            "::",
            stringify!(payload)
        )
    );
}
impl Default for M_Cmd_ServerNoOp_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_ServerSendShare_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ServerSendShare_Reply {
    pub flags: M_Cmd_ServerSendShare_Reply_flags,
    pub share: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_Cmd_ServerSendShare_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_ServerSendShare_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_ServerSendShare_Reply>(),
        24usize,
        concat!("Size of: ", stringify!(M_Cmd_ServerSendShare_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_ServerSendShare_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_ServerSendShare_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ServerSendShare_Reply),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).share) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_ServerSendShare_Reply),
            "::",
            stringify!(share)
        )
    );
}
impl Default for M_Cmd_ServerSendShare_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_SetApplianceTime_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_SetApplianceTime_Reply {
    pub flags: M_Cmd_SetApplianceTime_Reply_flags,
}
#[test]
fn bindgen_test_layout_M_Cmd_SetApplianceTime_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_SetApplianceTime_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_SetApplianceTime_Reply>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_SetApplianceTime_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_SetApplianceTime_Reply>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_SetApplianceTime_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_SetApplianceTime_Reply),
            "::",
            stringify!(flags)
        )
    );
}
pub type M_Cmd_SetApplianceUpgradeStatus_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_SetApplianceUpgradeStatus_Reply {
    pub flags: M_Cmd_SetApplianceUpgradeStatus_Reply_flags,
}
#[test]
fn bindgen_test_layout_M_Cmd_SetApplianceUpgradeStatus_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_SetApplianceUpgradeStatus_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_SetApplianceUpgradeStatus_Reply>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(M_Cmd_SetApplianceUpgradeStatus_Reply)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_SetApplianceUpgradeStatus_Reply>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(M_Cmd_SetApplianceUpgradeStatus_Reply)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_SetApplianceUpgradeStatus_Reply),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_Sign_Reply {
    pub sig: M_CipherText,
}
#[test]
fn bindgen_test_layout_M_Cmd_Sign_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_Sign_Reply> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_Sign_Reply>(),
        112usize,
        concat!("Size of: ", stringify!(M_Cmd_Sign_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_Sign_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_Sign_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_Sign_Reply),
            "::",
            stringify!(sig)
        )
    );
}
impl Default for M_Cmd_Sign_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_Sign_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Cmd_Sign_Reply {{ sig: {:?} }}", self.sig)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_ModuleCert {
    pub signature: M_CipherText,
    pub modcertmsg: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_ModuleCert() {
    const UNINIT: ::core::mem::MaybeUninit<M_ModuleCert> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_ModuleCert>(),
        128usize,
        concat!("Size of: ", stringify!(M_ModuleCert))
    );
    assert_eq!(
        ::core::mem::align_of::<M_ModuleCert>(),
        8usize,
        concat!("Alignment of ", stringify!(M_ModuleCert))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).signature) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ModuleCert),
            "::",
            stringify!(signature)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).modcertmsg) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ModuleCert),
            "::",
            stringify!(modcertmsg)
        )
    );
}
impl Default for M_ModuleCert {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_ModuleCert {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_ModuleCert {{ signature: {:?}, modcertmsg: {:?} }}",
            self.signature, self.modcertmsg
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_SignModuleState_Reply {
    pub cert: M_ModuleCert,
}
#[test]
fn bindgen_test_layout_M_Cmd_SignModuleState_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_SignModuleState_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_SignModuleState_Reply>(),
        128usize,
        concat!("Size of: ", stringify!(M_Cmd_SignModuleState_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_SignModuleState_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_SignModuleState_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cert) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_SignModuleState_Reply),
            "::",
            stringify!(cert)
        )
    );
}
impl Default for M_Cmd_SignModuleState_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_SignModuleState_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Cmd_SignModuleState_Reply {{ cert: {:?} }}", self.cert)
    }
}
pub type M_Cmd_StartUpdateWorld_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_StartUpdateWorld_Reply {
    pub flags: M_Cmd_StartUpdateWorld_Reply_flags,
}
#[test]
fn bindgen_test_layout_M_Cmd_StartUpdateWorld_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_StartUpdateWorld_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_StartUpdateWorld_Reply>(),
        4usize,
        concat!("Size of: ", stringify!(M_Cmd_StartUpdateWorld_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_StartUpdateWorld_Reply>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_StartUpdateWorld_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_StartUpdateWorld_Reply),
            "::",
            stringify!(flags)
        )
    );
}
pub type M_Cmd_StatEnumTree_Reply_flags = M_Word;
pub type M_vec_StatInfo = *mut M_StatInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_StatEnumTree_Reply {
    pub flags: M_Cmd_StatEnumTree_Reply_flags,
    pub n_statinfos: ::core::ffi::c_int,
    pub statinfos: M_vec_StatInfo,
    pub n_subnodetags: ::core::ffi::c_int,
    pub subnodetags: M_vec_Word,
}
#[test]
fn bindgen_test_layout_M_Cmd_StatEnumTree_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_StatEnumTree_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_StatEnumTree_Reply>(),
        32usize,
        concat!("Size of: ", stringify!(M_Cmd_StatEnumTree_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_StatEnumTree_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_StatEnumTree_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_StatEnumTree_Reply),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_statinfos) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_StatEnumTree_Reply),
            "::",
            stringify!(n_statinfos)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).statinfos) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_StatEnumTree_Reply),
            "::",
            stringify!(statinfos)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_subnodetags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_StatEnumTree_Reply),
            "::",
            stringify!(n_subnodetags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).subnodetags) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_StatEnumTree_Reply),
            "::",
            stringify!(subnodetags)
        )
    );
}
impl Default for M_Cmd_StatEnumTree_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_StatGetValues_Reply_flags = M_Word;
pub type M_vec_ASCIIString = *mut M_ASCIIString;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_wrap_vec_ASCIIString {
    pub n: ::core::ffi::c_int,
    pub v: M_vec_ASCIIString,
}
#[test]
fn bindgen_test_layout_M_wrap_vec_ASCIIString() {
    const UNINIT: ::core::mem::MaybeUninit<M_wrap_vec_ASCIIString> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_wrap_vec_ASCIIString>(),
        16usize,
        concat!("Size of: ", stringify!(M_wrap_vec_ASCIIString))
    );
    assert_eq!(
        ::core::mem::align_of::<M_wrap_vec_ASCIIString>(),
        8usize,
        concat!("Alignment of ", stringify!(M_wrap_vec_ASCIIString))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_wrap_vec_ASCIIString),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).v) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_wrap_vec_ASCIIString),
            "::",
            stringify!(v)
        )
    );
}
impl Default for M_wrap_vec_ASCIIString {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_StatGetValues_Reply {
    pub flags: M_Cmd_StatGetValues_Reply_flags,
    pub n_statinfos: ::core::ffi::c_int,
    pub statinfos: M_vec_StatInfo,
    pub n_values: ::core::ffi::c_int,
    pub values: M_vec_Word,
    pub strings: *mut M_wrap_vec_ASCIIString,
}
#[test]
fn bindgen_test_layout_M_Cmd_StatGetValues_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_StatGetValues_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_StatGetValues_Reply>(),
        40usize,
        concat!("Size of: ", stringify!(M_Cmd_StatGetValues_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_StatGetValues_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_StatGetValues_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_StatGetValues_Reply),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_statinfos) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_StatGetValues_Reply),
            "::",
            stringify!(n_statinfos)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).statinfos) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_StatGetValues_Reply),
            "::",
            stringify!(statinfos)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_values) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_StatGetValues_Reply),
            "::",
            stringify!(n_values)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).values) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_StatGetValues_Reply),
            "::",
            stringify!(values)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).strings) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_StatGetValues_Reply),
            "::",
            stringify!(strings)
        )
    );
}
impl Default for M_Cmd_StatGetValues_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_TraceSEEWorld_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_TraceSEEWorld_Reply {
    pub flags: M_Cmd_TraceSEEWorld_Reply_flags,
    pub data: M_ByteBlock,
}
#[test]
fn bindgen_test_layout_M_Cmd_TraceSEEWorld_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_TraceSEEWorld_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_TraceSEEWorld_Reply>(),
        24usize,
        concat!("Size of: ", stringify!(M_Cmd_TraceSEEWorld_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_TraceSEEWorld_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_TraceSEEWorld_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_TraceSEEWorld_Reply),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_TraceSEEWorld_Reply),
            "::",
            stringify!(data)
        )
    );
}
impl Default for M_Cmd_TraceSEEWorld_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_UpdateMergedKey_Reply {
    pub n_keys: ::core::ffi::c_int,
    pub keys: M_vec_KeyID,
}
#[test]
fn bindgen_test_layout_M_Cmd_UpdateMergedKey_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_UpdateMergedKey_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_UpdateMergedKey_Reply>(),
        16usize,
        concat!("Size of: ", stringify!(M_Cmd_UpdateMergedKey_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_UpdateMergedKey_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd_UpdateMergedKey_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_keys) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_UpdateMergedKey_Reply),
            "::",
            stringify!(n_keys)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).keys) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_UpdateMergedKey_Reply),
            "::",
            stringify!(keys)
        )
    );
}
impl Default for M_Cmd_UpdateMergedKey_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_UpgradeApplianceFirmware_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_UpgradeApplianceFirmware_Reply {
    pub flags: M_Cmd_UpgradeApplianceFirmware_Reply_flags,
}
#[test]
fn bindgen_test_layout_M_Cmd_UpgradeApplianceFirmware_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_UpgradeApplianceFirmware_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_UpgradeApplianceFirmware_Reply>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(M_Cmd_UpgradeApplianceFirmware_Reply)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_UpgradeApplianceFirmware_Reply>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(M_Cmd_UpgradeApplianceFirmware_Reply)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_UpgradeApplianceFirmware_Reply),
            "::",
            stringify!(flags)
        )
    );
}
pub type M_Cmd_VerifyCertificate_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_VerifyCertificate_Reply {
    pub flags: M_Cmd_VerifyCertificate_Reply_flags,
    pub v: M_Word,
}
#[test]
fn bindgen_test_layout_M_Cmd_VerifyCertificate_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd_VerifyCertificate_Reply> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd_VerifyCertificate_Reply>(),
        8usize,
        concat!("Size of: ", stringify!(M_Cmd_VerifyCertificate_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd_VerifyCertificate_Reply>(),
        4usize,
        concat!("Alignment of ", stringify!(M_Cmd_VerifyCertificate_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_VerifyCertificate_Reply),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).v) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd_VerifyCertificate_Reply),
            "::",
            stringify!(v)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_Cmd__Reply {
    pub anlogevent: M_Cmd_ANLogEvent_Reply,
    pub anmodulechangeevent: M_Cmd_ANModuleChangeEvent_Reply,
    pub anremotemoduledisconnected: M_Cmd_ANRemoteModuleDisconnected_Reply,
    pub anremoteslotdisconnected: M_Cmd_ANRemoteSlotDisconnected_Reply,
    pub ansendauditlogevent: M_Cmd_ANSendAuditLogEvent_Reply,
    pub anslotchangeevent: M_Cmd_ANSlotChangeEvent_Reply,
    pub anslotsconfigurationchangeevent: M_Cmd_ANSlotsConfigurationChangeEvent_Reply,
    pub addremoteserverpermission: M_Cmd_AddRemoteServerPermission_Reply,
    pub anonymousknetihash: M_Cmd_AnonymousKnetiHash_Reply,
    pub applyfeaturefile: M_Cmd_ApplyFeatureFile_Reply,
    pub bignumop: M_Cmd_BignumOp_Reply,
    pub channelopen: M_Cmd_ChannelOpen_Reply,
    pub channelupdate: M_Cmd_ChannelUpdate_Reply,
    pub checkworld: M_Cmd_CheckWorld_Reply,
    pub configurepoolmodule: M_Cmd_ConfigurePoolModule_Reply,
    pub createbuffer: M_Cmd_CreateBuffer_Reply,
    pub createclient: M_Cmd_CreateClient_Reply,
    pub createseeworld: M_Cmd_CreateSEEWorld_Reply,
    pub decrypt: M_Cmd_Decrypt_Reply,
    pub derivekey: M_Cmd_DeriveKey_Reply,
    pub devtest: M_Cmd_DevTest_Reply,
    pub duplicate: M_Cmd_Duplicate_Reply,
    pub dynamicslotcreateassociation: M_Cmd_DynamicSlotCreateAssociation_Reply,
    pub dynamicslotexchangeapdus: M_Cmd_DynamicSlotExchangeAPDUs_Reply,
    pub dynamicslotsconfigurequery: M_Cmd_DynamicSlotsConfigureQuery_Reply,
    pub encrypt: M_Cmd_Encrypt_Reply,
    pub eraseworld: M_Cmd_EraseWorld_Reply,
    pub existingclient: M_Cmd_ExistingClient_Reply,
    pub export: M_Cmd_Export_Reply,
    pub exportmodule: M_Cmd_ExportModule_Reply,
    pub exportslot: M_Cmd_ExportSlot_Reply,
    pub ftchecksum: M_Cmd_FTChecksum_Reply,
    pub ftdelete: M_Cmd_FTDelete_Reply,
    pub ftlistdir: M_Cmd_FTListDir_Reply,
    pub ftread: M_Cmd_FTRead_Reply,
    pub ftsessionopen: M_Cmd_FTSessionOpen_Reply,
    pub ftstartlistdir: M_Cmd_FTStartListDir_Reply,
    pub ftstartread: M_Cmd_FTStartRead_Reply,
    pub ftstartwrite: M_Cmd_FTStartWrite_Reply,
    pub ftstat: M_Cmd_FTStat_Reply,
    pub faildriver: M_Cmd_FailDriver_Reply,
    pub fastseejob: M_Cmd_FastSEEJob_Reply,
    pub fileop: M_Cmd_FileOp_Reply,
    pub firmwareauthenticate: M_Cmd_FirmwareAuthenticate_Reply,
    pub foreigntokencmd: M_Cmd_ForeignTokenCmd_Reply,
    pub foreigntokenopen: M_Cmd_ForeignTokenOpen_Reply,
    pub generatekey: M_Cmd_GenerateKey_Reply,
    pub generatekeypair: M_Cmd_GenerateKeyPair_Reply,
    pub generatelogicaltoken: M_Cmd_GenerateLogicalToken_Reply,
    pub generateprime: M_Cmd_GeneratePrime_Reply,
    pub generaterandom: M_Cmd_GenerateRandom_Reply,
    pub getacl: M_Cmd_GetACL_Reply,
    pub getappdata: M_Cmd_GetAppData_Reply,
    pub getappliancetime: M_Cmd_GetApplianceTime_Reply,
    pub getapplianceupgradestatus: M_Cmd_GetApplianceUpgradeStatus_Reply,
    pub getapplianceversion: M_Cmd_GetApplianceVersion_Reply,
    pub getchallenge: M_Cmd_GetChallenge_Reply,
    pub getclienthash: M_Cmd_GetClientHash_Reply,
    pub gethardwareerror: M_Cmd_GetHardwareError_Reply,
    pub getklf: M_Cmd_GetKLF_Reply,
    pub getklf2: M_Cmd_GetKLF2_Reply,
    pub getkml: M_Cmd_GetKML_Reply,
    pub getkmlist: M_Cmd_GetKMList_Reply,
    pub getkeyinfo: M_Cmd_GetKeyInfo_Reply,
    pub getkeyinfoex: M_Cmd_GetKeyInfoEx_Reply,
    pub getknetipub: M_Cmd_GetKnetiPub_Reply,
    pub getlogicaltokeninfo: M_Cmd_GetLogicalTokenInfo_Reply,
    pub getlogicaltokeninfoex: M_Cmd_GetLogicalTokenInfoEx_Reply,
    pub getmodulestate: M_Cmd_GetModuleState_Reply,
    pub getmonitorloaderstate: M_Cmd_GetMonitorLoaderState_Reply,
    pub getpoolinfo: M_Cmd_GetPoolInfo_Reply,
    pub getpublishedobject: M_Cmd_GetPublishedObject_Reply,
    pub getrtc: M_Cmd_GetRTC_Reply,
    pub getserverconfig: M_Cmd_GetServerConfig_Reply,
    pub getshareacl: M_Cmd_GetShareACL_Reply,
    pub getslotinfo: M_Cmd_GetSlotInfo_Reply,
    pub getslotlist: M_Cmd_GetSlotList_Reply,
    pub getticket: M_Cmd_GetTicket_Reply,
    pub getwhichmodule: M_Cmd_GetWhichModule_Reply,
    pub getworldsigners: M_Cmd_GetWorldSigners_Reply,
    pub hash: M_Cmd_Hash_Reply,
    pub ioboardreprogram: M_Cmd_IOBoardReprogram_Reply,
    pub impathgetinfo: M_Cmd_ImpathGetInfo_Reply,
    pub impathkxbegin: M_Cmd_ImpathKXBegin_Reply,
    pub impathreceive: M_Cmd_ImpathReceive_Reply,
    pub impathsend: M_Cmd_ImpathSend_Reply,
    pub import: M_Cmd_Import_Reply,
    pub importslot: M_Cmd_ImportSlot_Reply,
    pub insertsofttoken: M_Cmd_InsertSoftToken_Reply,
    pub listremoteserverpermission: M_Cmd_ListRemoteServerPermission_Reply,
    pub listremoteserverpermissionex: M_Cmd_ListRemoteServerPermissionEx_Reply,
    pub loadblob: M_Cmd_LoadBlob_Reply,
    pub loadlogicaltoken: M_Cmd_LoadLogicalToken_Reply,
    pub makeblob: M_Cmd_MakeBlob_Reply,
    pub mergekeyids: M_Cmd_MergeKeyIDs_Reply,
    pub modexp: M_Cmd_ModExp_Reply,
    pub moduleinfo: M_Cmd_ModuleInfo_Reply,
    pub nvmemlist: M_Cmd_NVMemList_Reply,
    pub nvmemop: M_Cmd_NVMemOp_Reply,
    pub newclient: M_Cmd_NewClient_Reply,
    pub newenquiry: M_Cmd_NewEnquiry_Reply,
    pub pausefornotifications: M_Cmd_PauseForNotifications_Reply,
    pub pollmodulestate: M_Cmd_PollModuleState_Reply,
    pub pollslotlist: M_Cmd_PollSlotList_Reply,
    pub productionsetup: M_Cmd_ProductionSetup_Reply,
    pub programmingbeginchunk: M_Cmd_ProgrammingBeginChunk_Reply,
    pub programmingendchunk: M_Cmd_ProgrammingEndChunk_Reply,
    pub programminggetkeylist: M_Cmd_ProgrammingGetKeyList_Reply,
    pub querylongjobs: M_Cmd_QueryLongJobs_Reply,
    pub rsaimmedsigndecrypt: M_Cmd_RSAImmedSignDecrypt_Reply,
    pub rereadconfig: M_Cmd_ReReadConfig_Reply,
    pub readfile: M_Cmd_ReadFile_Reply,
    pub readshare: M_Cmd_ReadShare_Reply,
    pub readsofttokenshare: M_Cmd_ReadSoftTokenShare_Reply,
    pub receivekey: M_Cmd_ReceiveKey_Reply,
    pub receiveshare: M_Cmd_ReceiveShare_Reply,
    pub redeemticket: M_Cmd_RedeemTicket_Reply,
    pub remotereboot: M_Cmd_RemoteReboot_Reply,
    pub remoteslots: M_Cmd_RemoteSlots_Reply,
    pub removesofttoken: M_Cmd_RemoveSoftToken_Reply,
    pub reportworldstate: M_Cmd_ReportWorldState_Reply,
    pub seejob: M_Cmd_SEEJob_Reply,
    pub sendkey: M_Cmd_SendKey_Reply,
    pub sendshare: M_Cmd_SendShare_Reply,
    pub servernoop: M_Cmd_ServerNoOp_Reply,
    pub serversendshare: M_Cmd_ServerSendShare_Reply,
    pub setappliancetime: M_Cmd_SetApplianceTime_Reply,
    pub setapplianceupgradestatus: M_Cmd_SetApplianceUpgradeStatus_Reply,
    pub sign: M_Cmd_Sign_Reply,
    pub signmodulestate: M_Cmd_SignModuleState_Reply,
    pub startupdateworld: M_Cmd_StartUpdateWorld_Reply,
    pub statenumtree: M_Cmd_StatEnumTree_Reply,
    pub statgetvalues: M_Cmd_StatGetValues_Reply,
    pub traceseeworld: M_Cmd_TraceSEEWorld_Reply,
    pub updatemergedkey: M_Cmd_UpdateMergedKey_Reply,
    pub upgradeappliancefirmware: M_Cmd_UpgradeApplianceFirmware_Reply,
    pub verifycertificate: M_Cmd_VerifyCertificate_Reply,
}
#[test]
fn bindgen_test_layout_M_Cmd__Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Cmd__Reply> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Cmd__Reply>(),
        248usize,
        concat!("Size of: ", stringify!(M_Cmd__Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Cmd__Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Cmd__Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).anlogevent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(anlogevent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).anmodulechangeevent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(anmodulechangeevent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).anremotemoduledisconnected) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(anremotemoduledisconnected)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).anremoteslotdisconnected) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(anremoteslotdisconnected)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ansendauditlogevent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(ansendauditlogevent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).anslotchangeevent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(anslotchangeevent)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).anslotsconfigurationchangeevent) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(anslotsconfigurationchangeevent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).addremoteserverpermission) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(addremoteserverpermission)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).anonymousknetihash) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(anonymousknetihash)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).applyfeaturefile) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(applyfeaturefile)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bignumop) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(bignumop)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).channelopen) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(channelopen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).channelupdate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(channelupdate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).checkworld) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(checkworld)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).configurepoolmodule) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(configurepoolmodule)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).createbuffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(createbuffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).createclient) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(createclient)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).createseeworld) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(createseeworld)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).decrypt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(decrypt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).derivekey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(derivekey)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).devtest) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(devtest)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).duplicate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(duplicate)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).dynamicslotcreateassociation) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(dynamicslotcreateassociation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dynamicslotexchangeapdus) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(dynamicslotexchangeapdus)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dynamicslotsconfigurequery) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(dynamicslotsconfigurequery)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).encrypt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(encrypt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).eraseworld) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(eraseworld)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).existingclient) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(existingclient)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).export) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(export)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).exportmodule) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(exportmodule)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).exportslot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(exportslot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ftchecksum) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(ftchecksum)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ftdelete) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(ftdelete)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ftlistdir) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(ftlistdir)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ftread) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(ftread)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ftsessionopen) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(ftsessionopen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ftstartlistdir) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(ftstartlistdir)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ftstartread) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(ftstartread)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ftstartwrite) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(ftstartwrite)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ftstat) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(ftstat)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).faildriver) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(faildriver)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fastseejob) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(fastseejob)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fileop) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(fileop)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).firmwareauthenticate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(firmwareauthenticate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).foreigntokencmd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(foreigntokencmd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).foreigntokenopen) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(foreigntokenopen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).generatekey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(generatekey)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).generatekeypair) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(generatekeypair)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).generatelogicaltoken) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(generatelogicaltoken)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).generateprime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(generateprime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).generaterandom) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(generaterandom)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getacl) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(getacl)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getappdata) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(getappdata)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getappliancetime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(getappliancetime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getapplianceupgradestatus) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(getapplianceupgradestatus)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getapplianceversion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(getapplianceversion)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getchallenge) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(getchallenge)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getclienthash) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(getclienthash)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gethardwareerror) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(gethardwareerror)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getklf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(getklf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getklf2) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(getklf2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getkml) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(getkml)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getkmlist) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(getkmlist)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getkeyinfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(getkeyinfo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getkeyinfoex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(getkeyinfoex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getknetipub) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(getknetipub)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getlogicaltokeninfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(getlogicaltokeninfo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getlogicaltokeninfoex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(getlogicaltokeninfoex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getmodulestate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(getmodulestate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getmonitorloaderstate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(getmonitorloaderstate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getpoolinfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(getpoolinfo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getpublishedobject) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(getpublishedobject)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getrtc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(getrtc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getserverconfig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(getserverconfig)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getshareacl) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(getshareacl)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getslotinfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(getslotinfo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getslotlist) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(getslotlist)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getticket) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(getticket)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getwhichmodule) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(getwhichmodule)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getworldsigners) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(getworldsigners)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hash) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ioboardreprogram) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(ioboardreprogram)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).impathgetinfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(impathgetinfo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).impathkxbegin) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(impathkxbegin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).impathreceive) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(impathreceive)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).impathsend) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(impathsend)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).import) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(import)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).importslot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(importslot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).insertsofttoken) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(insertsofttoken)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).listremoteserverpermission) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(listremoteserverpermission)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).listremoteserverpermissionex) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(listremoteserverpermissionex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).loadblob) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(loadblob)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).loadlogicaltoken) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(loadlogicaltoken)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).makeblob) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(makeblob)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mergekeyids) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(mergekeyids)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).modexp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(modexp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).moduleinfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(moduleinfo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nvmemlist) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(nvmemlist)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nvmemop) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(nvmemop)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).newclient) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(newclient)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).newenquiry) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(newenquiry)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pausefornotifications) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(pausefornotifications)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pollmodulestate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(pollmodulestate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pollslotlist) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(pollslotlist)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).productionsetup) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(productionsetup)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).programmingbeginchunk) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(programmingbeginchunk)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).programmingendchunk) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(programmingendchunk)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).programminggetkeylist) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(programminggetkeylist)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).querylongjobs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(querylongjobs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rsaimmedsigndecrypt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(rsaimmedsigndecrypt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rereadconfig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(rereadconfig)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).readfile) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(readfile)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).readshare) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(readshare)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).readsofttokenshare) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(readsofttokenshare)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).receivekey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(receivekey)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).receiveshare) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(receiveshare)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).redeemticket) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(redeemticket)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).remotereboot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(remotereboot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).remoteslots) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(remoteslots)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).removesofttoken) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(removesofttoken)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reportworldstate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(reportworldstate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).seejob) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(seejob)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sendkey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(sendkey)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sendshare) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(sendshare)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).servernoop) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(servernoop)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).serversendshare) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(serversendshare)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).setappliancetime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(setappliancetime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).setapplianceupgradestatus) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(setapplianceupgradestatus)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sign) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(sign)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).signmodulestate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(signmodulestate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).startupdateworld) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(startupdateworld)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).statenumtree) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(statenumtree)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).statgetvalues) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(statgetvalues)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).traceseeworld) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(traceseeworld)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).updatemergedkey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(updatemergedkey)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).upgradeappliancefirmware) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(upgradeappliancefirmware)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).verifycertificate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Cmd__Reply),
            "::",
            stringify!(verifycertificate)
        )
    );
}
impl Default for M_Cmd__Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd__Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Cmd__Reply {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Reply {
    pub tag: M_Tag,
    pub cmd: M_Cmd,
    pub status: M_Status,
    pub flags: M_Reply_flags,
    pub reply: M_Cmd__Reply,
    pub errorinfo: M_Status__ErrorInfo,
    pub state: *mut M_StateList,
    pub esn: *mut M_ASCIIString,
}
#[test]
fn bindgen_test_layout_M_Reply() {
    const UNINIT: ::core::mem::MaybeUninit<M_Reply> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_Reply>(),
        304usize,
        concat!("Size of: ", stringify!(M_Reply))
    );
    assert_eq!(
        ::core::mem::align_of::<M_Reply>(),
        8usize,
        concat!("Alignment of ", stringify!(M_Reply))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tag) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Reply),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Reply),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Reply),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Reply),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reply) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Reply),
            "::",
            stringify!(reply)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).errorinfo) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Reply),
            "::",
            stringify!(errorinfo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Reply),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).esn) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(M_Reply),
            "::",
            stringify!(esn)
        )
    );
}
impl Default for M_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_Reply {{ tag: {:?}, cmd: {:?}, status: {:?}, flags: {:?}, reply: {:?}, errorinfo: {:?}, state: {:?}, esn: {:?} }}" , self . tag , self . cmd , self . status , self . flags , self . reply , self . errorinfo , self . state , self . esn)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_LogTokenShareInfo {
    pub state: M_LogTokenShareState,
}
#[test]
fn bindgen_test_layout_M_LogTokenShareInfo() {
    const UNINIT: ::core::mem::MaybeUninit<M_LogTokenShareInfo> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_LogTokenShareInfo>(),
        4usize,
        concat!("Size of: ", stringify!(M_LogTokenShareInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<M_LogTokenShareInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(M_LogTokenShareInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_LogTokenShareInfo),
            "::",
            stringify!(state)
        )
    );
}
impl Default for M_LogTokenShareInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_TokenInfo_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_TokenInfo {
    pub flags: M_TokenInfo_flags,
    pub hkt: M_ShortHash,
    pub i: M_Word,
}
#[test]
fn bindgen_test_layout_M_TokenInfo() {
    const UNINIT: ::core::mem::MaybeUninit<M_TokenInfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_TokenInfo>(),
        20usize,
        concat!("Size of: ", stringify!(M_TokenInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<M_TokenInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(M_TokenInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_TokenInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hkt) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_TokenInfo),
            "::",
            stringify!(hkt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).i) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(M_TokenInfo),
            "::",
            stringify!(i)
        )
    );
}
impl Default for M_TokenInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_TokenInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_TokenInfo {{ flags: {:?}, hkt: {:?}, i: {:?} }}",
            self.flags, self.hkt, self.i
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_DeviceID {
    pub bus: M_BusType,
    pub id: M_Word,
    pub other: M_Word,
}
#[test]
fn bindgen_test_layout_M_DeviceID() {
    const UNINIT: ::core::mem::MaybeUninit<M_DeviceID> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_DeviceID>(),
        12usize,
        concat!("Size of: ", stringify!(M_DeviceID))
    );
    assert_eq!(
        ::core::mem::align_of::<M_DeviceID>(),
        4usize,
        concat!("Alignment of ", stringify!(M_DeviceID))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bus) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeviceID),
            "::",
            stringify!(bus)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeviceID),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).other) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(M_DeviceID),
            "::",
            stringify!(other)
        )
    );
}
impl Default for M_DeviceID {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_ProgrammingKeyListEntry {
    pub type_: M_KeyType,
    pub hash: M_KeyHash,
}
#[test]
fn bindgen_test_layout_M_ProgrammingKeyListEntry() {
    const UNINIT: ::core::mem::MaybeUninit<M_ProgrammingKeyListEntry> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_ProgrammingKeyListEntry>(),
        24usize,
        concat!("Size of: ", stringify!(M_ProgrammingKeyListEntry))
    );
    assert_eq!(
        ::core::mem::align_of::<M_ProgrammingKeyListEntry>(),
        4usize,
        concat!("Alignment of ", stringify!(M_ProgrammingKeyListEntry))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ProgrammingKeyListEntry),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hash) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_ProgrammingKeyListEntry),
            "::",
            stringify!(hash)
        )
    );
}
impl Default for M_ProgrammingKeyListEntry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_ProgrammingKeyListEntry {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_ProgrammingKeyListEntry {{ type: {:?}, hash: {:?} }}",
            self.type_, self.hash
        )
    }
}
pub type M_StatInfo_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_StatInfo {
    pub id: M_StatID,
    pub flags: M_StatInfo_flags,
}
#[test]
fn bindgen_test_layout_M_StatInfo() {
    const UNINIT: ::core::mem::MaybeUninit<M_StatInfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<M_StatInfo>(),
        8usize,
        concat!("Size of: ", stringify!(M_StatInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<M_StatInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(M_StatInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(M_StatInfo),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(M_StatInfo),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for M_StatInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NF_UserData {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NF_Free_Context {
    pub u: *mut NF_UserData,
}
#[test]
fn bindgen_test_layout_NF_Free_Context() {
    const UNINIT: ::core::mem::MaybeUninit<NF_Free_Context> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NF_Free_Context>(),
        8usize,
        concat!("Size of: ", stringify!(NF_Free_Context))
    );
    assert_eq!(
        ::core::mem::align_of::<NF_Free_Context>(),
        8usize,
        concat!("Alignment of ", stringify!(NF_Free_Context))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NF_Free_Context),
            "::",
            stringify!(u)
        )
    );
}
impl Default for NF_Free_Context {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static NF_Cmd_CreateSEEWorld_Args_flags_table: [M_ValInfo; 0usize];
}
extern "C" {
    pub static NF_Cmd_LoadBuffer_Args_flags_table: [M_ValInfo; 0usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NF_TypeHeader {
    pub tag: ::core::ffi::c_int,
    pub colour: *const NF_ColourInfo,
    pub name: *const ::core::ffi::c_char,
    pub sz: usize,
    pub flags: M_Word,
    pub tovoidstar: ::core::option::Option<
        unsafe extern "C" fn(pp: *const ::core::ffi::c_void) -> *mut ::core::ffi::c_void,
    >,
    pub fromvoidstar: ::core::option::Option<
        unsafe extern "C" fn(pp: *mut ::core::ffi::c_void, p: *mut ::core::ffi::c_void),
    >,
}
#[test]
fn bindgen_test_layout_NF_TypeHeader() {
    const UNINIT: ::core::mem::MaybeUninit<NF_TypeHeader> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NF_TypeHeader>(),
        56usize,
        concat!("Size of: ", stringify!(NF_TypeHeader))
    );
    assert_eq!(
        ::core::mem::align_of::<NF_TypeHeader>(),
        8usize,
        concat!("Alignment of ", stringify!(NF_TypeHeader))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tag) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NF_TypeHeader),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).colour) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NF_TypeHeader),
            "::",
            stringify!(colour)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NF_TypeHeader),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sz) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NF_TypeHeader),
            "::",
            stringify!(sz)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NF_TypeHeader),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tovoidstar) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NF_TypeHeader),
            "::",
            stringify!(tovoidstar)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fromvoidstar) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(NF_TypeHeader),
            "::",
            stringify!(fromvoidstar)
        )
    );
}
impl Default for NF_TypeHeader {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NF_StructSlot {
    pub name: *const ::core::ffi::c_char,
    pub kind: ::core::ffi::c_int,
    pub ty: *const NF_TypeHeader,
    pub off: usize,
    pub x: M_Word,
    pub y: M_Word,
}
#[test]
fn bindgen_test_layout_NF_StructSlot() {
    const UNINIT: ::core::mem::MaybeUninit<NF_StructSlot> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NF_StructSlot>(),
        40usize,
        concat!("Size of: ", stringify!(NF_StructSlot))
    );
    assert_eq!(
        ::core::mem::align_of::<NF_StructSlot>(),
        8usize,
        concat!("Alignment of ", stringify!(NF_StructSlot))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NF_StructSlot),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kind) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NF_StructSlot),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ty) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NF_StructSlot),
            "::",
            stringify!(ty)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).off) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NF_StructSlot),
            "::",
            stringify!(off)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NF_StructSlot),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(NF_StructSlot),
            "::",
            stringify!(y)
        )
    );
}
impl Default for NF_StructSlot {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NF_StructType {
    pub t: NF_TypeHeader,
    pub n_slots: ::core::ffi::c_int,
    pub slots: *const NF_StructSlot,
    pub vertag: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_NF_StructType() {
    const UNINIT: ::core::mem::MaybeUninit<NF_StructType> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NF_StructType>(),
        80usize,
        concat!("Size of: ", stringify!(NF_StructType))
    );
    assert_eq!(
        ::core::mem::align_of::<NF_StructType>(),
        8usize,
        concat!("Alignment of ", stringify!(NF_StructType))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).t) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NF_StructType),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_slots) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(NF_StructType),
            "::",
            stringify!(n_slots)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).slots) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(NF_StructType),
            "::",
            stringify!(slots)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vertag) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(NF_StructType),
            "::",
            stringify!(vertag)
        )
    );
}
impl Default for NF_StructType {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NF_FlagType {
    pub t: NF_TypeHeader,
    pub resmask: M_Word,
    pub allmask: M_Word,
    pub presmask: M_Word,
    pub vi: *const M_ValInfo,
}
#[test]
fn bindgen_test_layout_NF_FlagType() {
    const UNINIT: ::core::mem::MaybeUninit<NF_FlagType> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NF_FlagType>(),
        80usize,
        concat!("Size of: ", stringify!(NF_FlagType))
    );
    assert_eq!(
        ::core::mem::align_of::<NF_FlagType>(),
        8usize,
        concat!("Alignment of ", stringify!(NF_FlagType))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).t) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NF_FlagType),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).resmask) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(NF_FlagType),
            "::",
            stringify!(resmask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).allmask) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(NF_FlagType),
            "::",
            stringify!(allmask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).presmask) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(NF_FlagType),
            "::",
            stringify!(presmask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vi) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(NF_FlagType),
            "::",
            stringify!(vi)
        )
    );
}
impl Default for NF_FlagType {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NF_ColourInfo {
    pub primary: ::core::ffi::c_int,
    pub tag: *const ::core::ffi::c_char,
    pub nprim: ::core::ffi::c_uint,
    pub ty: *const *const NF_TypeHeader,
    pub expty: *const *const NF_TypeHeader,
}
#[test]
fn bindgen_test_layout_NF_ColourInfo() {
    const UNINIT: ::core::mem::MaybeUninit<NF_ColourInfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NF_ColourInfo>(),
        40usize,
        concat!("Size of: ", stringify!(NF_ColourInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<NF_ColourInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(NF_ColourInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).primary) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NF_ColourInfo),
            "::",
            stringify!(primary)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tag) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NF_ColourInfo),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nprim) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NF_ColourInfo),
            "::",
            stringify!(nprim)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ty) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NF_ColourInfo),
            "::",
            stringify!(ty)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).expty) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NF_ColourInfo),
            "::",
            stringify!(expty)
        )
    );
}
impl Default for NF_ColourInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NFTDM_State {
    _unused: [u8; 0],
}
extern "C" {
    pub static NF_Type_Cmd_CreateSEEWorld_Args_flags: NF_FlagType;
}
extern "C" {
    pub static NF_Type_Cmd_CreateSEEWorld_Args: NF_StructType;
}
extern "C" {
    pub static NF_Type_Cmd_LoadBuffer_Args_flags: NF_FlagType;
}
extern "C" {
    pub static NF_Type_Cmd_LoadBuffer_Args: NF_StructType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NF_StdmCommonCtx {
    pub a: *mut nf_arena,
    pub tdm: *mut NFTDM_State,
    pub pc: *mut PrimitiveContext,
    pub extra1: *mut ExtraOne,
    pub extra2: *mut ExtraTwo,
}
#[test]
fn bindgen_test_layout_NF_StdmCommonCtx() {
    const UNINIT: ::core::mem::MaybeUninit<NF_StdmCommonCtx> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NF_StdmCommonCtx>(),
        40usize,
        concat!("Size of: ", stringify!(NF_StdmCommonCtx))
    );
    assert_eq!(
        ::core::mem::align_of::<NF_StdmCommonCtx>(),
        8usize,
        concat!("Alignment of ", stringify!(NF_StdmCommonCtx))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).a) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NF_StdmCommonCtx),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tdm) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NF_StdmCommonCtx),
            "::",
            stringify!(tdm)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pc) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NF_StdmCommonCtx),
            "::",
            stringify!(pc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).extra1) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NF_StdmCommonCtx),
            "::",
            stringify!(extra1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).extra2) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NF_StdmCommonCtx),
            "::",
            stringify!(extra2)
        )
    );
}
impl Default for NF_StdmCommonCtx {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NF_StdmFree_Context {
    pub cc: NF_StdmCommonCtx,
}
#[test]
fn bindgen_test_layout_NF_StdmFree_Context() {
    const UNINIT: ::core::mem::MaybeUninit<NF_StdmFree_Context> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NF_StdmFree_Context>(),
        40usize,
        concat!("Size of: ", stringify!(NF_StdmFree_Context))
    );
    assert_eq!(
        ::core::mem::align_of::<NF_StdmFree_Context>(),
        8usize,
        concat!("Alignment of ", stringify!(NF_StdmFree_Context))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NF_StdmFree_Context),
            "::",
            stringify!(cc)
        )
    );
}
impl Default for NF_StdmFree_Context {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn NF_Free_Reply(ctx: *mut NF_Free_Context, msg: *mut M_Reply) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn NF_StdmFree_Reply(
        ctx: *mut NF_StdmFree_Context,
        msg: *mut M_Reply,
    ) -> ::core::ffi::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NFastApp_ConnectionData {
    _unused: [u8; 0],
}
pub type NFastApp_Connection = *mut NFastApp_ConnectionData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NFast_Call_Context {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NFast_Transaction_Context {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NFast_Application {
    _unused: [u8; 0],
}
pub type NFast_AppHandle = *mut NFast_Application;
pub type NFast_MallocUpcall_t = ::core::option::Option<
    unsafe extern "C" fn(
        sz: usize,
        cctx: *mut NFast_Call_Context,
        tctx: *mut NFast_Transaction_Context,
    ) -> *mut ::core::ffi::c_void,
>;
pub type NFast_ReallocUpcall_t = ::core::option::Option<
    unsafe extern "C" fn(
        ptr: *mut ::core::ffi::c_void,
        sz: usize,
        cctx: *mut NFast_Call_Context,
        tctx: *mut NFast_Transaction_Context,
    ) -> *mut ::core::ffi::c_void,
>;
pub type NFast_FreeUpcall_t = ::core::option::Option<
    unsafe extern "C" fn(
        ptr: *mut ::core::ffi::c_void,
        cctx: *mut NFast_Call_Context,
        tctx: *mut NFast_Transaction_Context,
    ),
>;
extern "C" {
    pub fn NFastApp_Init(
        handle_out: *mut NFast_AppHandle,
        mallocupcall: NFast_MallocUpcall_t,
        reallocupcall: NFast_ReallocUpcall_t,
        freeupcall: NFast_FreeUpcall_t,
        cctx: *mut NFast_Call_Context,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn NFastApp_Connect(
        app: NFast_AppHandle,
        conn_r: *mut NFastApp_Connection,
        flags: uint32,
        cctx: *mut NFast_Call_Context,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn NFastApp_Disconnect(
        conn: NFastApp_Connection,
        cctx: *mut NFast_Call_Context,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn NFastApp_Transact(
        conn: NFastApp_Connection,
        cctx: *mut NFast_Call_Context,
        command: *const M_Command,
        reply: *mut M_Reply,
        tctx: *mut NFast_Transaction_Context,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn NFastApp_Free_Reply(
        app: *mut NFast_Application,
        cctx: *mut NFast_Call_Context,
        tctx: *mut NFast_Transaction_Context,
        reply: *mut M_Reply,
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nf_arena {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PrimitiveContext {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ExtraOne {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ExtraTwo {
    pub _address: u8,
}
