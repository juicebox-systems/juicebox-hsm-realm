/* automatically generated by rust-bindgen 0.66.1 */

#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]

pub const Command_flags_BignumMSBitFirst: u32 = 1;
pub const Command_flags_BignumMSWordFirst: u32 = 2;
pub const Command_flags_certs_present: u32 = 4;
pub const Command_flags_Unused: u32 = 8;
pub const Command_flags_state_present: u32 = 16;
pub const Command_flags_PoolModule: u32 = 32;
pub const Command_flags_extractstate_present: u32 = 64;
pub const Command_flags_RetainState: u32 = 128;
pub const Command_flags_sessionid_present: u32 = 256;
pub const Command_flags_LongJob: u32 = 65536;
pub const Command_flags_Resubmit: u32 = 131072;
pub const Command_flags__reserved: u32 = 4294901760;
pub const Command_flags__allflags: u32 = 197119;
pub const Command_flags__presentflags: u32 = 340;
pub const SEELIB_JOB_REQUEUE: u32 = 1;
pub type uint32 = ::core::ffi::c_uint;
pub type uint64 = ::core::ffi::c_ulonglong;
pub type M_Word = uint32;
pub type M_Word64 = uint64;
pub type M_MustBeZeroWord = ::core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_ByteBlock {
    pub len: M_Word,
    pub ptr: *mut ::core::ffi::c_uchar,
}
impl Default for M_ByteBlock {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_StringASCII = *mut ::core::ffi::c_char;
pub type M_StringUTF8 = M_StringASCII;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_ASCIIString {
    pub ptr: M_StringASCII,
}
impl Default for M_ASCIIString {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Tag = M_Word;
pub type M_KeyID = M_Word;
pub type M_ModuleID = M_Word;
pub type M_SlotID = M_Word;
pub type M_Bignum = *mut NFast_Bignum;
pub const Status_OK: M_Status = 0;
pub const Status_UnknownCommand: M_Status = 1;
pub const Status_NotYetImplemented: M_Status = 2;
pub const Status_Malformed: M_Status = 3;
pub const Status_UnknownID: M_Status = 4;
pub const Status_AccessDenied: M_Status = 5;
pub const Status_ObjectInUse: M_Status = 6;
pub const Status_UseLimitExceeded: M_Status = 7;
pub const Status_TimeLimitExceeded: M_Status = 8;
pub const Status_BadCertKeyHash: M_Status = 9;
pub const Status_BadCertSignature: M_Status = 10;
pub const Status_VerifyFailed: M_Status = 11;
pub const Status_TypeMismatch: M_Status = 12;
pub const Status_BadShareState: M_Status = 13;
pub const Status_BadTokenData: M_Status = 14;
pub const Status_NoMemory: M_Status = 15;
pub const Status_Failed: M_Status = 16;
pub const Status_UnknownParameter: M_Status = 17;
pub const Status_UnknownFlag: M_Status = 18;
pub const Status_BlobTypeUnknown: M_Status = 19;
pub const Status_BufferFull: M_Status = 20;
pub const Status_UnitReset: M_Status = 21;
pub const Status_ClientUnknown: M_Status = 22;
pub const Status_CrossModule: M_Status = 23;
pub const Status_InvalidParameter: M_Status = 24;
pub const Status_InvalidState: M_Status = 25;
pub const Status_InvalidModule: M_Status = 26;
pub const Status_TokenAssemblyFailed: M_Status = 27;
pub const Status_UnknownKM: M_Status = 28;
pub const Status_LogTokenNotPresent: M_Status = 29;
pub const Status_InvalidMonitorMultiple: M_Status = 30;
pub const Status_DecryptFailed: M_Status = 31;
pub const Status_WriteProtected: M_Status = 33;
pub const Status_OutOfRange: M_Status = 34;
pub const Status_PrivilegedCommand: M_Status = 35;
pub const Status_UnknownSlot: M_Status = 36;
pub const Status_UnknownKeyHash: M_Status = 37;
pub const Status_TokenAuthFailed: M_Status = 38;
pub const Status_UnknownMechanism: M_Status = 39;
pub const Status_NoSpaceOnToken: M_Status = 40;
pub const Status_TokenNotFormatted: M_Status = 41;
pub const Status_UnknownTokenType: M_Status = 42;
pub const Status_TokenIOError: M_Status = 43;
pub const Status_EncryptFailed: M_Status = 44;
pub const Status_InvalidACL: M_Status = 45;
pub const Status_MetaDataProtection: M_Status = 46;
pub const Status_PhysTokenNotPresent: M_Status = 47;
pub const Status_MechanismNotExpected: M_Status = 48;
pub const Status_UnknownDefault: M_Status = 49;
pub const Status_AttemptedDowngrade: M_Status = 50;
pub const Status_SlotFull: M_Status = 51;
pub const Status_UnknownChallenge: M_Status = 52;
pub const Status_AsynchNotification: M_Status = 53;
pub const Status_InvalidData: M_Status = 54;
pub const Status_HardwareFailed: M_Status = 55;
pub const Status_ServerNotRunning: M_Status = 56;
pub const Status_OSErrorErrno: M_Status = 57;
pub const Status_TransactionNotFound: M_Status = 58;
pub const Status_TransactionNotYetComplete: M_Status = 59;
pub const Status_ServerConnectionLost: M_Status = 60;
pub const Status_ServerFailed: M_Status = 61;
pub const Status_StrictFIPS140: M_Status = 62;
pub const Status_UnknownStatus: M_Status = 63;
pub const Status_Cancelled: M_Status = 64;
pub const Status_UnsupportedChannelType: M_Status = 65;
pub const Status_ArithmeticError: M_Status = 66;
pub const Status_OpStackOverflow: M_Status = 67;
pub const Status_OpStackUnderflow: M_Status = 68;
pub const Status_NegativeResult: M_Status = 69;
pub const Status_HostDataInvalid: M_Status = 70;
pub const Status_HostDataAccessFailed: M_Status = 71;
pub const Status_NoUpcall: M_Status = 72;
pub const Status_NotAvailable: M_Status = 73;
pub const Status_MalformedCertificate: M_Status = 74;
pub const Status_InvalidCertificate: M_Status = 75;
pub const Status_ObjectNotReady: M_Status = 76;
pub const Status_BadMachineImage: M_Status = 77;
pub const Status_BadWorldImage: M_Status = 78;
pub const Status_SEEWorldFailed: M_Status = 79;
pub const Status_SoftwareFailed: M_Status = 80;
pub const Status_NoHostMemory: M_Status = 81;
pub const Status_NoModuleMemory: M_Status = 82;
pub const Status_IncorrectToken: M_Status = 83;
pub const Status_OperationFailed: M_Status = 84;
pub const Status_HostDataAccessDenied: M_Status = 86;
pub const Status_InvalidMergedKey: M_Status = 87;
pub const Status_AlreadyExists: M_Status = 88;
pub const Status_ReadOnly: M_Status = 89;
pub const Status_RemoteServerFailed: M_Status = 90;
pub const Status_SlotUnconnected: M_Status = 91;
pub const Status_NSTBadMessage: M_Status = 92;
pub const Status_nCErrno: M_Status = 93;
pub const Status_ImpathNotReady: M_Status = 94;
pub const Status_ImpathTimeLimitExceeded: M_Status = 95;
pub const Status_ImpathDataLimitExceeded: M_Status = 96;
pub const Status_ImpathReplay: M_Status = 97;
pub const Status_ImpathMsgTypeMismatch: M_Status = 98;
pub const Status_NoKXGroup: M_Status = 99;
pub const Status_ServerAccessDenied: M_Status = 100;
pub const Status_InProgress: M_Status = 101;
pub const Status_InvalidRM: M_Status = 102;
pub const Status_InvalidSlot: M_Status = 103;
pub const Status_UnknownPermID: M_Status = 104;
pub const Status_ForeignTokenLocked: M_Status = 105;
pub const Status_OperationTimeout: M_Status = 106;
pub const Status_SSLUnexpectedMessage: M_Status = 107;
pub const Status_SSLBadRecordMac: M_Status = 108;
pub const Status_SSLDecryptionFailed: M_Status = 109;
pub const Status_SSLRecordOverFlow: M_Status = 110;
pub const Status_SSLDecompressionFailure: M_Status = 111;
pub const Status_SSLHandshakeFailure: M_Status = 112;
pub const Status_SSLNoCertificate: M_Status = 113;
pub const Status_SSLBadCertificate: M_Status = 114;
pub const Status_SSLUnsupportedCertificate: M_Status = 115;
pub const Status_SSLCertificateRevoked: M_Status = 116;
pub const Status_SSLCertificateExpired: M_Status = 117;
pub const Status_SSLCertificateUnknown: M_Status = 118;
pub const Status_SSLIllegalParameter: M_Status = 119;
pub const Status_SSLUnknownCA: M_Status = 120;
pub const Status_SSLAccessDenied: M_Status = 121;
pub const Status_SSLDecodeError: M_Status = 122;
pub const Status_SSLDecryptError: M_Status = 123;
pub const Status_SSLExportRestriction: M_Status = 124;
pub const Status_SSLProtocolVersion: M_Status = 125;
pub const Status_SSLInsufficientSecurity: M_Status = 126;
pub const Status_SSLInternalError: M_Status = 127;
pub const Status_SSLUserCanceled: M_Status = 128;
pub const Status_SSLNoRenogotiation: M_Status = 129;
pub const Status_UnknownKey: M_Status = 130;
pub const Status_UserCancelled: M_Status = 131;
pub const Status_KeyNotLoaded: M_Status = 132;
pub const Status_HostUnknownKeyType: M_Status = 133;
pub const Status_IncorrectRepositoryName: M_Status = 134;
pub const Status_NoUsableModules: M_Status = 135;
pub const Status_InvalidHostDataIdentifier: M_Status = 136;
pub const Status_WorldUnusable: M_Status = 137;
pub const Status_MalformedPassphrase: M_Status = 138;
pub const Status_UnknownFileDevice: M_Status = 139;
pub const Status_TooManyLinks: M_Status = 140;
pub const Status_UseLimitsUnavailable: M_Status = 141;
pub const Status_Busy: M_Status = 142;
pub const Status_SecurityWorldFeatureDisabled: M_Status = 143;
pub const Status_ModuleNotUsable: M_Status = 144;
pub const Status_InappropriateObject: M_Status = 145;
pub const Status_InvalidImage: M_Status = 147;
pub const Status_InvalidModuleType: M_Status = 148;
pub const Status_RQCardUnwantedSlot: M_Status = 149;
pub const Status_RQCardUnwantedModule: M_Status = 150;
pub const Status_RQCardNeedPassphrase: M_Status = 151;
pub const Status_RQCardNeedConfirm: M_Status = 152;
pub const Status_RQCardUserCancelled: M_Status = 153;
pub const Status_RQCardMustContinue: M_Status = 154;
pub const Status_RQCardAlreadyProcessed: M_Status = 155;
pub const Status_UnknownHostVolume: M_Status = 156;
pub const Status_InvalidPathName: M_Status = 157;
pub const Status_InvalidFileName: M_Status = 158;
pub const Status_DeprecatedMechanism: M_Status = 159;
pub const Status_NetworkHSMUILockoutNotConfigured: M_Status = 160;
pub const Status_DboxEarlyExit: M_Status = 161;
pub const Status_CommandLocked: M_Status = 162;
pub const Status_CannotEncode: M_Status = 163;
pub const Status_DataOutstanding: M_Status = 164;
pub const Status_InvalidKeyType: M_Status = 176;
pub const Status_UnexpectedlyShallowNesting: M_Status = 177;
pub const Status_UnexpectedlyDeepNesting: M_Status = 178;
pub const Status_Accepted: M_Status = 179;
pub const Status_IncorrectKPSName: M_Status = 180;
pub const Status_UserAuthFailed: M_Status = 181;
pub const Status_UnknownKeyHashNEI: M_Status = 182;
pub const Status_TDMNotRegistered: M_Status = 183;
pub const Status_TDMNoSiblings: M_Status = 184;
pub const Status_IncorrectBlobFormat: M_Status = 185;
pub const Status_PythonException: M_Status = 186;
pub const Status_StreamOperationFailed: M_Status = 187;
pub const Status_SQLError: M_Status = 188;
pub const Status_SQLInternalError: M_Status = 189;
pub const Status_SQLInvalidHandle: M_Status = 190;
pub const Status_SQLNoSuchRow: M_Status = 191;
pub const Status_FragmentationError: M_Status = 192;
pub const Status_SEEJobRejected: M_Status = 193;
pub const Status_SeeHostcallProviderLock: M_Status = 194;
pub const Status_SeeHostcallProvisionFailed: M_Status = 195;
pub const Status_SeeStreamUnsupportedOperation: M_Status = 196;
pub const Status_SeeStreamInvalidDescriptor: M_Status = 197;
pub const Status_SeeStreamUnsupportedCreation: M_Status = 198;
pub const Status_SeeStreamUnexpectedResetErrorState: M_Status = 199;
pub const Status_RQCardTokenOperationFailed: M_Status = 200;
pub const Status_SeeHostcallProvisionLost: M_Status = 201;
pub const Status_DBINoRecord: M_Status = 202;
pub const Status_DBIOrphan: M_Status = 203;
pub const Status_DBIExists: M_Status = 204;
pub const Status_DBICorrupt: M_Status = 205;
pub const Status_DoesNotExist: M_Status = 206;
pub const Status_KPServerFailed: M_Status = 207;
pub const Status_KPSAuthorisationFailed: M_Status = 208;
pub const Status_SeeHostcallOperationFailed: M_Status = 209;
pub const Status_ConfigFileError: M_Status = 210;
pub const Status_SoftwareTooOld: M_Status = 211;
pub const Status_SEEWorldNotPresent: M_Status = 212;
pub const Status_UnknownESN: M_Status = 213;
pub const Status_InvalidKPReply: M_Status = 214;
pub const Status_KeyAlreadyExists: M_Status = 215;
pub const Status_IncorrectKeyStored: M_Status = 216;
pub const Status_NotManagementConnection: M_Status = 217;
pub const Status_GuardianNotStarted: M_Status = 218;
pub const Status_GuardianStarted: M_Status = 219;
pub const Status_GuardianNotSuspended: M_Status = 220;
pub const Status_GuardianSuspended: M_Status = 221;
pub const Status_GuardianDisabled: M_Status = 222;
pub const Status_GuardianNotMaster: M_Status = 223;
pub const Status_GuardianIsMaster: M_Status = 224;
pub const Status_GuardianStateTooOld: M_Status = 225;
pub const Status_InvalidCreateRegionParams: M_Status = 226;
pub const Status_UnknownRegion: M_Status = 227;
pub const Status_RegionAlreadyExists: M_Status = 228;
pub const Status_TrieInvalidPath: M_Status = 229;
pub const Status_TrieKeyPathInconsistent: M_Status = 230;
pub const Status_TrieInconsistentParameters: M_Status = 231;
pub const Status_TrieKeyMismatch: M_Status = 232;
pub const Status_DBITransactionLost: M_Status = 233;
pub const Status_UnrecoverableRegion: M_Status = 234;
pub const Status_UnknownEntityType: M_Status = 235;
pub const Status_InvalidEntityType: M_Status = 236;
pub const Status_InvalidObjspec: M_Status = 237;
pub const Status_CommandReplyMismatch: M_Status = 238;
pub const Status_ConflictingParameters: M_Status = 239;
pub const Status_DataMismatch: M_Status = 240;
pub const Status_UnknownGuardian: M_Status = 241;
pub const Status_NoActiveKey: M_Status = 242;
pub const Status_DataChangedDuringOperation: M_Status = 243;
pub const Status_NoGroupPermission: M_Status = 244;
pub const Status_DBIOutOfDate: M_Status = 245;
pub const Status_SQLConnectionLost: M_Status = 246;
pub const Status_SQLDeadlock: M_Status = 247;
pub const Status_UnknownFormat: M_Status = 248;
pub const Status_AppkeysetAlreadyExists: M_Status = 249;
pub const Status_DuplicateGroupEntry: M_Status = 250;
pub const Status_EntityAlreadyExists: M_Status = 251;
pub const Status_GroupAlreadyExists: M_Status = 252;
pub const Status_GroupPermissionAlreadyExists: M_Status = 253;
pub const Status_KeysetAlreadyExists: M_Status = 254;
pub const Status_NoSuchAppKeyset: M_Status = 255;
pub const Status_NoSuchEntityID: M_Status = 256;
pub const Status_NoSuchEntityName: M_Status = 257;
pub const Status_NoSuchGroup: M_Status = 258;
pub const Status_NoSuchGroupEntry: M_Status = 259;
pub const Status_NoSuchGroupPermission: M_Status = 260;
pub const Status_NoSuchKey: M_Status = 261;
pub const Status_NoSuchKeyset: M_Status = 262;
pub const Status_NoSuchKgdc: M_Status = 263;
pub const Status_UnknownEnrolID: M_Status = 264;
pub const Status_VerifyGuardianStateCertFailed: M_Status = 265;
pub const Status_VerifyKgdcCertFailed: M_Status = 266;
pub const Status_VerifyKgdiCertFailed: M_Status = 267;
pub const Status_VerifyKgkdcpCertFailed: M_Status = 268;
pub const Status_IncompatibleFormat: M_Status = 269;
pub const Status_TrieKeyNotFound: M_Status = 271;
pub const Status_TrieKeyAlreadyExists: M_Status = 272;
pub const Status_UnknownKPSName: M_Status = 273;
pub const Status_DBIResynchronize: M_Status = 274;
pub const Status_StrictFIPSSecurityLevel: M_Status = 275;
pub const Status_MalformedFlashTable: M_Status = 276;
pub const Status_GuardianIsOnStandby: M_Status = 277;
pub const Status_KPSConnectionLost: M_Status = 278;
pub const Status_KPSNoActiveMaster: M_Status = 279;
pub const Status_DBICorruptRecordHash: M_Status = 280;
pub const Status_DBICorruptOrderMismatch: M_Status = 281;
pub const Status_CertMissing: M_Status = 282;
pub const Status_TimeOutOfRange: M_Status = 283;
pub const Status_KPSServiceError: M_Status = 284;
pub const Status_CardNotLoaded: M_Status = 285;
pub const Status_UnknownDatabaseType: M_Status = 286;
pub const Status_KPSSigningKeyMismatch: M_Status = 287;
pub const Status_NoMastersConfigured: M_Status = 288;
pub const Status_NoModulesConfigured: M_Status = 289;
pub const Status_RTCWentBackwards: M_Status = 290;
pub const Status_NewKPSKeys: M_Status = 291;
pub const Status_StarterSystemLimitsExceeded: M_Status = 292;
pub const Status_InvalidDebugLogLevel: M_Status = 293;
pub const Status_ModuleApplicationNotSupported: M_Status = 294;
pub const Status_ModuleMonitorNotSupported: M_Status = 295;
pub const Status_InvalidWarrant: M_Status = 296;
pub const Status_InvalidWarrantRoot: M_Status = 297;
pub const Status_HostDeviceDriverNotSupported: M_Status = 298;
pub const Status_AlreadyConfigured: M_Status = 299;
pub const Status_NotYetConfigured: M_Status = 300;
pub const Status_ModuleNotWarranted: M_Status = 301;
pub const Status_TokenSecureChannelError: M_Status = 302;
pub const Status_TokenMessageError: M_Status = 303;
pub const Status_TooManyDynamicSlotOperations: M_Status = 304;
pub const Status_SynchronizationInitFailed: M_Status = 306;
pub const Status_TokenCommandTimeout: M_Status = 307;
pub const Status_UnlistedCard: M_Status = 308;
pub const Status_FrontPanelRemoteLocked: M_Status = 310;
pub const Status_RemoteLockoutModeNotConfigured: M_Status = 311;
pub const Status_CommandCannotHaveState: M_Status = 312;
pub const Status_NotPoolModule: M_Status = 313;
pub const Status_CommonCriteriaCMTSRestrictions: M_Status = 314;
pub const Status_TokenTransactionRolledBack: M_Status = 315;
pub const Status_TokenTransactionCorrupted: M_Status = 316;
pub const Status_ConnectionClosed: M_Status = 318;
pub const Status_TokenSecureChannelVersionError: M_Status = 321;
pub const Status_InvalidInterfaceName: M_Status = 322;
pub const Status_RTCNotSet: M_Status = 324;
pub const Status__Max: M_Status = 325;
pub type M_Status = ::core::ffi::c_uint;
pub const nCErrno_UNKNOWN: M_nCErrno = 1;
pub const nCErrno_EPERM: M_nCErrno = 2;
pub const nCErrno_ENOENT: M_nCErrno = 3;
pub const nCErrno_ESRCH: M_nCErrno = 4;
pub const nCErrno_EINTR: M_nCErrno = 5;
pub const nCErrno_EIO: M_nCErrno = 6;
pub const nCErrno_ENXIO: M_nCErrno = 7;
pub const nCErrno_E2BIG: M_nCErrno = 8;
pub const nCErrno_ENOEXEC: M_nCErrno = 9;
pub const nCErrno_EBADF: M_nCErrno = 10;
pub const nCErrno_ECHILD: M_nCErrno = 11;
pub const nCErrno_EAGAIN: M_nCErrno = 12;
pub const nCErrno_ENOMEM: M_nCErrno = 13;
pub const nCErrno_EACCES: M_nCErrno = 14;
pub const nCErrno_EFAULT: M_nCErrno = 15;
pub const nCErrno_ENOTBLK: M_nCErrno = 16;
pub const nCErrno_EBUSY: M_nCErrno = 17;
pub const nCErrno_EEXIST: M_nCErrno = 18;
pub const nCErrno_EXDEV: M_nCErrno = 19;
pub const nCErrno_ENODEV: M_nCErrno = 20;
pub const nCErrno_ENOTDIR: M_nCErrno = 21;
pub const nCErrno_EISDIR: M_nCErrno = 22;
pub const nCErrno_EINVAL: M_nCErrno = 23;
pub const nCErrno_ENFILE: M_nCErrno = 24;
pub const nCErrno_EMFILE: M_nCErrno = 25;
pub const nCErrno_ENOTTY: M_nCErrno = 26;
pub const nCErrno_ETXTBSY: M_nCErrno = 27;
pub const nCErrno_EFBIG: M_nCErrno = 28;
pub const nCErrno_ENOSPC: M_nCErrno = 29;
pub const nCErrno_ESPIPE: M_nCErrno = 30;
pub const nCErrno_EROFS: M_nCErrno = 31;
pub const nCErrno_EMLINK: M_nCErrno = 32;
pub const nCErrno_EPIPE: M_nCErrno = 33;
pub const nCErrno_EDOM: M_nCErrno = 34;
pub const nCErrno_ERANGE: M_nCErrno = 35;
pub const nCErrno_EDEADLK: M_nCErrno = 36;
pub const nCErrno_ENAMETOOLONG: M_nCErrno = 37;
pub const nCErrno_ENOLCK: M_nCErrno = 38;
pub const nCErrno_ENOSYS: M_nCErrno = 39;
pub const nCErrno_ENOTEMPTY: M_nCErrno = 40;
pub const nCErrno_ELOOP: M_nCErrno = 41;
pub const nCErrno_EWOULDBLOCK: M_nCErrno = 42;
pub const nCErrno_ENOMSG: M_nCErrno = 43;
pub const nCErrno_EIDRM: M_nCErrno = 44;
pub const nCErrno_EDEADLOCK: M_nCErrno = 45;
pub const nCErrno_EREMOTE: M_nCErrno = 46;
pub const nCErrno_EOVERFLOW: M_nCErrno = 47;
pub const nCErrno_EBADFD: M_nCErrno = 48;
pub const nCErrno_EILSEQ: M_nCErrno = 49;
pub const nCErrno_EUSERS: M_nCErrno = 50;
pub const nCErrno_ENOTSOCK: M_nCErrno = 51;
pub const nCErrno_EDESTADDRREQ: M_nCErrno = 52;
pub const nCErrno_EMSGSIZE: M_nCErrno = 53;
pub const nCErrno_EPROTOTYPE: M_nCErrno = 54;
pub const nCErrno_ENOPROTOOPT: M_nCErrno = 55;
pub const nCErrno_EPROTONOSUPPORT: M_nCErrno = 56;
pub const nCErrno_ESOCKTNOSUPPORT: M_nCErrno = 57;
pub const nCErrno_EOPNOTSUPP: M_nCErrno = 58;
pub const nCErrno_EPFNOSUPPORT: M_nCErrno = 59;
pub const nCErrno_EAFNOSUPPORT: M_nCErrno = 60;
pub const nCErrno_EADDRINUSE: M_nCErrno = 61;
pub const nCErrno_EADDRNOTAVAIL: M_nCErrno = 62;
pub const nCErrno_ENETDOWN: M_nCErrno = 63;
pub const nCErrno_ENETUNREACH: M_nCErrno = 64;
pub const nCErrno_ENETRESET: M_nCErrno = 65;
pub const nCErrno_ECONNABORTED: M_nCErrno = 66;
pub const nCErrno_ECONNRESET: M_nCErrno = 67;
pub const nCErrno_ENOBUFS: M_nCErrno = 68;
pub const nCErrno_EISCONN: M_nCErrno = 69;
pub const nCErrno_ENOTCONN: M_nCErrno = 70;
pub const nCErrno_ESHUTDOWN: M_nCErrno = 71;
pub const nCErrno_ETOOMANYREFS: M_nCErrno = 72;
pub const nCErrno_ETIMEDOUT: M_nCErrno = 73;
pub const nCErrno_ECONNREFUSED: M_nCErrno = 74;
pub const nCErrno_EHOSTDOWN: M_nCErrno = 75;
pub const nCErrno_EHOSTUNREACH: M_nCErrno = 76;
pub const nCErrno_EALREADY: M_nCErrno = 77;
pub const nCErrno_EINPROGRESS: M_nCErrno = 78;
pub const nCErrno_ESTALE: M_nCErrno = 79;
pub const nCErrno_EREMOTEIO: M_nCErrno = 80;
pub const nCErrno_EDQUOT: M_nCErrno = 81;
pub const nCErrno__Max: M_nCErrno = 82;
pub type M_nCErrno = ::core::ffi::c_uint;
pub const CrossModReason_ExplicitRequest: M_CrossModReason = 1;
pub const CrossModReason_Key: M_CrossModReason = 2;
pub const CrossModReason_Mode: M_CrossModReason = 4;
pub const CrossModReason_HardwareFailed: M_CrossModReason = 5;
pub const CrossModReason_UnitReset: M_CrossModReason = 6;
pub const CrossModReason_ServerKey: M_CrossModReason = 7;
pub const CrossModReason_ServerUnitReset: M_CrossModReason = 8;
pub const CrossModReason_NotPresent: M_CrossModReason = 9;
pub const CrossModReason_NToken: M_CrossModReason = 11;
pub const CrossModReason_NetworkError: M_CrossModReason = 12;
pub const CrossModReason_NoPoolModuleSupport: M_CrossModReason = 13;
pub const CrossModReason__Max: M_CrossModReason = 14;
pub type M_CrossModReason = ::core::ffi::c_uint;
pub const NetworkAddressFamily_INET: M_NetworkAddressFamily = 2;
pub const NetworkAddressFamily_INET6: M_NetworkAddressFamily = 10;
pub const NetworkAddressFamily_HOST: M_NetworkAddressFamily = 19;
pub const NetworkAddressFamily__Max: M_NetworkAddressFamily = 20;
pub type M_NetworkAddressFamily = ::core::ffi::c_uint;
pub const KeyHashMech_SHA1Hash: M_KeyHashMech = 44;
pub const KeyHashMech_SHA256Hash: M_KeyHashMech = 93;
pub const KeyHashMech_SHA512Hash: M_KeyHashMech = 95;
pub const KeyHashMech__Max: M_KeyHashMech = 96;
pub type M_KeyHashMech = ::core::ffi::c_uint;
pub const SlotType_Unknown: M_SlotType = 0;
pub const SlotType_DataKey: M_SlotType = 1;
pub const SlotType_SmartCard: M_SlotType = 2;
pub const SlotType_Emulated: M_SlotType = 3;
pub const SlotType_SoftToken: M_SlotType = 4;
pub const SlotType_Unconnected: M_SlotType = 5;
pub const SlotType__Max: M_SlotType = 6;
pub type M_SlotType = ::core::ffi::c_uint;
pub const PlainTextType_Bytes: M_PlainTextType = 1;
pub const PlainTextType_Hash: M_PlainTextType = 2;
pub const PlainTextType_Bignum: M_PlainTextType = 3;
pub const PlainTextType_Hash16: M_PlainTextType = 4;
pub const PlainTextType_ECPoint: M_PlainTextType = 5;
pub const PlainTextType_Hash24: M_PlainTextType = 6;
pub const PlainTextType_Hash32: M_PlainTextType = 7;
pub const PlainTextType_Hash48: M_PlainTextType = 8;
pub const PlainTextType_Hash64: M_PlainTextType = 9;
pub const PlainTextType_Hash28: M_PlainTextType = 10;
pub const PlainTextType__Max: M_PlainTextType = 11;
pub type M_PlainTextType = ::core::ffi::c_uint;
pub const ChannelType_Any: M_ChannelType = 0;
pub const ChannelType_Simple: M_ChannelType = 1;
pub const ChannelType__Max: M_ChannelType = 2;
pub type M_ChannelType = ::core::ffi::c_uint;
pub const ChannelMode_Encrypt: M_ChannelMode = 1;
pub const ChannelMode_Decrypt: M_ChannelMode = 2;
pub const ChannelMode_Sign: M_ChannelMode = 3;
pub const ChannelMode_Verify: M_ChannelMode = 4;
pub const ChannelMode__Max: M_ChannelMode = 5;
pub type M_ChannelMode = ::core::ffi::c_uint;
pub const CertType_Invalid: M_CertType = 0;
pub const CertType_SigningKey: M_CertType = 1;
pub const CertType_SingleCert: M_CertType = 2;
pub const CertType_SEECert: M_CertType = 3;
pub const CertType__Max: M_CertType = 4;
pub type M_CertType = ::core::ffi::c_uint;
pub const KeyType_Any: M_KeyType = 0;
pub const KeyType_RSAPublic: M_KeyType = 1;
pub const KeyType_RSAPrivate: M_KeyType = 2;
pub const KeyType_DSAPublic: M_KeyType = 3;
pub const KeyType_DHPublic: M_KeyType = 5;
pub const KeyType_DHPrivate: M_KeyType = 6;
pub const KeyType_Random: M_KeyType = 7;
pub const KeyType_DES: M_KeyType = 11;
pub const KeyType_DES3: M_KeyType = 12;
pub const KeyType_None: M_KeyType = 13;
pub const KeyType_ArcFour: M_KeyType = 15;
pub const KeyType_CAST: M_KeyType = 18;
pub const KeyType_DSAPrivate: M_KeyType = 19;
pub const KeyType_DSAComm: M_KeyType = 20;
pub const KeyType_Void: M_KeyType = 21;
pub const KeyType_Wrapped: M_KeyType = 23;
pub const KeyType_DKTemplate: M_KeyType = 24;
pub const KeyType_HMACMD5: M_KeyType = 26;
pub const KeyType_HMACSHA1: M_KeyType = 27;
pub const KeyType_HMACRIPEMD160: M_KeyType = 28;
pub const KeyType_Serpent: M_KeyType = 29;
pub const KeyType_Rijndael: M_KeyType = 30;
pub const KeyType_Twofish: M_KeyType = 31;
pub const KeyType_CAST256: M_KeyType = 32;
pub const KeyType_Blowfish: M_KeyType = 33;
pub const KeyType_HMACSHA256: M_KeyType = 34;
pub const KeyType_HMACSHA384: M_KeyType = 35;
pub const KeyType_HMACSHA512: M_KeyType = 36;
pub const KeyType_HMACTiger: M_KeyType = 37;
pub const KeyType_KCDSAPublic: M_KeyType = 39;
pub const KeyType_KCDSAPrivate: M_KeyType = 40;
pub const KeyType_DES2: M_KeyType = 41;
pub const KeyType_KCDSAComm: M_KeyType = 42;
pub const KeyType_SEED: M_KeyType = 43;
pub const KeyType_ECPublic: M_KeyType = 44;
pub const KeyType_ECPrivate: M_KeyType = 45;
pub const KeyType_ECDSAPublic: M_KeyType = 46;
pub const KeyType_ECDSAPrivate: M_KeyType = 47;
pub const KeyType_ECDHPrivate: M_KeyType = 48;
pub const KeyType_ECDHPublic: M_KeyType = 49;
pub const KeyType_HMACSHA224: M_KeyType = 50;
pub const KeyType_ARIA: M_KeyType = 51;
pub const KeyType_Camellia: M_KeyType = 52;
pub const KeyType_ECDHLaxPrivate: M_KeyType = 53;
pub const KeyType_ECDHLaxPublic: M_KeyType = 54;
pub const KeyType_DSACommVariableSeed: M_KeyType = 55;
pub const KeyType_DSACommFIPS186_3: M_KeyType = 56;
pub const KeyType_X25519Public: M_KeyType = 59;
pub const KeyType_X25519Private: M_KeyType = 60;
pub const KeyType_HMACSHA3b224: M_KeyType = 61;
pub const KeyType_HMACSHA3b256: M_KeyType = 62;
pub const KeyType_HMACSHA3b384: M_KeyType = 63;
pub const KeyType_HMACSHA3b512: M_KeyType = 64;
pub const KeyType_Ed25519Public: M_KeyType = 65;
pub const KeyType_Ed25519Private: M_KeyType = 66;
pub const KeyType_TUAKSubscriber: M_KeyType = 67;
pub const KeyType_TUAKTOP: M_KeyType = 68;
pub const KeyType_TUAKTOPC: M_KeyType = 69;
pub const KeyType_DHExPublic: M_KeyType = 73;
pub const KeyType_DHExPrivate: M_KeyType = 74;
pub const KeyType_KMAC128: M_KeyType = 75;
pub const KeyType_KMAC256: M_KeyType = 76;
pub const KeyType_MILENAGEOP: M_KeyType = 77;
pub const KeyType_MILENAGEOPC: M_KeyType = 78;
pub const KeyType_MILENAGESubscriber: M_KeyType = 79;
pub const KeyType_MILENAGERC: M_KeyType = 80;
pub const KeyType__Max: M_KeyType = 81;
pub type M_KeyType = ::core::ffi::c_uint;
pub const ECName_Custom: M_ECName = 1;
pub const ECName_NISTP192: M_ECName = 2;
pub const ECName_NISTP224: M_ECName = 3;
pub const ECName_NISTP256: M_ECName = 4;
pub const ECName_NISTP384: M_ECName = 5;
pub const ECName_NISTP521: M_ECName = 6;
pub const ECName_NISTB163: M_ECName = 7;
pub const ECName_NISTB233: M_ECName = 8;
pub const ECName_NISTB283: M_ECName = 9;
pub const ECName_NISTB409: M_ECName = 10;
pub const ECName_NISTB571: M_ECName = 11;
pub const ECName_NISTK163: M_ECName = 12;
pub const ECName_NISTK233: M_ECName = 13;
pub const ECName_NISTK283: M_ECName = 14;
pub const ECName_NISTK409: M_ECName = 15;
pub const ECName_NISTK571: M_ECName = 16;
pub const ECName_ANSIB163v1: M_ECName = 17;
pub const ECName_ANSIB191v1: M_ECName = 18;
pub const ECName_SECP160r1: M_ECName = 19;
pub const ECName_CustomLCF: M_ECName = 20;
pub const ECName_SECP256k1: M_ECName = 22;
pub const ECName_BrainpoolP160r1: M_ECName = 23;
pub const ECName_BrainpoolP160t1: M_ECName = 24;
pub const ECName_BrainpoolP192r1: M_ECName = 25;
pub const ECName_BrainpoolP192t1: M_ECName = 26;
pub const ECName_BrainpoolP224r1: M_ECName = 27;
pub const ECName_BrainpoolP224t1: M_ECName = 28;
pub const ECName_BrainpoolP256r1: M_ECName = 29;
pub const ECName_BrainpoolP256t1: M_ECName = 30;
pub const ECName_BrainpoolP320r1: M_ECName = 31;
pub const ECName_BrainpoolP320t1: M_ECName = 32;
pub const ECName_BrainpoolP384r1: M_ECName = 33;
pub const ECName_BrainpoolP384t1: M_ECName = 34;
pub const ECName_BrainpoolP512r1: M_ECName = 35;
pub const ECName_BrainpoolP512t1: M_ECName = 36;
pub const ECName__Max: M_ECName = 37;
pub type M_ECName = ::core::ffi::c_uint;
pub const FieldType_Prime: M_FieldType = 1;
pub const FieldType_Binary: M_FieldType = 2;
pub const FieldType_NISTfP192: M_FieldType = 3;
pub const FieldType_NISTfP224: M_FieldType = 4;
pub const FieldType_NISTfP256: M_FieldType = 5;
pub const FieldType_NISTfP384: M_FieldType = 6;
pub const FieldType_NISTfP521: M_FieldType = 7;
pub const FieldType_NISTfB163: M_FieldType = 8;
pub const FieldType_NISTfB233: M_FieldType = 9;
pub const FieldType_NISTfB283: M_FieldType = 10;
pub const FieldType_NISTfB409: M_FieldType = 11;
pub const FieldType_NISTfB571: M_FieldType = 12;
pub const FieldType_ANSIfB163: M_FieldType = 13;
pub const FieldType_ANSIfB191: M_FieldType = 14;
pub const FieldType_SECfP160: M_FieldType = 15;
pub const FieldType_SECP256k1: M_FieldType = 17;
pub const FieldType_BrainpoolP160: M_FieldType = 18;
pub const FieldType_BrainpoolP224: M_FieldType = 19;
pub const FieldType_BrainpoolP256: M_FieldType = 20;
pub const FieldType_BrainpoolP320: M_FieldType = 21;
pub const FieldType_BrainpoolP384: M_FieldType = 22;
pub const FieldType_BrainpoolP512: M_FieldType = 23;
pub const FieldType_BrainpoolP192: M_FieldType = 24;
pub const FieldType__Max: M_FieldType = 25;
pub type M_FieldType = ::core::ffi::c_uint;
pub const Mech_Any: M_Mech = 0;
pub const Mech_DESmCBCi64pPKCS5: M_Mech = 1;
pub const Mech_RSApPKCS1: M_Mech = 2;
pub const Mech_DESmECBpPKCS5: M_Mech = 7;
pub const Mech_DSA: M_Mech = 10;
pub const Mech_ArcFourpNONE: M_Mech = 11;
pub const Mech_DESmCBCMACi64pPKCS5: M_Mech = 17;
pub const Mech_CASTmCBCi64pPKCS5: M_Mech = 19;
pub const Mech_CASTmECBpPKCS5: M_Mech = 20;
pub const Mech_CASTmCBCMACi64pPKCS5: M_Mech = 21;
pub const Mech_DESmECBpNONE: M_Mech = 22;
pub const Mech_DESmCBCpNONE: M_Mech = 24;
pub const Mech_DHKeyExchange: M_Mech = 26;
pub const Mech_ElGamal: M_Mech = 27;
pub const Mech_CASTmECBpNONE: M_Mech = 29;
pub const Mech_CASTmCBCpNONE: M_Mech = 32;
pub const Mech_Generic64: M_Mech = 34;
pub const Mech_Generic64MAC: M_Mech = 35;
pub const Mech_DES3mCBCi64pPKCS5: M_Mech = 37;
pub const Mech_DES3mECBpPKCS5: M_Mech = 38;
pub const Mech_DES3mCBCMACi64pPKCS5: M_Mech = 39;
pub const Mech_DES3mECBpNONE: M_Mech = 40;
pub const Mech_DES3mCBCpNONE: M_Mech = 41;
pub const Mech_SHA1Hash: M_Mech = 44;
pub const Mech_MD5Hash: M_Mech = 45;
pub const Mech_RIPEMD160Hash: M_Mech = 52;
pub const Mech_HMACMD5: M_Mech = 54;
pub const Mech_HMACSHA1: M_Mech = 55;
pub const Mech_HMACRIPEMD160: M_Mech = 56;
pub const Mech_RSAhMD5pPKCS1: M_Mech = 58;
pub const Mech_RSAhSHA1pPKCS1: M_Mech = 59;
pub const Mech_RSAhRIPEMD160pPKCS1: M_Mech = 60;
pub const Mech_RSApPKCS1OAEP: M_Mech = 61;
pub const Mech_Generic128: M_Mech = 62;
pub const Mech_Generic128MAC: M_Mech = 63;
pub const Mech_Generic192: M_Mech = 64;
pub const Mech_Generic256: M_Mech = 66;
pub const Mech_SerpentmCBCi128pPKCS5: M_Mech = 68;
pub const Mech_SerpentmECBpPKCS5: M_Mech = 69;
pub const Mech_SerpentmCBCpNONE: M_Mech = 70;
pub const Mech_SerpentmECBpNONE: M_Mech = 71;
pub const Mech_SerpentmCBCMACi128pPKCS5: M_Mech = 72;
pub const Mech_RijndaelmCBCi128pPKCS5: M_Mech = 73;
pub const Mech_RijndaelmECBpPKCS5: M_Mech = 74;
pub const Mech_RijndaelmCBCpNONE: M_Mech = 75;
pub const Mech_RijndaelmECBpNONE: M_Mech = 76;
pub const Mech_RijndaelmCBCMACi128pPKCS5: M_Mech = 77;
pub const Mech_TwofishmCBCi128pPKCS5: M_Mech = 78;
pub const Mech_TwofishmECBpPKCS5: M_Mech = 79;
pub const Mech_TwofishmCBCpNONE: M_Mech = 80;
pub const Mech_TwofishmECBpNONE: M_Mech = 81;
pub const Mech_TwofishmCBCMACi128pPKCS5: M_Mech = 82;
pub const Mech_CAST256mCBCi128pPKCS5: M_Mech = 83;
pub const Mech_CAST256mECBpPKCS5: M_Mech = 84;
pub const Mech_CAST256mCBCpNONE: M_Mech = 85;
pub const Mech_CAST256mECBpNONE: M_Mech = 86;
pub const Mech_CAST256mCBCMACi128pPKCS5: M_Mech = 87;
pub const Mech_BlowfishmCBCi64pPKCS5: M_Mech = 88;
pub const Mech_BlowfishmECBpPKCS5: M_Mech = 89;
pub const Mech_BlowfishmCBCpNONE: M_Mech = 90;
pub const Mech_BlowfishmECBpNONE: M_Mech = 91;
pub const Mech_BlowfishmCBCMACi64pPKCS5: M_Mech = 92;
pub const Mech_SHA256Hash: M_Mech = 93;
pub const Mech_SHA384Hash: M_Mech = 94;
pub const Mech_SHA512Hash: M_Mech = 95;
pub const Mech_TigerHash: M_Mech = 96;
pub const Mech_HMACSHA256: M_Mech = 97;
pub const Mech_HMACSHA384: M_Mech = 98;
pub const Mech_HMACSHA512: M_Mech = 99;
pub const Mech_HMACTiger: M_Mech = 100;
pub const Mech_Imech: M_Mech = 101;
pub const Mech_DES3wSHA1: M_Mech = 102;
pub const Mech_DES3wCRC32: M_Mech = 103;
pub const Mech_HAS160Hash: M_Mech = 109;
pub const Mech_KCDSAHAS160: M_Mech = 110;
pub const Mech_KCDSASHA1: M_Mech = 111;
pub const Mech_KCDSARIPEMD160: M_Mech = 112;
pub const Mech_DES2mCBCi64pPKCS5: M_Mech = 113;
pub const Mech_DES2mCBCpNONE: M_Mech = 114;
pub const Mech_DES2mECBpPKCS5: M_Mech = 115;
pub const Mech_DES2mCBCMACi64pPKCS5: M_Mech = 116;
pub const Mech_DES2mECBpNONE: M_Mech = 117;
pub const Mech_RSApPKCS1pPKCS11: M_Mech = 118;
pub const Mech_SEEDmECBpNONE: M_Mech = 119;
pub const Mech_SEEDmECBpPKCS5: M_Mech = 120;
pub const Mech_SEEDmCBCpNONE: M_Mech = 121;
pub const Mech_SEEDmCBCi128pPKCS5: M_Mech = 122;
pub const Mech_SEEDmCBCMACi128pPKCS5: M_Mech = 123;
pub const Mech_DLIESe3DEShSHA1: M_Mech = 124;
pub const Mech_DLIESeAEShSHA1: M_Mech = 125;
pub const Mech_DESmCBCMACi0pPKCS5: M_Mech = 130;
pub const Mech_CASTmCBCMACi0pPKCS5: M_Mech = 131;
pub const Mech_DES3mCBCMACi0pPKCS5: M_Mech = 132;
pub const Mech_BlowfishmCBCMACi0pPKCS5: M_Mech = 134;
pub const Mech_DES2mCBCMACi0pPKCS5: M_Mech = 135;
pub const Mech_SerpentmCBCMACi0pPKCS5: M_Mech = 136;
pub const Mech_RijndaelmCBCMACi0pPKCS5: M_Mech = 137;
pub const Mech_TwofishmCBCMACi0pPKCS5: M_Mech = 138;
pub const Mech_CAST256mCBCMACi0pPKCS5: M_Mech = 139;
pub const Mech_SEEDmCBCMACi0pPKCS5: M_Mech = 140;
pub const Mech_BlobCryptv2kHasheRijndaelCBC0hSHA1mSHA1HMAC: M_Mech = 141;
pub const Mech_BlobCryptv2kRSAeRijndaelCBC0hSHA1mSHA1HMAC: M_Mech = 142;
pub const Mech_BlobCryptv2kDHeRijndaelCBC0hSHA1mSHA1HMAC: M_Mech = 143;
pub const Mech_BlobCrypt: M_Mech = 144;
pub const Mech_BlobCryptv2kHasheDES3CBC0hSHA1mSHA1HMAC: M_Mech = 145;
pub const Mech_BlobCryptv2kRSAeDES3CBC0hSHA1mSHA1HMAC: M_Mech = 146;
pub const Mech_BlobCryptv2kDHeDES3CBC0hSHA1mSHA1HMAC: M_Mech = 147;
pub const Mech_BlobCryptv2kHasheRijndaelCBC0hSHA256mSHA256HMAC: M_Mech = 148;
pub const Mech_BlobCryptv2kRSAeRijndaelCBC0hSHA256mSHA256HMAC: M_Mech = 149;
pub const Mech_BlobCryptv2kDHeRijndaelCBC0hSHA256mSHA256HMAC: M_Mech = 150;
pub const Mech_BlobCryptv2kHasheRijndaelCBC0hSHA512mSHA512HMAC: M_Mech = 151;
pub const Mech_BlobCryptv2kRSAeRijndaelCBC0hSHA512mSHA512HMAC: M_Mech = 152;
pub const Mech_BlobCryptv2kDHeRijndaelCBC0hSHA512mSHA512HMAC: M_Mech = 153;
pub const Mech_ECDSA: M_Mech = 154;
pub const Mech_ECDHKeyExchange: M_Mech = 155;
pub const Mech_DESmCBCMACi0pNONE: M_Mech = 156;
pub const Mech_DES2mCBCMACi0pNONE: M_Mech = 157;
pub const Mech_DES3mCBCMACi0pNONE: M_Mech = 158;
pub const Mech_RijndaelmCBCMACi0pNONE: M_Mech = 159;
pub const Mech_RSAhSHA1pPSS: M_Mech = 160;
pub const Mech_RSAhSHA256pPSS: M_Mech = 161;
pub const Mech_RSAhSHA384pPSS: M_Mech = 162;
pub const Mech_RSAhSHA512pPSS: M_Mech = 163;
pub const Mech_RSAhSHA256pPKCS1: M_Mech = 164;
pub const Mech_RSAhSHA384pPKCS1: M_Mech = 165;
pub const Mech_RSAhSHA512pPKCS1: M_Mech = 166;
pub const Mech_SHA224Hash: M_Mech = 167;
pub const Mech_HMACSHA224: M_Mech = 168;
pub const Mech_DSAhSHA224: M_Mech = 169;
pub const Mech_DSAhSHA256: M_Mech = 170;
pub const Mech_DSAhSHA384: M_Mech = 171;
pub const Mech_DSAhSHA512: M_Mech = 172;
pub const Mech_RSAhSHA224pPSS: M_Mech = 173;
pub const Mech_RSAhSHA224pPKCS1: M_Mech = 174;
pub const Mech_ARIAmCBCpNONE: M_Mech = 175;
pub const Mech_ARIAmECBpNONE: M_Mech = 176;
pub const Mech_RijndaelmCMAC: M_Mech = 177;
pub const Mech_GenericGCM128: M_Mech = 178;
pub const Mech_RijndaelmGCM: M_Mech = 179;
pub const Mech_KCDSASHA224: M_Mech = 180;
pub const Mech_KCDSASHA256: M_Mech = 181;
pub const Mech_ECDSAhSHA224: M_Mech = 184;
pub const Mech_ECDSAhSHA256: M_Mech = 185;
pub const Mech_ECDSAhSHA384: M_Mech = 186;
pub const Mech_ECDSAhSHA512: M_Mech = 187;
pub const Mech_CamelliamCBCpNONE: M_Mech = 188;
pub const Mech_CamelliamECBpNONE: M_Mech = 189;
pub const Mech_ECDHLaxKeyExchange: M_Mech = 190;
pub const Mech_RSAhRIPEMD160pPSS: M_Mech = 191;
pub const Mech_ECDSAhRIPEMD160: M_Mech = 192;
pub const Mech_DSAhRIPEMD160: M_Mech = 193;
pub const Mech_RSApPKCS1OAEPhSHA224: M_Mech = 195;
pub const Mech_RSApPKCS1OAEPhSHA256: M_Mech = 196;
pub const Mech_RSApPKCS1OAEPhSHA384: M_Mech = 197;
pub const Mech_RSApPKCS1OAEPhSHA512: M_Mech = 198;
pub const Mech_SEEDmCBCMACi0pNONE: M_Mech = 203;
pub const Mech_ECDSAhSHA256kGBCS: M_Mech = 204;
pub const Mech_SHA3b224Hash: M_Mech = 205;
pub const Mech_SHA3b256Hash: M_Mech = 206;
pub const Mech_SHA3b384Hash: M_Mech = 207;
pub const Mech_SHA3b512Hash: M_Mech = 208;
pub const Mech_HMACSHA3b224: M_Mech = 211;
pub const Mech_HMACSHA3b256: M_Mech = 212;
pub const Mech_HMACSHA3b384: M_Mech = 213;
pub const Mech_HMACSHA3b512: M_Mech = 214;
pub const Mech_Ed25519ph: M_Mech = 217;
pub const Mech_X25519KeyExchange: M_Mech = 218;
pub const Mech_Ed25519: M_Mech = 219;
pub const Mech_BlobCryptv3kNoneeAESCBC0dCTRCMACmSHA256HMAC: M_Mech = 222;
pub const Mech_BlobCryptv3kRSAOAEPeAESCBC0dCTRCMACmSHA256HMAC: M_Mech = 223;
pub const Mech_BlobCryptv3kNoneeAESCBC0dCTRCMACmSHA512HMAC: M_Mech = 224;
pub const Mech_BlobCryptv3kRSAOAEPeAESCBC0dCTRCMACmSHA512HMAC: M_Mech = 225;
pub const Mech_DHExKeyExchange: M_Mech = 226;
pub const Mech_DLIESeAEShSHA1DHEx: M_Mech = 227;
pub const Mech_AESKeyWrapPadded: M_Mech = 228;
pub const Mech_ECDHCKeyExchange: M_Mech = 229;
pub const Mech_KMAC128: M_Mech = 230;
pub const Mech_KMAC256: M_Mech = 231;
pub const Mech_AESmGCM: M_Mech = 232;
pub const Mech_None: M_Mech = 233;
pub const Mech_RSAhSHA3b224pPKCS1: M_Mech = 234;
pub const Mech_RSAhSHA3b256pPKCS1: M_Mech = 235;
pub const Mech_RSAhSHA3b384pPKCS1: M_Mech = 236;
pub const Mech_RSAhSHA3b512pPKCS1: M_Mech = 237;
pub const Mech_RSAhSHA3b224pPSS: M_Mech = 238;
pub const Mech_RSAhSHA3b256pPSS: M_Mech = 239;
pub const Mech_RSAhSHA3b384pPSS: M_Mech = 240;
pub const Mech_RSAhSHA3b512pPSS: M_Mech = 241;
pub const Mech_RSApPKCS1OAEPhSHA3b224: M_Mech = 242;
pub const Mech_RSApPKCS1OAEPhSHA3b256: M_Mech = 243;
pub const Mech_RSApPKCS1OAEPhSHA3b384: M_Mech = 244;
pub const Mech_RSApPKCS1OAEPhSHA3b512: M_Mech = 245;
pub const Mech_ECDSAhSHA3b224: M_Mech = 256;
pub const Mech_ECDSAhSHA3b256: M_Mech = 257;
pub const Mech_ECDSAhSHA3b384: M_Mech = 258;
pub const Mech_ECDSAhSHA3b512: M_Mech = 259;
pub const Mech_ARIAmCBCi128pPKCS5: M_Mech = 260;
pub const Mech_ARIAmECBpPKCS5: M_Mech = 261;
pub const Mech_ARIAmCBCMACi0pPKCS5: M_Mech = 262;
pub const Mech_ARIAmCBCMACi0pNONE: M_Mech = 263;
pub const Mech__Max: M_Mech = 264;
pub type M_Mech = ::core::ffi::c_uint;
pub const FileDevice_PhysToken: M_FileDevice = 1;
pub const FileDevice_NVMem: M_FileDevice = 2;
pub const FileDevice_NVMemPersist: M_FileDevice = 3;
pub const FileDevice__Max: M_FileDevice = 4;
pub type M_FileDevice = ::core::ffi::c_uint;
pub const BlobFormat_None: M_BlobFormat = 0;
pub const BlobFormat_Module: M_BlobFormat = 5;
pub const BlobFormat_Token: M_BlobFormat = 6;
pub const BlobFormat_Direct: M_BlobFormat = 7;
pub const BlobFormat_Indirect: M_BlobFormat = 8;
pub const BlobFormat_UserKey: M_BlobFormat = 9;
pub const BlobFormat__Max: M_BlobFormat = 10;
pub type M_BlobFormat = ::core::ffi::c_uint;
pub const DeriveMech_Any: M_DeriveMech = 0;
pub const DeriveMech_DESsplitXOR: M_DeriveMech = 1;
pub const DeriveMech_DESjoinXOR: M_DeriveMech = 2;
pub const DeriveMech_DES3splitXOR: M_DeriveMech = 3;
pub const DeriveMech_DES3joinXOR: M_DeriveMech = 4;
pub const DeriveMech_DESjoinXORsetParity: M_DeriveMech = 5;
pub const DeriveMech_DES3joinXORsetParity: M_DeriveMech = 6;
pub const DeriveMech_RandsplitXOR: M_DeriveMech = 7;
pub const DeriveMech_RandjoinXOR: M_DeriveMech = 8;
pub const DeriveMech_CASTsplitXOR: M_DeriveMech = 9;
pub const DeriveMech_CASTjoinXOR: M_DeriveMech = 10;
pub const DeriveMech_EncryptMarshalled: M_DeriveMech = 11;
pub const DeriveMech_DecryptMarshalled: M_DeriveMech = 12;
pub const DeriveMech_SSL3withRSA: M_DeriveMech = 13;
pub const DeriveMech_TLSwithRSA: M_DeriveMech = 14;
pub const DeriveMech_SSL3withDH: M_DeriveMech = 15;
pub const DeriveMech_TLSwithDH: M_DeriveMech = 16;
pub const DeriveMech_RawEncrypt: M_DeriveMech = 17;
pub const DeriveMech_RawDecrypt: M_DeriveMech = 18;
pub const DeriveMech_DES2splitXOR: M_DeriveMech = 19;
pub const DeriveMech_DES2joinXOR: M_DeriveMech = 20;
pub const DeriveMech_DES2joinXORsetParity: M_DeriveMech = 21;
pub const DeriveMech_PKCS8Encrypt: M_DeriveMech = 22;
pub const DeriveMech_PKCS8Decrypt: M_DeriveMech = 23;
pub const DeriveMech_RSAComponents: M_DeriveMech = 24;
pub const DeriveMech_KDPKeyWrapDES3: M_DeriveMech = 25;
pub const DeriveMech_AESsplitXOR: M_DeriveMech = 26;
pub const DeriveMech_AESjoinXOR: M_DeriveMech = 27;
pub const DeriveMech_SignedKDPKeyWrapDES3: M_DeriveMech = 28;
pub const DeriveMech_PublicFromPrivate: M_DeriveMech = 29;
pub const DeriveMech_ECCMQV: M_DeriveMech = 30;
pub const DeriveMech_ConcatenateBytes: M_DeriveMech = 31;
pub const DeriveMech_ConcatenationKDF: M_DeriveMech = 32;
pub const DeriveMech_NISTKDFmCTRpRijndaelCMACr32: M_DeriveMech = 33;
pub const DeriveMech_RawEncryptZeroPad: M_DeriveMech = 34;
pub const DeriveMech_RawDecryptZeroPad: M_DeriveMech = 35;
pub const DeriveMech_AESKeyWrap: M_DeriveMech = 36;
pub const DeriveMech_AESKeyUnwrap: M_DeriveMech = 37;
pub const DeriveMech_PKCS8DecryptEx: M_DeriveMech = 38;
pub const DeriveMech_CompositeWatchWordVerify: M_DeriveMech = 39;
pub const DeriveMech_CompositeWatchWordSign: M_DeriveMech = 40;
pub const DeriveMech_CompositeARQCVerify: M_DeriveMech = 41;
pub const DeriveMech_HyperledgerClient: M_DeriveMech = 43;
pub const DeriveMech_ECDHKA: M_DeriveMech = 46;
pub const DeriveMech_ECIESKeyWrap: M_DeriveMech = 47;
pub const DeriveMech_ECIESKeyUnwrap: M_DeriveMech = 48;
pub const DeriveMech_NISTKDFmCTRr8: M_DeriveMech = 49;
pub const DeriveMech_ECCMQVdNISTCKDF: M_DeriveMech = 50;
pub const DeriveMech_TUAKTOPC: M_DeriveMech = 51;
pub const DeriveMech_DHKA: M_DeriveMech = 56;
pub const DeriveMech_X25519KA: M_DeriveMech = 57;
pub const DeriveMech_TestKX: M_DeriveMech = 58;
pub const DeriveMech_GenerateRSAB36: M_DeriveMech = 59;
pub const DeriveMech_RSAKeyUnwrap: M_DeriveMech = 60;
pub const DeriveMech_RSAKeyWrap: M_DeriveMech = 61;
pub const DeriveMech_RawSign: M_DeriveMech = 62;
pub const DeriveMech_MILENAGEOPC: M_DeriveMech = 63;
pub const DeriveMech_MILENAGEAV: M_DeriveMech = 64;
pub const DeriveMech_MILENAGEResync: M_DeriveMech = 65;
pub const DeriveMech_MILENAGEGenAUTS: M_DeriveMech = 66;
pub const DeriveMech_TUAKAV: M_DeriveMech = 67;
pub const DeriveMech_TUAKGenAUTS: M_DeriveMech = 68;
pub const DeriveMech_TUAKResync: M_DeriveMech = 69;
pub const DeriveMech_RawEncryptUnsafe: M_DeriveMech = 70;
pub const DeriveMech_RawEncryptZeroPadUnsafe: M_DeriveMech = 71;
pub const DeriveMech_PKCS8EncryptUnsafe: M_DeriveMech = 72;
pub const DeriveMech__Max: M_DeriveMech = 73;
pub type M_DeriveMech = ::core::ffi::c_uint;
pub const ARQCScheme_EMV2000: M_ARQCScheme = 1;
pub const ARQCScheme_EMV2004: M_ARQCScheme = 2;
pub const ARQCScheme_MCHIP21: M_ARQCScheme = 3;
pub const ARQCScheme_VIS10: M_ARQCScheme = 4;
pub const ARQCScheme_VIS10TDS: M_ARQCScheme = 5;
pub const ARQCScheme_MCHIP21TDS: M_ARQCScheme = 6;
pub const ARQCScheme_VIS18: M_ARQCScheme = 7;
pub const ARQCScheme_VIS18TDS: M_ARQCScheme = 8;
pub const ARQCScheme_VIS22: M_ARQCScheme = 9;
pub const ARQCScheme_VIS22TDS: M_ARQCScheme = 10;
pub const ARQCScheme__Max: M_ARQCScheme = 11;
pub type M_ARQCScheme = ::core::ffi::c_uint;
pub const KAPrimitive_Any: M_KAPrimitive = 0;
pub const KAPrimitive_ECDHdKDF2: M_KAPrimitive = 1;
pub const KAPrimitive_ECDHCdKDF2: M_KAPrimitive = 2;
pub const KAPrimitive_PKCS11LSB: M_KAPrimitive = 3;
pub const KAPrimitive_PKCS11MSB: M_KAPrimitive = 4;
pub const KAPrimitive_RSAWrap: M_KAPrimitive = 5;
pub const KAPrimitive_ECDHCmDHAESdKDF2: M_KAPrimitive = 6;
pub const KAPrimitive__Max: M_KAPrimitive = 7;
pub type M_KAPrimitive = ::core::ffi::c_uint;
pub const IESCipherMode_Any: M_IESCipherMode = 0;
pub const IESCipherMode_XORwithHMAC: M_IESCipherMode = 1;
pub const IESCipherMode_AESKeyWrapPadded: M_IESCipherMode = 2;
pub const IESCipherMode_AESmCTRwHMAC: M_IESCipherMode = 3;
pub const IESCipherMode__Max: M_IESCipherMode = 4;
pub type M_IESCipherMode = ::core::ffi::c_uint;
pub const TestKXGroup_ImpathMODP3072: M_TestKXGroup = 1;
pub const TestKXGroup_SecureChannelv1: M_TestKXGroup = 2;
pub const TestKXGroup__Max: M_TestKXGroup = 3;
pub type M_TestKXGroup = ::core::ffi::c_uint;
pub const TestKXSessionKey_OutboundEncryption: M_TestKXSessionKey = 1;
pub const TestKXSessionKey_OutboundMAC: M_TestKXSessionKey = 2;
pub const TestKXSessionKey_InboundEncryption: M_TestKXSessionKey = 3;
pub const TestKXSessionKey_InboundMAC: M_TestKXSessionKey = 4;
pub const TestKXSessionKey__Max: M_TestKXSessionKey = 5;
pub type M_TestKXSessionKey = ::core::ffi::c_uint;
pub const RemoteServerOp_All: M_RemoteServerOp = 1;
pub const RemoteServerOp_ExportSlot: M_RemoteServerOp = 2;
pub const RemoteServerOp_ExportModule: M_RemoteServerOp = 3;
pub const RemoteServerOp_AccessFiles: M_RemoteServerOp = 4;
pub const RemoteServerOp__Max: M_RemoteServerOp = 5;
pub type M_RemoteServerOp = ::core::ffi::c_uint;
pub const ClientPermission_Unpriv: M_ClientPermission = 1;
pub const ClientPermission_Unix: M_ClientPermission = 2;
pub const ClientPermission_Wideopen: M_ClientPermission = 3;
pub const ClientPermission__Max: M_ClientPermission = 4;
pub type M_ClientPermission = ::core::ffi::c_uint;
pub const ModuleAttribTag_None: M_ModuleAttribTag = 0;
pub const ModuleAttribTag_Challenge: M_ModuleAttribTag = 1;
pub const ModuleAttribTag_ESN: M_ModuleAttribTag = 2;
pub const ModuleAttribTag_KML: M_ModuleAttribTag = 3;
pub const ModuleAttribTag_KLF: M_ModuleAttribTag = 4;
pub const ModuleAttribTag_KNSO: M_ModuleAttribTag = 5;
pub const ModuleAttribTag_KMList: M_ModuleAttribTag = 6;
pub const ModuleAttribTag_PhysSerial: M_ModuleAttribTag = 7;
pub const ModuleAttribTag_PhysFIPSl3: M_ModuleAttribTag = 8;
pub const ModuleAttribTag_FeatureGoldCert: M_ModuleAttribTag = 9;
pub const ModuleAttribTag_Enquiry: M_ModuleAttribTag = 10;
pub const ModuleAttribTag_AdditionalInfo: M_ModuleAttribTag = 11;
pub const ModuleAttribTag_ModKeyInfo: M_ModuleAttribTag = 12;
pub const ModuleAttribTag_KLF2: M_ModuleAttribTag = 13;
pub const ModuleAttribTag_KAL: M_ModuleAttribTag = 14;
pub const ModuleAttribTag_KLF3: M_ModuleAttribTag = 15;
pub const ModuleAttribTag_WarrantKLF2: M_ModuleAttribTag = 16;
pub const ModuleAttribTag_WarrantKLF3: M_ModuleAttribTag = 17;
pub const ModuleAttribTag_HardwareID: M_ModuleAttribTag = 18;
pub const ModuleAttribTag__Max: M_ModuleAttribTag = 19;
pub type M_ModuleAttribTag = ::core::ffi::c_uint;
pub const ModuleType_None: M_ModuleType = 0;
pub const ModuleType_Clyde: M_ModuleType = 2;
pub const ModuleType_Chili: M_ModuleType = 4;
pub const ModuleType_Ariel: M_ModuleType = 5;
pub const ModuleType_Persil: M_ModuleType = 6;
pub const ModuleType_Dorris: M_ModuleType = 7;
pub const ModuleType_Morris: M_ModuleType = 8;
pub const ModuleType_SeaBird: M_ModuleType = 9;
pub const ModuleType_Cosmo: M_ModuleType = 10;
pub const ModuleType_Zowie: M_ModuleType = 11;
pub const ModuleType_Sawshark: M_ModuleType = 12;
pub const ModuleType_Emulator: M_ModuleType = 13;
pub const ModuleType_Ultra: M_ModuleType = 14;
pub const ModuleType_Unknown: M_ModuleType = 999;
pub const ModuleType_PoolModule: M_ModuleType = 1001;
pub const ModuleType__Max: M_ModuleType = 1002;
pub type M_ModuleType = ::core::ffi::c_uint;
pub const SEEMachineType_None: M_SEEMachineType = 0;
pub const SEEMachineType_gen1AIF: M_SEEMachineType = 1;
pub const SEEMachineType_PowerPCSXF: M_SEEMachineType = 2;
pub const SEEMachineType_Virtual: M_SEEMachineType = 3;
pub const SEEMachineType_ARMtype2: M_SEEMachineType = 4;
pub const SEEMachineType_PowerPCELF: M_SEEMachineType = 5;
pub const SEEMachineType_PowerPC64: M_SEEMachineType = 6;
pub const SEEMachineType__Max: M_SEEMachineType = 7;
pub type M_SEEMachineType = ::core::ffi::c_uint;
pub const FeatureGoldCertVendor_VeriSign: M_FeatureGoldCertVendor = 1;
pub const FeatureGoldCertVendor_InternalTestingOnly: M_FeatureGoldCertVendor = 2;
pub const FeatureGoldCertVendor__Max: M_FeatureGoldCertVendor = 3;
pub type M_FeatureGoldCertVendor = ::core::ffi::c_uint;
pub const Cmd_ErrorReturn: M_Cmd = 0;
pub const Cmd_ModExp: M_Cmd = 1;
pub const Cmd_ModExpCrt: M_Cmd = 2;
pub const Cmd_GeneratePrime: M_Cmd = 5;
pub const Cmd_GenerateRandom: M_Cmd = 8;
pub const Cmd_GenerateKey: M_Cmd = 9;
pub const Cmd_GenerateKeyPair: M_Cmd = 10;
pub const Cmd_Import: M_Cmd = 11;
pub const Cmd_Duplicate: M_Cmd = 12;
pub const Cmd_GetKeyInfo: M_Cmd = 13;
pub const Cmd_Destroy: M_Cmd = 14;
pub const Cmd_Encrypt: M_Cmd = 15;
pub const Cmd_Decrypt: M_Cmd = 16;
pub const Cmd_Verify: M_Cmd = 17;
pub const Cmd_Export: M_Cmd = 18;
pub const Cmd_GetAppData: M_Cmd = 19;
pub const Cmd_SetAppData: M_Cmd = 20;
pub const Cmd_NewClient: M_Cmd = 21;
pub const Cmd_ExistingClient: M_Cmd = 22;
pub const Cmd_GetWhichModule: M_Cmd = 23;
pub const Cmd_MergeKeyIDs: M_Cmd = 24;
pub const Cmd_GenerateLogicalToken: M_Cmd = 26;
pub const Cmd_WriteShare: M_Cmd = 27;
pub const Cmd_GetSlotList: M_Cmd = 28;
pub const Cmd_GetSlotInfo: M_Cmd = 29;
pub const Cmd_ReadShare: M_Cmd = 30;
pub const Cmd_LoadBlob: M_Cmd = 32;
pub const Cmd_LoadLogicalToken: M_Cmd = 34;
pub const Cmd_EraseShare: M_Cmd = 35;
pub const Cmd_ChangeSharePIN: M_Cmd = 36;
pub const Cmd_WriteFile: M_Cmd = 37;
pub const Cmd_ReadFile: M_Cmd = 38;
pub const Cmd_EraseFile: M_Cmd = 39;
pub const Cmd_ProgrammingBegin: M_Cmd = 40;
pub const Cmd_ProgrammingBeginChunk: M_Cmd = 41;
pub const Cmd_ProgrammingLoadBlock: M_Cmd = 42;
pub const Cmd_ProgrammingEndChunk: M_Cmd = 43;
pub const Cmd_ProgrammingEnd: M_Cmd = 44;
pub const Cmd_FormatToken: M_Cmd = 45;
pub const Cmd_SetKM: M_Cmd = 47;
pub const Cmd_RemoveKM: M_Cmd = 48;
pub const Cmd_GetKMList: M_Cmd = 49;
pub const Cmd_InitialiseUnit: M_Cmd = 50;
pub const Cmd_Maintenance: M_Cmd = 51;
pub const Cmd_Fail: M_Cmd = 52;
pub const Cmd_NewEnquiry: M_Cmd = 53;
pub const Cmd_NoOp: M_Cmd = 54;
pub const Cmd_Sign: M_Cmd = 55;
pub const Cmd_ModuleInfo: M_Cmd = 56;
pub const Cmd_ProgrammingGetKeyList: M_Cmd = 57;
pub const Cmd_InsertSoftToken: M_Cmd = 58;
pub const Cmd_RemoveSoftToken: M_Cmd = 59;
pub const Cmd_GetChallenge: M_Cmd = 60;
pub const Cmd_ANModuleReset: M_Cmd = 61;
pub const Cmd_MakeBlob: M_Cmd = 62;
pub const Cmd_GetLogicalTokenInfo: M_Cmd = 63;
pub const Cmd_GetKML: M_Cmd = 64;
pub const Cmd_ANReadTerminated: M_Cmd = 65;
pub const Cmd_ANPleaseClearUnitSoon: M_Cmd = 66;
pub const Cmd_ANPleaseClearUnitNow: M_Cmd = 67;
pub const Cmd_PauseForNotifications: M_Cmd = 68;
pub const Cmd_Hash: M_Cmd = 69;
pub const Cmd_ClearUnit: M_Cmd = 70;
pub const Cmd_ChannelOpen: M_Cmd = 71;
pub const Cmd_ChannelUpdate: M_Cmd = 72;
pub const Cmd_GetACL: M_Cmd = 73;
pub const Cmd_SetACL: M_Cmd = 74;
pub const Cmd_DeriveKey: M_Cmd = 75;
pub const Cmd_RetryFailedModule: M_Cmd = 76;
pub const Cmd_BignumOp: M_Cmd = 77;
pub const Cmd_RSAImmedSignDecrypt: M_Cmd = 78;
pub const Cmd_RSAImmedVerifyEncrypt: M_Cmd = 79;
pub const Cmd_StatEnumTree: M_Cmd = 80;
pub const Cmd_StatGetValues: M_Cmd = 81;
pub const Cmd_LoadRaw: M_Cmd = 87;
pub const Cmd_NVMemAlloc: M_Cmd = 88;
pub const Cmd_NVMemList: M_Cmd = 89;
pub const Cmd_NVMemOp: M_Cmd = 90;
pub const Cmd_NVMemFree: M_Cmd = 91;
pub const Cmd_GetRTC: M_Cmd = 92;
pub const Cmd_SetRTC: M_Cmd = 93;
pub const Cmd_CreateSEEWorld: M_Cmd = 94;
pub const Cmd_SEEJob: M_Cmd = 95;
pub const Cmd_CreateBuffer: M_Cmd = 96;
pub const Cmd_LoadBuffer: M_Cmd = 97;
pub const Cmd_SetSEEMachine: M_Cmd = 98;
pub const Cmd_TraceSEEWorld: M_Cmd = 99;
pub const Cmd_GetTicket: M_Cmd = 100;
pub const Cmd_RedeemTicket: M_Cmd = 101;
pub const Cmd_SetNSOPerms: M_Cmd = 102;
pub const Cmd_PollModuleState: M_Cmd = 103;
pub const Cmd_PollSlotList: M_Cmd = 104;
pub const Cmd_ANModuleChangeEvent: M_Cmd = 105;
pub const Cmd_ANSlotChangeEvent: M_Cmd = 106;
pub const Cmd_ImpathKXBegin: M_Cmd = 107;
pub const Cmd_ImpathKXFinish: M_Cmd = 108;
pub const Cmd_ImpathGetInfo: M_Cmd = 109;
pub const Cmd_ImpathSend: M_Cmd = 110;
pub const Cmd_ImpathReceive: M_Cmd = 111;
pub const Cmd_SendShare: M_Cmd = 112;
pub const Cmd_ReceiveShare: M_Cmd = 113;
pub const Cmd_ImportSlot: M_Cmd = 119;
pub const Cmd_UnimportSlot: M_Cmd = 120;
pub const Cmd_ExportSlot: M_Cmd = 121;
pub const Cmd_ServerSendShare: M_Cmd = 122;
pub const Cmd_GetClientHash: M_Cmd = 123;
pub const Cmd_UpdateMergedKey: M_Cmd = 124;
pub const Cmd_GetWorldSigners: M_Cmd = 125;
pub const Cmd_ForeignTokenOpen: M_Cmd = 126;
pub const Cmd_ForeignTokenCmd: M_Cmd = 127;
pub const Cmd_GetKeyInfoEx: M_Cmd = 129;
pub const Cmd_FirmwareAuthenticate: M_Cmd = 130;
pub const Cmd_SignModuleState: M_Cmd = 131;
pub const Cmd_GenerateKLF: M_Cmd = 132;
pub const Cmd_GetKLF: M_Cmd = 133;
pub const Cmd_AddRemoteServerPermission: M_Cmd = 134;
pub const Cmd_RemoveRemoteServerPermission: M_Cmd = 135;
pub const Cmd_ListRemoteServerPermission: M_Cmd = 136;
pub const Cmd_ANRemoteSlotDisconnected: M_Cmd = 137;
pub const Cmd_GetLogicalTokenInfoEx: M_Cmd = 138;
pub const Cmd_GetShareACL: M_Cmd = 139;
pub const Cmd_StaticFeatureEnable: M_Cmd = 140;
pub const Cmd_CheckUserAction: M_Cmd = 142;
pub const Cmd_FileCreate: M_Cmd = 143;
pub const Cmd_FileErase: M_Cmd = 144;
pub const Cmd_FileOp: M_Cmd = 145;
pub const Cmd_FileCopy: M_Cmd = 146;
pub const Cmd_ImportModule: M_Cmd = 147;
pub const Cmd_UnimportModule: M_Cmd = 148;
pub const Cmd_SetMaxNumClients: M_Cmd = 149;
pub const Cmd_ExportModule: M_Cmd = 150;
pub const Cmd_ANRemoteModuleDisconnected: M_Cmd = 151;
pub const Cmd_GetModuleState: M_Cmd = 152;
pub const Cmd_ServerNoOp: M_Cmd = 153;
pub const Cmd_FTSessionOpen: M_Cmd = 154;
pub const Cmd_FTStartRead: M_Cmd = 155;
pub const Cmd_FTRead: M_Cmd = 156;
pub const Cmd_FTStartWrite: M_Cmd = 157;
pub const Cmd_FTWrite: M_Cmd = 158;
pub const Cmd_FTStartListDir: M_Cmd = 159;
pub const Cmd_FTListDir: M_Cmd = 160;
pub const Cmd_SetPublishedObject: M_Cmd = 161;
pub const Cmd_RemovePublishedObject: M_Cmd = 162;
pub const Cmd_GetPublishedObject: M_Cmd = 163;
pub const Cmd_ReReadConfig: M_Cmd = 164;
pub const Cmd_RemoteSlots: M_Cmd = 165;
pub const Cmd_GetKnetiPub: M_Cmd = 166;
pub const Cmd_AnonymousKnetiHash: M_Cmd = 167;
pub const Cmd_IOBoardReprogram: M_Cmd = 169;
pub const Cmd_FTStat: M_Cmd = 173;
pub const Cmd_GetServerConfig: M_Cmd = 181;
pub const Cmd_QueryLongJobs: M_Cmd = 182;
pub const Cmd_FastSEEJob: M_Cmd = 183;
pub const Cmd_FTDelete: M_Cmd = 184;
pub const Cmd_FTChecksum: M_Cmd = 185;
pub const Cmd_FRAGMENT: M_Cmd = 186;
pub const Cmd_ProductionSetup: M_Cmd = 187;
pub const Cmd_MakeSEEWill: M_Cmd = 188;
pub const Cmd_ExecuteSEEWill: M_Cmd = 189;
pub const Cmd_ReadSoftTokenShare: M_Cmd = 194;
pub const Cmd_CreateClient: M_Cmd = 195;
pub const Cmd_InitialiseUnitEx: M_Cmd = 197;
pub const Cmd_GetMonitorLoaderState: M_Cmd = 198;
pub const Cmd_LoadMonitor: M_Cmd = 199;
pub const Cmd_ClearUnitEx: M_Cmd = 200;
pub const Cmd_VerifyCertificate: M_Cmd = 201;
pub const Cmd_DynamicSlotExchangeAPDUs: M_Cmd = 202;
pub const Cmd_StartUpdateWorld: M_Cmd = 204;
pub const Cmd_CheckWorld: M_Cmd = 205;
pub const Cmd_ReportWorldState: M_Cmd = 206;
pub const Cmd_DynamicSlotsConfigure: M_Cmd = 208;
pub const Cmd_ANSlotsConfigurationChangeEvent: M_Cmd = 209;
pub const Cmd_DynamicSlotCreateAssociation: M_Cmd = 210;
pub const Cmd_GetHardwareError: M_Cmd = 211;
pub const Cmd_DynamicSlotsConfigureQuery: M_Cmd = 212;
pub const Cmd_SetPrimarySlot: M_Cmd = 213;
pub const Cmd_ANLogEvent: M_Cmd = 214;
pub const Cmd_GetApplianceVersion: M_Cmd = 215;
pub const Cmd_RemoteReboot: M_Cmd = 216;
pub const Cmd_UpgradeApplianceFirmware: M_Cmd = 217;
pub const Cmd_SetApplianceUpgradeStatus: M_Cmd = 218;
pub const Cmd_GetApplianceUpgradeStatus: M_Cmd = 219;
pub const Cmd_FailDriver: M_Cmd = 223;
pub const Cmd_ConfigurePoolModule: M_Cmd = 224;
pub const Cmd_GetPoolInfo: M_Cmd = 226;
pub const Cmd_ApplyFeatureFile: M_Cmd = 231;
pub const Cmd_SendKey: M_Cmd = 232;
pub const Cmd_ReceiveKey: M_Cmd = 233;
pub const Cmd_ANSendAuditLogEvent: M_Cmd = 234;
pub const Cmd_EraseWorld: M_Cmd = 235;
pub const Cmd_GetApplianceTime: M_Cmd = 236;
pub const Cmd_SetApplianceTime: M_Cmd = 237;
pub const Cmd_GetKLF2: M_Cmd = 238;
pub const Cmd_ChangeShareGroupPIN: M_Cmd = 239;
pub const Cmd_HotReset: M_Cmd = 240;
pub const Cmd_DevTest: M_Cmd = 241;
pub const Cmd_ListRemoteServerPermissionEx: M_Cmd = 242;
pub const Cmd_SessionCreate: M_Cmd = 243;
pub const Cmd_SessionDestroy: M_Cmd = 244;
pub const Cmd_CreateSEEConnection: M_Cmd = 245;
pub const Cmd__Max: M_Cmd = 246;
pub type M_Cmd = ::core::ffi::c_uint;
pub const ModuleMode_Default: M_ModuleMode = 0;
pub const ModuleMode_Maintenance: M_ModuleMode = 1;
pub const ModuleMode_Operational: M_ModuleMode = 2;
pub const ModuleMode_Initialisation: M_ModuleMode = 3;
pub const ModuleMode__Max: M_ModuleMode = 4;
pub type M_ModuleMode = ::core::ffi::c_uint;
pub const CreateClientVer_Zero: M_CreateClientVer = 0;
pub const CreateClientVer_One: M_CreateClientVer = 1;
pub const CreateClientVer__Max: M_CreateClientVer = 2;
pub type M_CreateClientVer = ::core::ffi::c_uint;
pub const DevTestOp_GetFastRaw: M_DevTestOp = 0;
pub const DevTestOp_GetSlowRaw: M_DevTestOp = 1;
pub const DevTestOp__Max: M_DevTestOp = 2;
pub type M_DevTestOp = ::core::ffi::c_uint;
pub const NVMemOpType_Read: M_NVMemOpType = 1;
pub const NVMemOpType_Write: M_NVMemOpType = 2;
pub const NVMemOpType_Incr: M_NVMemOpType = 3;
pub const NVMemOpType_Decr: M_NVMemOpType = 4;
pub const NVMemOpType_BitSet: M_NVMemOpType = 5;
pub const NVMemOpType_BitClear: M_NVMemOpType = 6;
pub const NVMemOpType_Free: M_NVMemOpType = 7;
pub const NVMemOpType_IncrRead: M_NVMemOpType = 8;
pub const NVMemOpType_DecrRead: M_NVMemOpType = 9;
pub const NVMemOpType_BitSetRead: M_NVMemOpType = 10;
pub const NVMemOpType_BitClearRead: M_NVMemOpType = 11;
pub const NVMemOpType_GetACL: M_NVMemOpType = 12;
pub const NVMemOpType_Resize: M_NVMemOpType = 13;
pub const NVMemOpType__Max: M_NVMemOpType = 14;
pub type M_NVMemOpType = ::core::ffi::c_uint;
pub const FwAuthType_NFFHMAC1: M_FwAuthType = 1;
pub const FwAuthType_PRNG1: M_FwAuthType = 2;
pub const FwAuthType__Max: M_FwAuthType = 3;
pub type M_FwAuthType = ::core::ffi::c_uint;
pub const PhysTokenType_Invalid: M_PhysTokenType = 0;
pub const PhysTokenType_ISO7816: M_PhysTokenType = 1;
pub const PhysTokenType__Max: M_PhysTokenType = 2;
pub type M_PhysTokenType = ::core::ffi::c_uint;
pub const PoolInfo_StoreInfo: M_PoolInfo = 1;
pub const PoolInfo_ClientInfo: M_PoolInfo = 2;
pub const PoolInfo_ModuleInfo: M_PoolInfo = 3;
pub const PoolInfo_KeyInfo: M_PoolInfo = 4;
pub const PoolInfo__Max: M_PoolInfo = 5;
pub type M_PoolInfo = ::core::ffi::c_uint;
pub const TicketDestination_Any: M_TicketDestination = 0;
pub const TicketDestination_AnyClient: M_TicketDestination = 1;
pub const TicketDestination_NamedClient: M_TicketDestination = 2;
pub const TicketDestination_AnySEEWorld: M_TicketDestination = 3;
pub const TicketDestination_NamedSEEWorld: M_TicketDestination = 4;
pub const TicketDestination_AnyKernelClient: M_TicketDestination = 5;
pub const TicketDestination__Max: M_TicketDestination = 6;
pub type M_TicketDestination = ::core::ffi::c_uint;
pub const KMLType_DSAp1024s160: M_KMLType = 0;
pub const KMLType_DSAp3072s256: M_KMLType = 1;
pub const KMLType__Max: M_KMLType = 2;
pub type M_KMLType = ::core::ffi::c_uint;
pub const UpgradeState_Invalid: M_UpgradeState = 0;
pub const UpgradeState_Initiated: M_UpgradeState = 1;
pub const UpgradeState_Transferred: M_UpgradeState = 2;
pub const UpgradeState_Verified: M_UpgradeState = 3;
pub const UpgradeState_Upgraded: M_UpgradeState = 4;
pub const UpgradeState__Max: M_UpgradeState = 5;
pub type M_UpgradeState = ::core::ffi::c_uint;
pub const SignerType_KLF: M_SignerType = 1;
pub const SignerType_KML: M_SignerType = 2;
pub const SignerType_AppKey: M_SignerType = 3;
pub const SignerType_KLF2: M_SignerType = 4;
pub const SignerType__Max: M_SignerType = 5;
pub type M_SignerType = ::core::ffi::c_uint;
pub const CertificateKind_ModuleIdentification: M_CertificateKind = 1;
pub const CertificateKind__Max: M_CertificateKind = 2;
pub type M_CertificateKind = ::core::ffi::c_uint;
pub const StackOp_NoOp: M_StackOp = 0;
pub const StackOp_Add: M_StackOp = 1;
pub const StackOp_Sub: M_StackOp = 2;
pub const StackOp_RSub: M_StackOp = 3;
pub const StackOp_Mul: M_StackOp = 4;
pub const StackOp_Div: M_StackOp = 5;
pub const StackOp_Mod: M_StackOp = 6;
pub const StackOp_DivMod: M_StackOp = 7;
pub const StackOp_ModExp: M_StackOp = 8;
pub const StackOp_ModInv: M_StackOp = 9;
pub const StackOp_Dup: M_StackOp = 10;
pub const StackOp_Drop: M_StackOp = 11;
pub const StackOp_Rot: M_StackOp = 12;
pub const StackOp_Set: M_StackOp = 13;
pub const StackOp_Test: M_StackOp = 14;
pub const StackOp_TestPrime: M_StackOp = 15;
pub const StackOp_Neg: M_StackOp = 16;
pub const StackOp_Abs: M_StackOp = 17;
pub const StackOp_GCD: M_StackOp = 18;
pub const StackOp_LCM: M_StackOp = 19;
pub const StackOp__Max: M_StackOp = 20;
pub type M_StackOp = ::core::ffi::c_uint;
pub const ImpathWarrantType_KLF2: M_ImpathWarrantType = 1;
pub const ImpathWarrantType__Max: M_ImpathWarrantType = 2;
pub type M_ImpathWarrantType = ::core::ffi::c_uint;
pub const UseLim_Global: M_UseLim = 1;
pub const UseLim_AuthOld: M_UseLim = 2;
pub const UseLim_Time: M_UseLim = 3;
pub const UseLim_NonVolatile: M_UseLim = 4;
pub const UseLim_Auth: M_UseLim = 6;
pub const UseLim__Max: M_UseLim = 7;
pub type M_UseLim = ::core::ffi::c_uint;
pub const Act_NoAction: M_Act = 0;
pub const Act_OpPermissions: M_Act = 1;
pub const Act_MakeBlob: M_Act = 2;
pub const Act_MakeArchiveBlob: M_Act = 3;
pub const Act_NSOPermissions: M_Act = 4;
pub const Act_DeriveKey: M_Act = 5;
pub const Act_NVMemOpPerms: M_Act = 6;
pub const Act_FeatureEnable: M_Act = 7;
pub const Act_NVMemUseLimit: M_Act = 8;
pub const Act_SendShare: M_Act = 9;
pub const Act_ReadShare: M_Act = 10;
pub const Act_StaticFeatureEnable: M_Act = 11;
pub const Act_UserAction: M_Act = 12;
pub const Act_FileCopy: M_Act = 15;
pub const Act_DeriveKeyEx: M_Act = 47;
pub const Act_SendKey: M_Act = 48;
pub const Act__Max: M_Act = 49;
pub type M_Act = ::core::ffi::c_uint;
pub const DeriveRole_TemplateKey: M_DeriveRole = 0;
pub const DeriveRole_BaseKey: M_DeriveRole = 1;
pub const DeriveRole_WrapKey: M_DeriveRole = 2;
pub const DeriveRole_Key3: M_DeriveRole = 3;
pub const DeriveRole_Key4: M_DeriveRole = 4;
pub const DeriveRole_Key5: M_DeriveRole = 5;
pub const DeriveRole__Max: M_DeriveRole = 6;
pub type M_DeriveRole = ::core::ffi::c_uint;
pub const EnqVer_Zero: M_EnqVer = 0;
pub const EnqVer_One: M_EnqVer = 1;
pub const EnqVer_Two: M_EnqVer = 2;
pub const EnqVer_Three: M_EnqVer = 3;
pub const EnqVer_Four: M_EnqVer = 4;
pub const EnqVer_Five: M_EnqVer = 5;
pub const EnqVer_Six: M_EnqVer = 6;
pub const EnqVer__Max: M_EnqVer = 7;
pub type M_EnqVer = ::core::ffi::c_uint;
pub const LogTokenState_Present: M_LogTokenState = 1;
pub const LogTokenState_Reading: M_LogTokenState = 2;
pub const LogTokenState_Writing: M_LogTokenState = 3;
pub const LogTokenState_TokenAssemblyFailed: M_LogTokenState = 5;
pub const LogTokenState_PhysTokenNotPresent: M_LogTokenState = 6;
pub const LogTokenState_TimeLimitExceeded: M_LogTokenState = 7;
pub const LogTokenState__Max: M_LogTokenState = 8;
pub type M_LogTokenState = ::core::ffi::c_uint;
pub const MonitorLoaderState_Ready: M_MonitorLoaderState = 1;
pub const MonitorLoaderState_Finished: M_MonitorLoaderState = 2;
pub const MonitorLoaderState_AlreadyLoaded: M_MonitorLoaderState = 3;
pub const MonitorLoaderState__Max: M_MonitorLoaderState = 4;
pub type M_MonitorLoaderState = ::core::ffi::c_uint;
pub const ImpathState_Exchange: M_ImpathState = 1;
pub const ImpathState_UpAndRunning: M_ImpathState = 2;
pub const ImpathState_Expired: M_ImpathState = 3;
pub const ImpathState__Max: M_ImpathState = 4;
pub type M_ImpathState = ::core::ffi::c_uint;
pub const InfoFormat_HardwareRev1: M_InfoFormat = 1;
pub const InfoFormat_HardwareRev2: M_InfoFormat = 2;
pub const InfoFormat__Max: M_InfoFormat = 3;
pub type M_InfoFormat = ::core::ffi::c_uint;
pub const LogTokenShareState_OK: M_LogTokenShareState = 1;
pub const LogTokenShareState_NotYetWritten: M_LogTokenShareState = 2;
pub const LogTokenShareState_NotYetRead: M_LogTokenShareState = 3;
pub const LogTokenShareState__Max: M_LogTokenShareState = 4;
pub type M_LogTokenShareState = ::core::ffi::c_uint;
pub const BusType_SCSI: M_BusType = 0;
pub const BusType_PCI: M_BusType = 1;
pub const BusType_USB: M_BusType = 2;
pub const BusType_Local: M_BusType = 3;
pub const BusType_Serial: M_BusType = 4;
pub const BusType_I2C: M_BusType = 5;
pub const BusType_OneWire: M_BusType = 6;
pub const BusType_XBus: M_BusType = 7;
pub const BusType_PS2: M_BusType = 8;
pub const BusType__Max: M_BusType = 9;
pub type M_BusType = ::core::ffi::c_uint;
pub const StatID_Uptime: M_StatID = 1;
pub const StatID_CmdCount: M_StatID = 2;
pub const StatID_ReplyCount: M_StatID = 3;
pub const StatID_CmdBytes: M_StatID = 4;
pub const StatID_ReplyBytes: M_StatID = 5;
pub const StatID_CmdMarshalErrors: M_StatID = 6;
pub const StatID_ReplyMarshalErrors: M_StatID = 7;
pub const StatID_HostWriteCount: M_StatID = 8;
pub const StatID_HostWriteErrors: M_StatID = 9;
pub const StatID_HostWriteOverruns: M_StatID = 10;
pub const StatID_HostWriteNoMemory: M_StatID = 11;
pub const StatID_HostReadCount: M_StatID = 12;
pub const StatID_HostReadErrors: M_StatID = 13;
pub const StatID_HostReadEmpty: M_StatID = 14;
pub const StatID_HostReadUnderruns: M_StatID = 15;
pub const StatID_HostReadDeferred: M_StatID = 16;
pub const StatID_HostReadTerminated: M_StatID = 17;
pub const StatID_PFNIssued: M_StatID = 19;
pub const StatID_PFNRejected: M_StatID = 20;
pub const StatID_PFNCompleted: M_StatID = 21;
pub const StatID_ANIssued: M_StatID = 22;
pub const StatID_ChanJobsIssued: M_StatID = 23;
pub const StatID_ChanJobsCompleted: M_StatID = 24;
pub const StatID_CPULoadPercent: M_StatID = 25;
pub const StatID_HostIRQs: M_StatID = 26;
pub const StatID_ChanJobErrors: M_StatID = 27;
pub const StatID_HostDebugIRQs: M_StatID = 28;
pub const StatID_HostUnhandledIRQs: M_StatID = 29;
pub const StatID_HostReadReconnect: M_StatID = 30;
pub const StatID_SCSIConnections: M_StatID = 31;
pub const StatID_SCSICommands: M_StatID = 32;
pub const StatID_SCSIInquiries: M_StatID = 33;
pub const StatID_SCSIDisconnects: M_StatID = 34;
pub const StatID_SCSIReconnects: M_StatID = 35;
pub const StatID_SCSILUN0Use: M_StatID = 36;
pub const StatID_SCSILUN1Use: M_StatID = 37;
pub const StatID_SCSICmdErrors: M_StatID = 38;
pub const StatID_SCSIBusResets: M_StatID = 39;
pub const StatID_SCSICtrlErrors: M_StatID = 40;
pub const StatID_SCSITagQUse: M_StatID = 41;
pub const StatID_SCSIReconFailures: M_StatID = 42;
pub const StatID_HostWriteBadData: M_StatID = 43;
pub const StatID_ClientCount: M_StatID = 44;
pub const StatID_MaxClients: M_StatID = 45;
pub const StatID_QOutstanding: M_StatID = 46;
pub const StatID_DeviceFails: M_StatID = 47;
pub const StatID_DeviceRestarts: M_StatID = 48;
pub const StatID_DevOutstanding: M_StatID = 49;
pub const StatID_ObjectsCreated: M_StatID = 50;
pub const StatID_ObjectsDestroyed: M_StatID = 51;
pub const StatID_ObjectCount: M_StatID = 52;
pub const StatID_SCSIWideNeg: M_StatID = 53;
pub const StatID_SCSISyncNeg: M_StatID = 54;
pub const StatID_CurrentTempC: M_StatID = 55;
pub const StatID_MaxTempC: M_StatID = 56;
pub const StatID_MinTempC: M_StatID = 57;
pub const StatID_MemTotal: M_StatID = 58;
pub const StatID_MemAllocKernel: M_StatID = 59;
pub const StatID_MemAllocUser: M_StatID = 60;
pub const StatID_CurrentTemp2C: M_StatID = 61;
pub const StatID_MaxTemp2C: M_StatID = 62;
pub const StatID_MinTemp2C: M_StatID = 63;
pub const StatID_VoltageOn5VSupply: M_StatID = 64;
pub const StatID_VoltageOn12VSupply: M_StatID = 65;
pub const StatID_CurrentFanRPM: M_StatID = 66;
pub const StatID_CurrentFan2RPM: M_StatID = 67;
pub const StatID_CurrentFan3RPM: M_StatID = 68;
pub const StatID_CurrentFan4RPM: M_StatID = 69;
pub const StatID_CurrentFan5RPM: M_StatID = 70;
pub const StatID_CurrentFan6RPM: M_StatID = 71;
pub const StatID_HostKernReadCount: M_StatID = 72;
pub const StatID_HostKernReadDeferred: M_StatID = 73;
pub const StatID_HostKernReadReconnect: M_StatID = 74;
pub const StatID_HostKernReadErrors: M_StatID = 75;
pub const StatID_HostKernWriteCount: M_StatID = 76;
pub const StatID_HostKernWriteErrors: M_StatID = 77;
pub const StatID_HostReadPushedDMA: M_StatID = 78;
pub const StatID_HostReadPushedPIO: M_StatID = 79;
pub const StatID_HostKernReadPushedDMA: M_StatID = 80;
pub const StatID_HostKernReadPushedPIO: M_StatID = 81;
pub const StatID_RemoteIPAddr: M_StatID = 82;
pub const StatID_LongOutstanding: M_StatID = 83;
pub const StatID_CmdFragments: M_StatID = 84;
pub const StatID_ReplyFragments: M_StatID = 85;
pub const StatID_DriverIRQs: M_StatID = 86;
pub const StatID_DriverReadIRQs: M_StatID = 87;
pub const StatID_DriverWriteIRQs: M_StatID = 88;
pub const StatID_DriverWriteFails: M_StatID = 89;
pub const StatID_DriverWriteBlocks: M_StatID = 90;
pub const StatID_DriverWriteBytes: M_StatID = 91;
pub const StatID_DriverReadFails: M_StatID = 92;
pub const StatID_DriverReadBlocks: M_StatID = 93;
pub const StatID_DriverReadBytes: M_StatID = 94;
pub const StatID_DriverEnsureFail: M_StatID = 95;
pub const StatID_DriverEnsure: M_StatID = 96;
pub const StatID_JobsOutstanding: M_StatID = 97;
pub const StatID_LongJobsOutstanding: M_StatID = 98;
pub const StatID_VoltageOn3p3VSupply: M_StatID = 99;
pub const StatID_CurrentOn3p3VSupply: M_StatID = 100;
pub const StatID_TamperBattery1: M_StatID = 101;
pub const StatID_CurrentOn5VSupply: M_StatID = 102;
pub const StatID_TamperBattery2: M_StatID = 103;
pub const StatID_CurrentOn12VSupply: M_StatID = 104;
pub const StatID_VoltageOn5VSBSupply: M_StatID = 105;
pub const StatID_CurrentOn5VSBSupply: M_StatID = 106;
pub const StatID_PSUFailure: M_StatID = 107;
pub const StatID_ClientProcessID: M_StatID = 108;
pub const StatID_ClientProcessName: M_StatID = 109;
pub const StatID_ClientNumber: M_StatID = 110;
pub const StatID_ObjectCountTotal: M_StatID = 111;
pub const StatID_TempSP: M_StatID = 112;
pub const StatID_CurrentCPUTemp1: M_StatID = 113;
pub const StatID_CurrentCPUTemp2: M_StatID = 114;
pub const StatID_CurrentFanSpeed: M_StatID = 115;
pub const StatID_CurrentFanDuty: M_StatID = 116;
pub const StatID_CPUVoltage1: M_StatID = 117;
pub const StatID_CPUVoltage2: M_StatID = 118;
pub const StatID_CPUVoltage3: M_StatID = 119;
pub const StatID_CPUVoltage4: M_StatID = 120;
pub const StatID_CPUVoltage5: M_StatID = 121;
pub const StatID_CPUVoltage6: M_StatID = 122;
pub const StatID_CPUVoltage7: M_StatID = 123;
pub const StatID_CPUVoltage8: M_StatID = 124;
pub const StatID_CPUVoltage9: M_StatID = 125;
pub const StatID_CPUVoltage10: M_StatID = 127;
pub const StatID_CPUVoltage11: M_StatID = 128;
pub const StatID_CacheEntryCount: M_StatID = 129;
pub const StatID_CacheEntriesInserted: M_StatID = 130;
pub const StatID_CacheEntriesRemoved: M_StatID = 131;
pub const StatID_AIS31PrelimAlarms: M_StatID = 132;
pub const StatID_MceCount: M_StatID = 133;
pub const StatID_SpiRetries: M_StatID = 134;
pub const StatID_SpI2c1: M_StatID = 135;
pub const StatID_SpI2c2: M_StatID = 136;
pub const StatID_SpTempExcursion: M_StatID = 137;
pub const StatID_SpVoltageExcursion: M_StatID = 138;
pub const StatID_HostBusExceptions: M_StatID = 139;
pub const StatID_CryptoBusExceptions: M_StatID = 140;
pub const StatID_SerialNumber: M_StatID = 141;
pub const StatID_CurrentTime: M_StatID = 142;
pub const StatID_XCSpLogEventID: M_StatID = 143;
pub const StatID_XCSpLogEventDate: M_StatID = 144;
pub const StatID_SpSensorCmdFails: M_StatID = 145;
pub const StatID_JobsStarted: M_StatID = 146;
pub const StatID_JobsComplete: M_StatID = 147;
pub const StatID_RepliesQueued: M_StatID = 148;
pub const StatID_NVMFreeSpace: M_StatID = 149;
pub const StatID_NVMWearLevel: M_StatID = 150;
pub const StatID_NVMWornBlocks: M_StatID = 151;
pub const StatID__Max: M_StatID = 152;
pub type M_StatID = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_Hash {
    pub bytes: [::core::ffi::c_uchar; 20usize],
    pub words: [M_Word; 5usize],
}
impl Default for M_Hash {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Hash {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Hash {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_Hash28 {
    pub bytes: [::core::ffi::c_uchar; 28usize],
    pub words: [M_Word; 7usize],
}
impl Default for M_Hash28 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Hash28 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Hash28 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_Hash32 {
    pub bytes: [::core::ffi::c_uchar; 32usize],
    pub words: [M_Word; 8usize],
}
impl Default for M_Hash32 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Hash32 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Hash32 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_Hash48 {
    pub bytes: [::core::ffi::c_uchar; 48usize],
    pub words: [M_Word; 12usize],
}
impl Default for M_Hash48 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Hash48 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Hash48 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_Hash64 {
    pub bytes: [::core::ffi::c_uchar; 64usize],
    pub words: [M_Word; 16usize],
}
impl Default for M_Hash64 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Hash64 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Hash64 {{ union }}")
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Status_AttemptedDowngrade_ErrorInfo {
    pub oldvsn: M_Word,
    pub newvsn: M_Word,
}
pub type M_vec_CrossModuleReason = *mut M_CrossModuleReason;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Status_CrossModule_ErrorInfo {
    pub n_reasons: ::core::ffi::c_int,
    pub reasons: M_vec_CrossModuleReason,
}
impl Default for M_Status_CrossModule_ErrorInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Status_RemoteServerFailed_ErrorInfo_flags = M_Word;
pub type M_opt_StatusErrorInfo = *mut M_StatusErrorInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Status_RemoteServerFailed_ErrorInfo {
    pub flags: M_Status_RemoteServerFailed_ErrorInfo_flags,
    pub stinfo: M_opt_StatusErrorInfo,
    pub addr: *mut M_NetworkAddress,
}
impl Default for M_Status_RemoteServerFailed_ErrorInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Status_SlotUnconnected_ErrorInfo {
    pub stinfo: M_opt_StatusErrorInfo,
}
impl Default for M_Status_SlotUnconnected_ErrorInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Status_TokenTransactionCorrupted_ErrorInfo {
    pub tokenstatus: M_Status,
}
impl Default for M_Status_TokenTransactionCorrupted_ErrorInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Status_TokenTransactionRolledBack_ErrorInfo {
    pub tokenstatus: M_Status,
}
impl Default for M_Status_TokenTransactionRolledBack_ErrorInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Status_UnknownKPSName_ErrorInfo {
    pub knownkps: M_ASCIIString,
}
impl Default for M_Status_UnknownKPSName_ErrorInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_KeyHash = M_Hash;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Status_UnknownKeyHash_ErrorInfo {
    pub hk: M_KeyHash,
}
impl Default for M_Status_UnknownKeyHash_ErrorInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Status_UnknownKeyHash_ErrorInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Status_UnknownKeyHash_ErrorInfo {{ hk: {:?} }}",
            self.hk
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Status_nCErrno_ErrorInfo {
    pub err: M_nCErrno,
    pub strerr: M_ASCIIString,
}
impl Default for M_Status_nCErrno_ErrorInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_Status__ErrorInfo {
    pub attempteddowngrade: M_Status_AttemptedDowngrade_ErrorInfo,
    pub crossmodule: M_Status_CrossModule_ErrorInfo,
    pub remoteserverfailed: M_Status_RemoteServerFailed_ErrorInfo,
    pub slotunconnected: M_Status_SlotUnconnected_ErrorInfo,
    pub tokentransactioncorrupted: M_Status_TokenTransactionCorrupted_ErrorInfo,
    pub tokentransactionrolledback: M_Status_TokenTransactionRolledBack_ErrorInfo,
    pub unknownkpsname: M_Status_UnknownKPSName_ErrorInfo,
    pub unknownkeyhash: M_Status_UnknownKeyHash_ErrorInfo,
    pub ncerrno: M_Status_nCErrno_ErrorInfo,
}
impl Default for M_Status__ErrorInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Status__ErrorInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Status__ErrorInfo {{ union }}")
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_CrossModReason_Key_Info {
    pub key: M_KeyID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_CrossModReason__Info {
    pub key: M_CrossModReason_Key_Info,
}
impl Default for M_CrossModReason__Info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_CrossModReason__Info {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_CrossModReason__Info {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_CrossModuleReason {
    pub type_: M_CrossModReason,
    pub info: M_CrossModReason__Info,
}
impl Default for M_CrossModuleReason {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_CrossModuleReason {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_CrossModuleReason {{ type: {:?}, info: {:?} }}",
            self.type_, self.info
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_StatusErrorInfo {
    pub st: M_Status,
    pub einfo: M_Status__ErrorInfo,
}
impl Default for M_StatusErrorInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_StatusErrorInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_StatusErrorInfo {{ st: {:?}, einfo: {:?} }}",
            self.st, self.einfo
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_NetworkAddressFamily_HOST_Value {
    pub addr: M_ASCIIString,
    pub port: M_Word,
}
impl Default for M_NetworkAddressFamily_HOST_Value {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_IPv4Address {
    pub bytes: [::core::ffi::c_uchar; 4usize],
    pub words: [M_Word; 1usize],
}
impl Default for M_IPv4Address {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_IPv4Address {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_IPv4Address {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_NetworkAddressFamily_INET_Value {
    pub addr: M_IPv4Address,
    pub port: M_Word,
}
impl Default for M_NetworkAddressFamily_INET_Value {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_NetworkAddressFamily_INET_Value {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_NetworkAddressFamily_INET_Value {{ addr: {:?}, port: {:?} }}",
            self.addr, self.port
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_IPv6Address {
    pub bytes: [::core::ffi::c_uchar; 16usize],
    pub words: [M_Word; 4usize],
}
impl Default for M_IPv6Address {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_IPv6Address {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_IPv6Address {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_NetworkAddressFamily_INET6_Value {
    pub addr: M_IPv6Address,
    pub port: M_Word,
}
impl Default for M_NetworkAddressFamily_INET6_Value {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_NetworkAddressFamily_INET6_Value {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_NetworkAddressFamily_INET6_Value {{ addr: {:?}, port: {:?} }}",
            self.addr, self.port
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_NetworkAddressFamily__Value {
    pub host: M_NetworkAddressFamily_HOST_Value,
    pub inet: M_NetworkAddressFamily_INET_Value,
    pub inet6: M_NetworkAddressFamily_INET6_Value,
}
impl Default for M_NetworkAddressFamily__Value {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_NetworkAddressFamily__Value {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_NetworkAddressFamily__Value {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_NetworkAddress {
    pub af: M_NetworkAddressFamily,
    pub addr: M_NetworkAddressFamily__Value,
}
impl Default for M_NetworkAddress {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_NetworkAddress {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_NetworkAddress {{ af: {:?}, addr: {:?} }}",
            self.af, self.addr
        )
    }
}
pub type M_ClientID = M_Hash;
pub type M_LimitID = M_Hash;
pub type M_Hash20 = M_Hash;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_KeyHashMech_SHA1Hash_KeyHashData {
    pub hash: M_Hash20,
}
impl Default for M_KeyHashMech_SHA1Hash_KeyHashData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_KeyHashMech_SHA1Hash_KeyHashData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_KeyHashMech_SHA1Hash_KeyHashData {{ hash: {:?} }}",
            self.hash
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_KeyHashMech_SHA256Hash_KeyHashData {
    pub hash: M_Hash32,
}
impl Default for M_KeyHashMech_SHA256Hash_KeyHashData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_KeyHashMech_SHA256Hash_KeyHashData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_KeyHashMech_SHA256Hash_KeyHashData {{ hash: {:?} }}",
            self.hash
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_KeyHashMech_SHA512Hash_KeyHashData {
    pub hash: M_Hash64,
}
impl Default for M_KeyHashMech_SHA512Hash_KeyHashData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_KeyHashMech_SHA512Hash_KeyHashData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_KeyHashMech_SHA512Hash_KeyHashData {{ hash: {:?} }}",
            self.hash
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_KeyHashMech__KeyHashData {
    pub sha1hash: M_KeyHashMech_SHA1Hash_KeyHashData,
    pub sha256hash: M_KeyHashMech_SHA256Hash_KeyHashData,
    pub sha512hash: M_KeyHashMech_SHA512Hash_KeyHashData,
}
impl Default for M_KeyHashMech__KeyHashData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_KeyHashMech__KeyHashData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_KeyHashMech__KeyHashData {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_KeyHashEx {
    pub mech: M_KeyHashMech,
    pub data: M_KeyHashMech__KeyHashData,
}
impl Default for M_KeyHashEx {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_KeyHashEx {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_KeyHashEx {{ mech: {:?}, data: {:?} }}",
            self.mech, self.data
        )
    }
}
pub type M_TokenHash = M_Hash;
pub type M_KMHash = M_Hash;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_PhysToken {
    pub module: M_ModuleID,
    pub slot: M_SlotID,
    pub ic: M_Word,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_SlotType_Unconnected_SlotExData {
    pub stinfo: M_StatusErrorInfo,
}
impl Default for M_SlotType_Unconnected_SlotExData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_SlotType_Unconnected_SlotExData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_SlotType_Unconnected_SlotExData {{ stinfo: {:?} }}",
            self.stinfo
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_SlotType__SlotExData {
    pub unconnected: M_SlotType_Unconnected_SlotExData,
}
impl Default for M_SlotType__SlotExData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_SlotType__SlotExData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_SlotType__SlotExData {{ union }}")
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_PlainTextType_Bignum_Data {
    pub m: M_Bignum,
}
impl Default for M_PlainTextType_Bignum_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_PlainTextType_Bytes_Data {
    pub data: M_ByteBlock,
}
impl Default for M_PlainTextType_Bytes_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_ECPoint_flags = M_Word;
pub type M_FieldElement = M_Bignum;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_ECPoint {
    pub flags: M_ECPoint_flags,
    pub x: M_FieldElement,
    pub y: M_FieldElement,
}
impl Default for M_ECPoint {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_PlainTextType_ECPoint_Data {
    pub data: M_ECPoint,
}
impl Default for M_PlainTextType_ECPoint_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_PlainTextType_Hash_Data {
    pub data: M_Hash,
}
impl Default for M_PlainTextType_Hash_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_PlainTextType_Hash_Data {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_PlainTextType_Hash_Data {{ data: {:?} }}", self.data)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_Hash16 {
    pub bytes: [::core::ffi::c_uchar; 16usize],
    pub words: [M_Word; 4usize],
}
impl Default for M_Hash16 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Hash16 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Hash16 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_PlainTextType_Hash16_Data {
    pub data: M_Hash16,
}
impl Default for M_PlainTextType_Hash16_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_PlainTextType_Hash16_Data {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_PlainTextType_Hash16_Data {{ data: {:?} }}", self.data)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_Hash24 {
    pub bytes: [::core::ffi::c_uchar; 24usize],
    pub words: [M_Word; 6usize],
}
impl Default for M_Hash24 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Hash24 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Hash24 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_PlainTextType_Hash24_Data {
    pub data: M_Hash24,
}
impl Default for M_PlainTextType_Hash24_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_PlainTextType_Hash24_Data {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_PlainTextType_Hash24_Data {{ data: {:?} }}", self.data)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_PlainTextType_Hash28_Data {
    pub data: M_Hash28,
}
impl Default for M_PlainTextType_Hash28_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_PlainTextType_Hash28_Data {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_PlainTextType_Hash28_Data {{ data: {:?} }}", self.data)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_PlainTextType_Hash32_Data {
    pub data: M_Hash32,
}
impl Default for M_PlainTextType_Hash32_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_PlainTextType_Hash32_Data {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_PlainTextType_Hash32_Data {{ data: {:?} }}", self.data)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_PlainTextType_Hash48_Data {
    pub data: M_Hash48,
}
impl Default for M_PlainTextType_Hash48_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_PlainTextType_Hash48_Data {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_PlainTextType_Hash48_Data {{ data: {:?} }}", self.data)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_PlainTextType_Hash64_Data {
    pub data: M_Hash64,
}
impl Default for M_PlainTextType_Hash64_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_PlainTextType_Hash64_Data {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_PlainTextType_Hash64_Data {{ data: {:?} }}", self.data)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_PlainTextType__Data {
    pub bignum: M_PlainTextType_Bignum_Data,
    pub bytes: M_PlainTextType_Bytes_Data,
    pub ecpoint: M_PlainTextType_ECPoint_Data,
    pub hash: M_PlainTextType_Hash_Data,
    pub hash16: M_PlainTextType_Hash16_Data,
    pub hash24: M_PlainTextType_Hash24_Data,
    pub hash28: M_PlainTextType_Hash28_Data,
    pub hash32: M_PlainTextType_Hash32_Data,
    pub hash48: M_PlainTextType_Hash48_Data,
    pub hash64: M_PlainTextType_Hash64_Data,
}
impl Default for M_PlainTextType__Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_PlainTextType__Data {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_PlainTextType__Data {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_ChannelType__ExtraCOI {
    pub union_is_empty_hack: ::core::ffi::c_int,
}
impl Default for M_ChannelType__ExtraCOI {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_ChannelType__ExtraCOI {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_ChannelType__ExtraCOI {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_ChannelOpenInfo {
    pub type_: M_ChannelType,
    pub info: M_ChannelType__ExtraCOI,
}
impl Default for M_ChannelOpenInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_ChannelOpenInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_ChannelOpenInfo {{ type: {:?}, info: {:?} }}",
            self.type_, self.info
        )
    }
}
pub type M_AnyKeyID = M_KeyID;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_CertType_SigningKey_CertBody {
    pub key: M_AnyKeyID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_DESKey {
    pub bytes: [::core::ffi::c_uchar; 8usize],
    pub words: [M_Word; 2usize],
}
impl Default for M_DESKey {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_DESKey {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_DESKey {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_KeyType_DES_Data {
    pub k: M_DESKey,
}
impl Default for M_KeyType_DES_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_KeyType_DES_Data {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_KeyType_DES_Data {{ k: {:?} }}", self.k)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_DES2Key {
    pub bytes: [::core::ffi::c_uchar; 16usize],
    pub words: [M_Word; 4usize],
}
impl Default for M_DES2Key {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_DES2Key {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_DES2Key {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_KeyType_DES2_Data {
    pub k: M_DES2Key,
}
impl Default for M_KeyType_DES2_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_KeyType_DES2_Data {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_KeyType_DES2_Data {{ k: {:?} }}", self.k)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_DES3Key {
    pub bytes: [::core::ffi::c_uchar; 24usize],
    pub words: [M_Word; 6usize],
}
impl Default for M_DES3Key {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_DES3Key {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_DES3Key {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_KeyType_DES3_Data {
    pub k: M_DES3Key,
}
impl Default for M_KeyType_DES3_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_KeyType_DES3_Data {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_KeyType_DES3_Data {{ k: {:?} }}", self.k)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_DSADiscreteLogGroup {
    pub p: M_Bignum,
    pub q: M_Bignum,
    pub g: M_Bignum,
}
impl Default for M_DSADiscreteLogGroup {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_DHExDiscreteLogGroup = M_DSADiscreteLogGroup;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_KeyType_DHExPrivate_Data {
    pub dlg: M_DHExDiscreteLogGroup,
    pub x: M_Bignum,
}
impl Default for M_KeyType_DHExPrivate_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_KeyType_DHExPublic_Data {
    pub dlg: M_DHExDiscreteLogGroup,
    pub gx: M_Bignum,
}
impl Default for M_KeyType_DHExPublic_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_DiscreteLogGroup {
    pub p: M_Bignum,
    pub g: M_Bignum,
}
impl Default for M_DiscreteLogGroup {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_KeyType_DHPrivate_Data {
    pub dlg: M_DiscreteLogGroup,
    pub x: M_Bignum,
}
impl Default for M_KeyType_DHPrivate_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_KeyType_DHPublic_Data {
    pub dlg: M_DiscreteLogGroup,
    pub gx: M_Bignum,
}
impl Default for M_KeyType_DHPublic_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_KeyType_DKTemplate_Data {
    pub appdata: M_ByteBlock,
    pub nested_acl: M_ByteBlock,
}
impl Default for M_KeyType_DKTemplate_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_DSAInitValues {
    pub seed: M_Hash,
    pub counter: M_Word,
    pub h: M_Word,
}
impl Default for M_DSAInitValues {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_DSAInitValues {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_DSAInitValues {{ seed: {:?}, counter: {:?}, h: {:?} }}",
            self.seed, self.counter, self.h
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_KeyType_DSAComm_Data {
    pub iv: M_DSAInitValues,
    pub dlg: M_DSADiscreteLogGroup,
}
impl Default for M_KeyType_DSAComm_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_KeyType_DSAComm_Data {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_KeyType_DSAComm_Data {{ iv: {:?}, dlg: {:?} }}",
            self.iv, self.dlg
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_DSAInitValuesVarSeed {
    pub seed: M_ByteBlock,
    pub counter: M_Word,
    pub h: M_Word,
}
impl Default for M_DSAInitValuesVarSeed {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_KeyType_DSACommVariableSeed_Data {
    pub iv: M_DSAInitValuesVarSeed,
    pub dlg: M_DSADiscreteLogGroup,
}
impl Default for M_KeyType_DSACommVariableSeed_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_KeyType_DSAPrivate_Data {
    pub dlg: M_DSADiscreteLogGroup,
    pub x: M_Bignum,
}
impl Default for M_KeyType_DSAPrivate_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_KeyType_DSAPublic_Data {
    pub dlg: M_DSADiscreteLogGroup,
    pub y: M_Bignum,
}
impl Default for M_KeyType_DSAPublic_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_FieldType_Binary_Data_flags = M_Word;
pub type M_vec_Word = *mut M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_FieldType_Binary_Data {
    pub flags: M_FieldType_Binary_Data_flags,
    pub n_exponents: ::core::ffi::c_int,
    pub exponents: M_vec_Word,
    pub beta: *mut M_Bignum,
}
impl Default for M_FieldType_Binary_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_FieldType_Prime_Data_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_FieldType_Prime_Data {
    pub flags: M_FieldType_Prime_Data_flags,
    pub p: M_Bignum,
}
impl Default for M_FieldType_Prime_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_FieldType__Data {
    pub binary: M_FieldType_Binary_Data,
    pub prime: M_FieldType_Prime_Data,
}
impl Default for M_FieldType__Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_FieldType__Data {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_FieldType__Data {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Field {
    pub type_: M_FieldType,
    pub data: M_FieldType__Data,
}
impl Default for M_Field {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Field {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Field {{ type: {:?}, data: {:?} }}",
            self.type_, self.data
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_ECName_Custom_Data {
    pub F: M_Field,
    pub a: M_FieldElement,
    pub b: M_FieldElement,
    pub g: M_ECPoint,
    pub r: M_Bignum,
    pub h: M_Word,
}
impl Default for M_ECName_Custom_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_ECName_Custom_Data {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_ECName_Custom_Data {{ F: {:?}, a: {:?}, b: {:?}, g: {:?}, r: {:?}, h: {:?} }}",
            self.F, self.a, self.b, self.g, self.r, self.h
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_ECName_CustomLCF_Data {
    pub F: M_Field,
    pub a: M_FieldElement,
    pub b: M_FieldElement,
    pub g: M_ECPoint,
    pub r: M_Bignum,
    pub h: M_Bignum,
}
impl Default for M_ECName_CustomLCF_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_ECName_CustomLCF_Data {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_ECName_CustomLCF_Data {{ F: {:?}, a: {:?}, b: {:?}, g: {:?}, r: {:?}, h: {:?} }}",
            self.F, self.a, self.b, self.g, self.r, self.h
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_ECName__Data {
    pub custom: M_ECName_Custom_Data,
    pub customlcf: M_ECName_CustomLCF_Data,
}
impl Default for M_ECName__Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_ECName__Data {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_ECName__Data {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_EllipticCurve {
    pub name: M_ECName,
    pub data: M_ECName__Data,
}
impl Default for M_EllipticCurve {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_EllipticCurve {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_EllipticCurve {{ name: {:?}, data: {:?} }}",
            self.name, self.data
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_KeyType_ECPrivate_Data {
    pub curve: M_EllipticCurve,
    pub d: M_Bignum,
}
impl Default for M_KeyType_ECPrivate_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_KeyType_ECPrivate_Data {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_KeyType_ECPrivate_Data {{ curve: {:?}, d: {:?} }}",
            self.curve, self.d
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_KeyType_ECPublic_Data {
    pub curve: M_EllipticCurve,
    pub Q: M_ECPoint,
}
impl Default for M_KeyType_ECPublic_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_KeyType_ECPublic_Data {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_KeyType_ECPublic_Data {{ curve: {:?}, Q: {:?} }}",
            self.curve, self.Q
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_KCDSAInitValues {
    pub seed: M_ByteBlock,
    pub counter: M_Word,
}
impl Default for M_KCDSAInitValues {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_KCDSADiscreteLogGroup = M_DSADiscreteLogGroup;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_KeyType_KCDSAComm_Data {
    pub iv: M_KCDSAInitValues,
    pub dlg: M_KCDSADiscreteLogGroup,
}
impl Default for M_KeyType_KCDSAComm_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_KeyType_KCDSAPrivate_Data {
    pub dlg: M_KCDSADiscreteLogGroup,
    pub y: M_Bignum,
    pub x: M_Bignum,
}
impl Default for M_KeyType_KCDSAPrivate_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_KeyType_KCDSAPublic_Data {
    pub dlg: M_KCDSADiscreteLogGroup,
    pub y: M_Bignum,
}
impl Default for M_KeyType_KCDSAPublic_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_MILENAGESecret {
    pub bytes: [::core::ffi::c_uchar; 16usize],
    pub words: [M_Word; 4usize],
}
impl Default for M_MILENAGESecret {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_MILENAGESecret {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_MILENAGESecret {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_KeyType_MILENAGEOP_Data {
    pub data: M_MILENAGESecret,
}
impl Default for M_KeyType_MILENAGEOP_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_KeyType_MILENAGEOP_Data {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_KeyType_MILENAGEOP_Data {{ data: {:?} }}", self.data)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_MILENAGERCBYTES {
    pub bytes: [::core::ffi::c_uchar; 85usize],
}
impl Default for M_MILENAGERCBYTES {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_MILENAGERCBYTES {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_MILENAGERCBYTES {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_KeyType_MILENAGERC_Data {
    pub data: M_MILENAGERCBYTES,
}
impl Default for M_KeyType_MILENAGERC_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_KeyType_MILENAGERC_Data {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_KeyType_MILENAGERC_Data {{ data: {:?} }}", self.data)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_KeyType_RSAPrivate_Data {
    pub p: M_Bignum,
    pub q: M_Bignum,
    pub dmp1: M_Bignum,
    pub dmq1: M_Bignum,
    pub iqmp: M_Bignum,
    pub e: M_Bignum,
}
impl Default for M_KeyType_RSAPrivate_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_KeyType_RSAPublic_Data {
    pub e: M_Bignum,
    pub n: M_Bignum,
}
impl Default for M_KeyType_RSAPublic_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_KeyType_Random_Data {
    pub k: M_ByteBlock,
}
impl Default for M_KeyType_Random_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_TUAKTOP {
    pub bytes: [::core::ffi::c_uchar; 32usize],
    pub words: [M_Word; 8usize],
}
impl Default for M_TUAKTOP {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_TUAKTOP {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_TUAKTOP {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_KeyType_TUAKTOP_Data {
    pub data: M_TUAKTOP,
}
impl Default for M_KeyType_TUAKTOP_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_KeyType_TUAKTOP_Data {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_KeyType_TUAKTOP_Data {{ data: {:?} }}", self.data)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_KeyType__Data {
    pub des: M_KeyType_DES_Data,
    pub des2: M_KeyType_DES2_Data,
    pub des3: M_KeyType_DES3_Data,
    pub dhexprivate: M_KeyType_DHExPrivate_Data,
    pub dhexpublic: M_KeyType_DHExPublic_Data,
    pub dhprivate: M_KeyType_DHPrivate_Data,
    pub dhpublic: M_KeyType_DHPublic_Data,
    pub dktemplate: M_KeyType_DKTemplate_Data,
    pub dsacomm: M_KeyType_DSAComm_Data,
    pub dsacommvariableseed: M_KeyType_DSACommVariableSeed_Data,
    pub dsaprivate: M_KeyType_DSAPrivate_Data,
    pub dsapublic: M_KeyType_DSAPublic_Data,
    pub ecprivate: M_KeyType_ECPrivate_Data,
    pub ecpublic: M_KeyType_ECPublic_Data,
    pub kcdsacomm: M_KeyType_KCDSAComm_Data,
    pub kcdsaprivate: M_KeyType_KCDSAPrivate_Data,
    pub kcdsapublic: M_KeyType_KCDSAPublic_Data,
    pub milenageop: M_KeyType_MILENAGEOP_Data,
    pub milenagerc: M_KeyType_MILENAGERC_Data,
    pub rsaprivate: M_KeyType_RSAPrivate_Data,
    pub rsapublic: M_KeyType_RSAPublic_Data,
    pub random: M_KeyType_Random_Data,
    pub tuaktop: M_KeyType_TUAKTOP_Data,
}
impl Default for M_KeyType__Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_KeyType__Data {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_KeyType__Data {{ union }}")
    }
}
pub type M_KeyType_DHExPrivate_GenParams_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_KeyType_DHExPrivate_GenParams {
    pub flags: M_KeyType_DHExPrivate_GenParams_flags,
    pub plength: M_Word,
    pub qlength: M_Word,
    pub dlg: *mut M_DHExDiscreteLogGroup,
}
impl Default for M_KeyType_DHExPrivate_GenParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_KeyType_DHPrivate_GenParams_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_KeyType_DHPrivate_GenParams {
    pub flags: M_KeyType_DHPrivate_GenParams_flags,
    pub plength: M_Word,
    pub xlength: M_Word,
    pub dlg: *mut M_DiscreteLogGroup,
}
impl Default for M_KeyType_DHPrivate_GenParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_KeyType_DSAComm_GenParams_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_KeyType_DSAComm_GenParams {
    pub flags: M_KeyType_DSAComm_GenParams_flags,
    pub lenbits: M_Word,
    pub iv: *mut M_DSAInitValues,
}
impl Default for M_KeyType_DSAComm_GenParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_KeyType_DSACommVariableSeed_GenParams_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_KeyType_DSACommVariableSeed_GenParams {
    pub flags: M_KeyType_DSACommVariableSeed_GenParams_flags,
    pub lenbits: M_Word,
    pub iv: *mut M_DSAInitValuesVarSeed,
    pub qhash: *mut M_DSAGenerationHash,
}
impl Default for M_KeyType_DSACommVariableSeed_GenParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_KeyType_DSAPrivate_GenParams_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_KeyType_DSAPrivate_GenParams {
    pub flags: M_KeyType_DSAPrivate_GenParams_flags,
    pub lenbits: M_Word,
    pub dlg: *mut M_DSADiscreteLogGroup,
    pub qhash: *mut M_DSAGenerationHash,
}
impl Default for M_KeyType_DSAPrivate_GenParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_KeyType_ECPrivate_GenParams {
    pub curve: M_EllipticCurve,
}
impl Default for M_KeyType_ECPrivate_GenParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_KeyType_ECPrivate_GenParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_KeyType_ECPrivate_GenParams {{ curve: {:?} }}",
            self.curve
        )
    }
}
pub type M_KeyType_KCDSAComm_GenParams_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_KeyType_KCDSAComm_GenParams {
    pub flags: M_KeyType_KCDSAComm_GenParams_flags,
    pub plen: M_Word,
    pub qlen: M_Word,
    pub iv: *mut M_KCDSAInitValues,
}
impl Default for M_KeyType_KCDSAComm_GenParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_KeyType_KCDSAPrivate_GenParams_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_KeyType_KCDSAPrivate_GenParams {
    pub flags: M_KeyType_KCDSAPrivate_GenParams_flags,
    pub plen: M_Word,
    pub qlen: M_Word,
    pub dlg: *mut M_KCDSADiscreteLogGroup,
}
impl Default for M_KeyType_KCDSAPrivate_GenParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_KeyType_RSAPrivate_GenParams_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_KeyType_RSAPrivate_GenParams {
    pub flags: M_KeyType_RSAPrivate_GenParams_flags,
    pub lenbits: M_Word,
    pub given_e: *mut M_Bignum,
    pub nchecks: *mut M_Word,
}
impl Default for M_KeyType_RSAPrivate_GenParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_KeyType_Random_GenParams {
    pub lenbytes: M_Word,
}
pub type M_KeyType_Wrapped_GenParams_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_KeyType_Wrapped_GenParams {
    pub flags: M_KeyType_Wrapped_GenParams_flags,
    pub length: M_Word,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_KeyType__GenParams {
    pub dhexprivate: M_KeyType_DHExPrivate_GenParams,
    pub dhprivate: M_KeyType_DHPrivate_GenParams,
    pub dsacomm: M_KeyType_DSAComm_GenParams,
    pub dsacommvariableseed: M_KeyType_DSACommVariableSeed_GenParams,
    pub dsaprivate: M_KeyType_DSAPrivate_GenParams,
    pub ecprivate: M_KeyType_ECPrivate_GenParams,
    pub kcdsacomm: M_KeyType_KCDSAComm_GenParams,
    pub kcdsaprivate: M_KeyType_KCDSAPrivate_GenParams,
    pub rsaprivate: M_KeyType_RSAPrivate_GenParams,
    pub random: M_KeyType_Random_GenParams,
    pub wrapped: M_KeyType_Wrapped_GenParams,
}
impl Default for M_KeyType__GenParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_KeyType__GenParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_KeyType__GenParams {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_KeyData {
    pub type_: M_KeyType,
    pub data: M_KeyType__Data,
}
impl Default for M_KeyData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_KeyData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_KeyData {{ type: {:?}, data: {:?} }}",
            self.type_, self.data
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Mech_ArcFourpNONE_Cipher {
    pub cipher: M_ByteBlock,
}
impl Default for M_Mech_ArcFourpNONE_Cipher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Mech_BlobCrypt_Cipher {
    pub cipher: M_ByteBlock,
}
impl Default for M_Mech_BlobCrypt_Cipher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Mech_DHExKeyExchange_Cipher {
    pub gx: M_Bignum,
}
impl Default for M_Mech_DHExKeyExchange_Cipher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Mech_DHKeyExchange_Cipher {
    pub gx: M_Bignum,
}
impl Default for M_Mech_DHKeyExchange_Cipher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Mech_DLIESe3DEShSHA1_Cipher {
    pub cipher: M_ByteBlock,
}
impl Default for M_Mech_DLIESe3DEShSHA1_Cipher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Mech_DSA_Cipher {
    pub r: M_Bignum,
    pub s: M_Bignum,
}
impl Default for M_Mech_DSA_Cipher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Mech_ECDHKeyExchange_Cipher {
    pub gd: M_ECPoint,
}
impl Default for M_Mech_ECDHKeyExchange_Cipher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Mech_ECDSA_Cipher {
    pub r: M_Bignum,
    pub s: M_Bignum,
}
impl Default for M_Mech_ECDSA_Cipher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Mech_Ed25519ph_Cipher {
    pub cipher: M_ByteBlock,
}
impl Default for M_Mech_Ed25519ph_Cipher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Mech_ElGamal_Cipher {
    pub a: M_Bignum,
    pub b: M_Bignum,
}
impl Default for M_Mech_ElGamal_Cipher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Mech_Generic128_Cipher {
    pub cipher: M_ByteBlock,
}
impl Default for M_Mech_Generic128_Cipher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_Block128 {
    pub bytes: [::core::ffi::c_uchar; 16usize],
    pub words: [M_Word; 4usize],
}
impl Default for M_Block128 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Block128 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Block128 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Mech_Generic128MAC_Cipher {
    pub mac: M_Block128,
}
impl Default for M_Mech_Generic128MAC_Cipher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Mech_Generic128MAC_Cipher {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Mech_Generic128MAC_Cipher {{ mac: {:?} }}", self.mac)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Mech_Generic192_Cipher {
    pub cipher: M_ByteBlock,
}
impl Default for M_Mech_Generic192_Cipher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Mech_Generic256_Cipher {
    pub cipher: M_ByteBlock,
}
impl Default for M_Mech_Generic256_Cipher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Mech_Generic64_Cipher {
    pub cipher: M_ByteBlock,
}
impl Default for M_Mech_Generic64_Cipher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_Block64 {
    pub bytes: [::core::ffi::c_uchar; 8usize],
    pub words: [M_Word; 2usize],
}
impl Default for M_Block64 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Block64 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Block64 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Mech_Generic64MAC_Cipher {
    pub mac: M_Block64,
}
impl Default for M_Mech_Generic64MAC_Cipher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Mech_Generic64MAC_Cipher {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Mech_Generic64MAC_Cipher {{ mac: {:?} }}", self.mac)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Mech_GenericGCM128_Cipher {
    pub cipher: M_ByteBlock,
    pub tag: M_Block128,
}
impl Default for M_Mech_GenericGCM128_Cipher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Mech_GenericGCM128_Cipher {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Mech_GenericGCM128_Cipher {{ cipher: {:?}, tag: {:?} }}",
            self.cipher, self.tag
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Mech_HAS160Hash_Cipher {
    pub h: M_Hash20,
}
impl Default for M_Mech_HAS160Hash_Cipher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Mech_HAS160Hash_Cipher {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Mech_HAS160Hash_Cipher {{ h: {:?} }}", self.h)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Mech_Imech_Cipher {
    pub c: M_ByteBlock,
    pub len: M_Word,
}
impl Default for M_Mech_Imech_Cipher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Mech_KCDSAHAS160_Cipher {
    pub r: M_ByteBlock,
    pub s: M_Bignum,
}
impl Default for M_Mech_KCDSAHAS160_Cipher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Mech_KMAC128_Cipher {
    pub tag: M_ByteBlock,
}
impl Default for M_Mech_KMAC128_Cipher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Mech_MD5Hash_Cipher {
    pub h: M_Hash16,
}
impl Default for M_Mech_MD5Hash_Cipher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Mech_MD5Hash_Cipher {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Mech_MD5Hash_Cipher {{ h: {:?} }}", self.h)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Mech_RIPEMD160Hash_Cipher {
    pub h: M_Hash20,
}
impl Default for M_Mech_RIPEMD160Hash_Cipher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Mech_RIPEMD160Hash_Cipher {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Mech_RIPEMD160Hash_Cipher {{ h: {:?} }}", self.h)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Mech_RSApPKCS1_Cipher {
    pub m: M_Bignum,
}
impl Default for M_Mech_RSApPKCS1_Cipher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Mech_RSApPKCS1pPKCS11_Cipher {
    pub cipher: M_ByteBlock,
}
impl Default for M_Mech_RSApPKCS1pPKCS11_Cipher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Mech_SHA1Hash_Cipher {
    pub h: M_Hash20,
}
impl Default for M_Mech_SHA1Hash_Cipher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Mech_SHA1Hash_Cipher {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Mech_SHA1Hash_Cipher {{ h: {:?} }}", self.h)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Mech_SHA224Hash_Cipher {
    pub h: M_Hash28,
}
impl Default for M_Mech_SHA224Hash_Cipher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Mech_SHA224Hash_Cipher {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Mech_SHA224Hash_Cipher {{ h: {:?} }}", self.h)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Mech_SHA256Hash_Cipher {
    pub h: M_Hash32,
}
impl Default for M_Mech_SHA256Hash_Cipher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Mech_SHA256Hash_Cipher {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Mech_SHA256Hash_Cipher {{ h: {:?} }}", self.h)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Mech_SHA384Hash_Cipher {
    pub h: M_Hash48,
}
impl Default for M_Mech_SHA384Hash_Cipher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Mech_SHA384Hash_Cipher {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Mech_SHA384Hash_Cipher {{ h: {:?} }}", self.h)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Mech_SHA512Hash_Cipher {
    pub h: M_Hash64,
}
impl Default for M_Mech_SHA512Hash_Cipher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Mech_SHA512Hash_Cipher {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Mech_SHA512Hash_Cipher {{ h: {:?} }}", self.h)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Mech_TigerHash_Cipher {
    pub h: M_Hash24,
}
impl Default for M_Mech_TigerHash_Cipher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Mech_TigerHash_Cipher {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Mech_TigerHash_Cipher {{ h: {:?} }}", self.h)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_Mech__Cipher {
    pub arcfourpnone: M_Mech_ArcFourpNONE_Cipher,
    pub blobcrypt: M_Mech_BlobCrypt_Cipher,
    pub dhexkeyexchange: M_Mech_DHExKeyExchange_Cipher,
    pub dhkeyexchange: M_Mech_DHKeyExchange_Cipher,
    pub dliese3deshsha1: M_Mech_DLIESe3DEShSHA1_Cipher,
    pub dsa: M_Mech_DSA_Cipher,
    pub ecdhkeyexchange: M_Mech_ECDHKeyExchange_Cipher,
    pub ecdsa: M_Mech_ECDSA_Cipher,
    pub ed25519ph: M_Mech_Ed25519ph_Cipher,
    pub elgamal: M_Mech_ElGamal_Cipher,
    pub generic128: M_Mech_Generic128_Cipher,
    pub generic128mac: M_Mech_Generic128MAC_Cipher,
    pub generic192: M_Mech_Generic192_Cipher,
    pub generic256: M_Mech_Generic256_Cipher,
    pub generic64: M_Mech_Generic64_Cipher,
    pub generic64mac: M_Mech_Generic64MAC_Cipher,
    pub genericgcm128: M_Mech_GenericGCM128_Cipher,
    pub has160hash: M_Mech_HAS160Hash_Cipher,
    pub imech: M_Mech_Imech_Cipher,
    pub kcdsahas160: M_Mech_KCDSAHAS160_Cipher,
    pub kmac128: M_Mech_KMAC128_Cipher,
    pub md5hash: M_Mech_MD5Hash_Cipher,
    pub ripemd160hash: M_Mech_RIPEMD160Hash_Cipher,
    pub rsappkcs1: M_Mech_RSApPKCS1_Cipher,
    pub rsappkcs1ppkcs11: M_Mech_RSApPKCS1pPKCS11_Cipher,
    pub sha1hash: M_Mech_SHA1Hash_Cipher,
    pub sha224hash: M_Mech_SHA224Hash_Cipher,
    pub sha256hash: M_Mech_SHA256Hash_Cipher,
    pub sha384hash: M_Mech_SHA384Hash_Cipher,
    pub sha512hash: M_Mech_SHA512Hash_Cipher,
    pub tigerhash: M_Mech_TigerHash_Cipher,
}
impl Default for M_Mech__Cipher {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Mech__Cipher {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Mech__Cipher {{ union }}")
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Mech_AESmGCM_IV {
    pub taglen: M_Word,
    pub aad: M_ByteBlock,
}
impl Default for M_Mech_AESmGCM_IV {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Mech_Generic128_IV {
    pub iv: M_Block128,
}
impl Default for M_Mech_Generic128_IV {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Mech_Generic128_IV {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Mech_Generic128_IV {{ iv: {:?} }}", self.iv)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Mech_Generic128MAC_IV {
    pub iv: M_Block128,
}
impl Default for M_Mech_Generic128MAC_IV {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Mech_Generic128MAC_IV {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Mech_Generic128MAC_IV {{ iv: {:?} }}", self.iv)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_Block192 {
    pub bytes: [::core::ffi::c_uchar; 24usize],
    pub words: [M_Word; 6usize],
}
impl Default for M_Block192 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Block192 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Block192 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Mech_Generic192_IV {
    pub iv: M_Block192,
}
impl Default for M_Mech_Generic192_IV {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Mech_Generic192_IV {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Mech_Generic192_IV {{ iv: {:?} }}", self.iv)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_Block256 {
    pub bytes: [::core::ffi::c_uchar; 32usize],
    pub words: [M_Word; 8usize],
}
impl Default for M_Block256 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Block256 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Block256 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Mech_Generic256_IV {
    pub iv: M_Block256,
}
impl Default for M_Mech_Generic256_IV {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Mech_Generic256_IV {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Mech_Generic256_IV {{ iv: {:?} }}", self.iv)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Mech_Generic64_IV {
    pub iv: M_Block64,
}
impl Default for M_Mech_Generic64_IV {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Mech_Generic64_IV {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Mech_Generic64_IV {{ iv: {:?} }}", self.iv)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Mech_Generic64MAC_IV {
    pub iv: M_Block64,
}
impl Default for M_Mech_Generic64MAC_IV {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Mech_Generic64MAC_IV {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Mech_Generic64MAC_IV {{ iv: {:?} }}", self.iv)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Mech_GenericGCM128_IV {
    pub iv: M_ByteBlock,
    pub header: M_ByteBlock,
    pub taglen: M_Word,
}
impl Default for M_Mech_GenericGCM128_IV {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Mech_KMAC128_IV {
    pub lenbits: M_Word,
    pub domain: M_ByteBlock,
}
impl Default for M_Mech_KMAC128_IV {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Mech_RSApPKCS1OAEP_IV {
    pub p: M_ByteBlock,
}
impl Default for M_Mech_RSApPKCS1OAEP_IV {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_Mech__IV {
    pub aesmgcm: M_Mech_AESmGCM_IV,
    pub generic128: M_Mech_Generic128_IV,
    pub generic128mac: M_Mech_Generic128MAC_IV,
    pub generic192: M_Mech_Generic192_IV,
    pub generic256: M_Mech_Generic256_IV,
    pub generic64: M_Mech_Generic64_IV,
    pub generic64mac: M_Mech_Generic64MAC_IV,
    pub genericgcm128: M_Mech_GenericGCM128_IV,
    pub kmac128: M_Mech_KMAC128_IV,
    pub rsappkcs1oaep: M_Mech_RSApPKCS1OAEP_IV,
}
impl Default for M_Mech__IV {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Mech__IV {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Mech__IV {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_CipherText {
    pub mech: M_Mech,
    pub data: M_Mech__Cipher,
    pub iv: M_Mech__IV,
}
impl Default for M_CipherText {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_CipherText {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_CipherText {{ mech: {:?}, data: {:?}, iv: {:?} }}",
            self.mech, self.data, self.iv
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_CertType_SingleCert_CertBody {
    pub pubkeydata: M_KeyData,
    pub signature: M_CipherText,
    pub certsignmsg: M_ByteBlock,
}
impl Default for M_CertType_SingleCert_CertBody {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_CertType_SingleCert_CertBody {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_CertType_SingleCert_CertBody {{ pubkeydata: {:?}, signature: {:?}, certsignmsg: {:?} }}" , self . pubkeydata , self . signature , self . certsignmsg)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_CertType__CertBody {
    pub signingkey: M_CertType_SigningKey_CertBody,
    pub singlecert: M_CertType_SingleCert_CertBody,
}
impl Default for M_CertType__CertBody {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_CertType__CertBody {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_CertType__CertBody {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Certificate {
    pub keyhash: M_KeyHash,
    pub type_: M_CertType,
    pub body: M_CertType__CertBody,
}
impl Default for M_Certificate {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Certificate {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Certificate {{ keyhash: {:?}, type: {:?}, body: {:?} }}",
            self.keyhash, self.type_, self.body
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_DSAGenerationHash {
    pub hash: M_Mech,
}
impl Default for M_DSAGenerationHash {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Nonce = M_Hash;
pub type M_FileSpec_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_FileDevice_NVMem_Details {
    pub module: M_ModuleID,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_FileDevice_NVMemPersist_Details {
    pub module: M_ModuleID,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_FileDevice_PhysToken_Details {
    pub token: M_PhysToken,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_FileDevice__Details {
    pub nvmem: M_FileDevice_NVMem_Details,
    pub nvmempersist: M_FileDevice_NVMemPersist_Details,
    pub phystoken: M_FileDevice_PhysToken_Details,
}
impl Default for M_FileDevice__Details {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_FileDevice__Details {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_FileDevice__Details {{ union }}")
    }
}
pub type M_FileInfo_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_FileID {
    pub bytes: [::core::ffi::c_uchar; 11usize],
}
impl Default for M_FileID {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_FileID {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_FileID {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_FileInfo {
    pub flags: M_FileInfo_flags,
    pub length: M_Word,
    pub id: M_FileID,
}
impl Default for M_FileInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_FileInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_FileInfo {{ flags: {:?}, length: {:?}, id: {:?} }}",
            self.flags, self.length, self.id
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_FileSpec {
    pub flags: M_FileSpec_flags,
    pub dev: M_FileDevice,
    pub details: M_FileDevice__Details,
    pub file: M_FileInfo,
}
impl Default for M_FileSpec {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_FileSpec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_FileSpec {{ flags: {:?}, dev: {:?}, details: {:?}, file: {:?} }}",
            self.flags, self.dev, self.details, self.file
        )
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_BlobFormat_Direct_MkBlobParams {
    pub idki: M_KeyID,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_BlobFormat_Indirect_MkBlobParams {
    pub idkr: M_KeyID,
    pub mech: M_Mech,
}
impl Default for M_BlobFormat_Indirect_MkBlobParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_BlobFormat_Module_MkBlobParams {
    pub hkm: M_KMHash,
}
impl Default for M_BlobFormat_Module_MkBlobParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_BlobFormat_Module_MkBlobParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_BlobFormat_Module_MkBlobParams {{ hkm: {:?} }}",
            self.hkm
        )
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_BlobFormat_Token_MkBlobParams {
    pub idkt: M_KeyID,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_BlobFormat_UserKey_MkBlobParams {
    pub idkr: M_KeyID,
    pub mech: M_Mech,
}
impl Default for M_BlobFormat_UserKey_MkBlobParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_BlobFormat__MkBlobParams {
    pub direct: M_BlobFormat_Direct_MkBlobParams,
    pub indirect: M_BlobFormat_Indirect_MkBlobParams,
    pub module: M_BlobFormat_Module_MkBlobParams,
    pub token: M_BlobFormat_Token_MkBlobParams,
    pub userkey: M_BlobFormat_UserKey_MkBlobParams,
}
impl Default for M_BlobFormat__MkBlobParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_BlobFormat__MkBlobParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_BlobFormat__MkBlobParams {{ union }}")
    }
}
pub type M_DeriveMech_AESKeyUnwrap_DKParams_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_DeriveMech_AESKeyUnwrap_DKParams {
    pub flags: M_DeriveMech_AESKeyUnwrap_DKParams_flags,
    pub keytype: M_KeyType,
    pub iv: *mut M_Block64,
}
impl Default for M_DeriveMech_AESKeyUnwrap_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_DeriveMech_AESKeyWrap_DKParams_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_DeriveMech_AESKeyWrap_DKParams {
    pub flags: M_DeriveMech_AESKeyWrap_DKParams_flags,
    pub iv: *mut M_Block64,
}
impl Default for M_DeriveMech_AESKeyWrap_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_DeriveMech_CompositeARQCVerify_DKParams {
    pub scheme: M_ARQCScheme,
    pub mkdata: M_ByteBlock,
    pub skdata: M_ByteBlock,
    pub height: M_Word,
    pub branch: M_Word,
    pub atc: M_Word,
    pub iv: M_ByteBlock,
    pub iipb: M_ByteBlock,
    pub signature: M_ByteBlock,
    pub transdata: M_ByteBlock,
    pub data: M_ByteBlock,
}
impl Default for M_DeriveMech_CompositeARQCVerify_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_DeriveMech_CompositeWatchWordSign_DKParams {
    pub challenge: M_ByteBlock,
    pub version: M_Word,
}
impl Default for M_DeriveMech_CompositeWatchWordSign_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_DeriveMech_CompositeWatchWordVerify_DKParams {
    pub challenge: M_ByteBlock,
    pub response: M_ByteBlock,
    pub version: M_Word,
}
impl Default for M_DeriveMech_CompositeWatchWordVerify_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_DeriveMech_ConcatenateBytes_DKParams {
    pub dst_type: M_KeyType,
}
impl Default for M_DeriveMech_ConcatenateBytes_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_DeriveMech_ConcatenationKDF_DKParams_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_DeriveMech_ConcatenationKDF_DKParams {
    pub flags: M_DeriveMech_ConcatenationKDF_DKParams_flags,
    pub keylen: M_Word,
    pub kdfhash: M_Mech,
    pub keytype: M_KeyType,
    pub sharedinfo: *mut M_ByteBlock,
    pub kx: *mut M_CipherText,
}
impl Default for M_DeriveMech_ConcatenationKDF_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_DeriveMech_ECCMQV_DKParams_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_DeriveMech_ECCMQV_DKParams {
    pub flags: M_DeriveMech_ECCMQV_DKParams_flags,
    pub keylen: M_Word,
    pub kdfhash: M_Mech,
    pub keytype: M_KeyType,
    pub sharedinfo: *mut M_ByteBlock,
}
impl Default for M_DeriveMech_ECCMQV_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_DeriveMech_ECCMQVdNISTCKDF_DKParams_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_DeriveMech_ECCMQVdNISTCKDF_DKParams {
    pub flags: M_DeriveMech_ECCMQVdNISTCKDF_DKParams_flags,
    pub keylen: M_Word,
    pub kdfhash: M_Mech,
    pub keytype: M_KeyType,
    pub sharedinfo: M_ByteBlock,
}
impl Default for M_DeriveMech_ECCMQVdNISTCKDF_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_KAPrimitive_ECDHdKDF2_KADetails {
    pub sharedInfo: M_ByteBlock,
}
impl Default for M_KAPrimitive_ECDHdKDF2_KADetails {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_IV {
    pub mech: M_Mech,
    pub iv: M_Mech__IV,
}
impl Default for M_IV {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_IV {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_IV {{ mech: {:?}, iv: {:?} }}", self.mech, self.iv)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_KAPrimitive_RSAWrap_KADetails {
    pub iv: M_IV,
}
impl Default for M_KAPrimitive_RSAWrap_KADetails {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_KAPrimitive_RSAWrap_KADetails {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_KAPrimitive_RSAWrap_KADetails {{ iv: {:?} }}", self.iv)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_KAPrimitive__KADetails {
    pub ecdhdkdf2: M_KAPrimitive_ECDHdKDF2_KADetails,
    pub rsawrap: M_KAPrimitive_RSAWrap_KADetails,
}
impl Default for M_KAPrimitive__KADetails {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_KAPrimitive__KADetails {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_KAPrimitive__KADetails {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_KAParams {
    pub prim: M_KAPrimitive,
    pub kdfhash: M_Mech,
    pub details: M_KAPrimitive__KADetails,
}
impl Default for M_KAParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_KAParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_KAParams {{ prim: {:?}, kdfhash: {:?}, details: {:?} }}",
            self.prim, self.kdfhash, self.details
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_DeriveMech_ECDHKA_DKParams {
    pub kaparams: M_KAParams,
    pub keytype: M_KeyType,
    pub keylenbits: M_Word,
}
impl Default for M_DeriveMech_ECDHKA_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_DeriveMech_ECDHKA_DKParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_DeriveMech_ECDHKA_DKParams {{ kaparams: {:?}, keytype: {:?}, keylenbits: {:?} }}",
            self.kaparams, self.keytype, self.keylenbits
        )
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_IESCipherMode_AESKeyWrapPadded_IESDetails {
    pub keylenbits: M_Word,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_IESCipherMode_AESmCTRwHMAC_IESDetails {
    pub enckeylenbits: M_Word,
    pub mackeylenbits: M_Word,
    pub mactaglenbits: M_Word,
    pub mac: M_Mech,
}
impl Default for M_IESCipherMode_AESmCTRwHMAC_IESDetails {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_IESCipherMode_XORwithHMAC_IESDetails {
    pub mackeylenbits: M_Word,
    pub mactaglenbits: M_Word,
    pub mac: M_Mech,
}
impl Default for M_IESCipherMode_XORwithHMAC_IESDetails {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_IESCipherMode__IESDetails {
    pub aeskeywrappadded: M_IESCipherMode_AESKeyWrapPadded_IESDetails,
    pub aesmctrwhmac: M_IESCipherMode_AESmCTRwHMAC_IESDetails,
    pub xorwithhmac: M_IESCipherMode_XORwithHMAC_IESDetails,
}
impl Default for M_IESCipherMode__IESDetails {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_IESCipherMode__IESDetails {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_IESCipherMode__IESDetails {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_IESParams {
    pub mode: M_IESCipherMode,
    pub details: M_IESCipherMode__IESDetails,
}
impl Default for M_IESParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_IESParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_IESParams {{ mode: {:?}, details: {:?} }}",
            self.mode, self.details
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_DeriveMech_ECIESKeyUnwrap_DKParams {
    pub kaparams: M_KAParams,
    pub iesparams: M_IESParams,
    pub keytype: M_KeyType,
}
impl Default for M_DeriveMech_ECIESKeyUnwrap_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_DeriveMech_ECIESKeyUnwrap_DKParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_DeriveMech_ECIESKeyUnwrap_DKParams {{ kaparams: {:?}, iesparams: {:?}, keytype: {:?} }}" , self . kaparams , self . iesparams , self . keytype)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_DeriveMech_ECIESKeyWrap_DKParams {
    pub kaparams: M_KAParams,
    pub iesparams: M_IESParams,
}
impl Default for M_DeriveMech_ECIESKeyWrap_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_DeriveMech_ECIESKeyWrap_DKParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_DeriveMech_ECIESKeyWrap_DKParams {{ kaparams: {:?}, iesparams: {:?} }}",
            self.kaparams, self.iesparams
        )
    }
}
pub type M_DeriveMech_GenerateRSAB36_DKParams_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_DeriveMech_GenerateRSAB36_DKParams {
    pub flags: M_DeriveMech_GenerateRSAB36_DKParams_flags,
    pub lenbits: M_Word,
    pub e: M_Bignum,
    pub xp1: M_Bignum,
    pub xp2: M_Bignum,
    pub xp: M_Bignum,
    pub xq1: M_Bignum,
    pub xq2: M_Bignum,
    pub xq: M_Bignum,
}
impl Default for M_DeriveMech_GenerateRSAB36_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_DeriveMech_HyperledgerClient_DKParams {
    pub hmac: M_Mech,
    pub decrypt: M_Mech,
    pub eksize: M_Word,
    pub evsize: M_Word,
    pub big_endian: M_Word,
}
impl Default for M_DeriveMech_HyperledgerClient_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_KDPEncoding_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_KDPEncoding {
    pub flags: M_KDPEncoding_flags,
    pub type_: M_Word,
    pub kind: M_Word,
    pub details: M_Word,
    pub duration: M_Word,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_DeriveMech_KDPKeyWrapDES3_DKParams {
    pub policy: M_KDPEncoding,
}
pub type M_DeriveMech_MILENAGEAV_DKParams_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_AKASequence {
    pub bytes: [::core::ffi::c_uchar; 6usize],
}
impl Default for M_AKASequence {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_AKASequence {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_AKASequence {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_AKAAMF {
    pub bytes: [::core::ffi::c_uchar; 2usize],
}
impl Default for M_AKAAMF {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_AKAAMF {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_AKAAMF {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_AKARandom {
    pub bytes: [::core::ffi::c_uchar; 16usize],
    pub words: [M_Word; 4usize],
}
impl Default for M_AKARandom {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_AKARandom {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_AKARandom {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_DeriveMech_MILENAGEAV_DKParams {
    pub flags: M_DeriveMech_MILENAGEAV_DKParams_flags,
    pub sqn: M_AKASequence,
    pub amf: M_AKAAMF,
    pub rand: *mut M_AKARandom,
}
impl Default for M_DeriveMech_MILENAGEAV_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_DeriveMech_MILENAGEAV_DKParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_DeriveMech_MILENAGEAV_DKParams {{ flags: {:?}, sqn: {:?}, amf: {:?}, rand: {:?} }}",
            self.flags, self.sqn, self.amf, self.rand
        )
    }
}
pub type M_DeriveMech_MILENAGEResync_DKParams_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_MILENAGEAUTS {
    pub bytes: [::core::ffi::c_uchar; 14usize],
}
impl Default for M_MILENAGEAUTS {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_MILENAGEAUTS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_MILENAGEAUTS {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_DeriveMech_MILENAGEResync_DKParams {
    pub flags: M_DeriveMech_MILENAGEResync_DKParams_flags,
    pub amf: M_AKAAMF,
    pub rand: M_AKARandom,
    pub auts: M_MILENAGEAUTS,
}
impl Default for M_DeriveMech_MILENAGEResync_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_DeriveMech_MILENAGEResync_DKParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_DeriveMech_MILENAGEResync_DKParams {{ flags: {:?}, amf: {:?}, rand: {:?}, auts: {:?} }}" , self . flags , self . amf , self . rand , self . auts)
    }
}
pub type M_DeriveMech_NISTKDFmCTRpRijndaelCMACr32_DKParams_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_DeriveMech_NISTKDFmCTRpRijndaelCMACr32_DKParams {
    pub flags: M_DeriveMech_NISTKDFmCTRpRijndaelCMACr32_DKParams_flags,
    pub keylen: M_Word,
    pub keytype: M_KeyType,
    pub context: M_ByteBlock,
    pub label: M_ByteBlock,
}
impl Default for M_DeriveMech_NISTKDFmCTRpRijndaelCMACr32_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_DeriveMech_NISTKDFmCTRr8_DKParams_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_DeriveMech_NISTKDFmCTRr8_DKParams {
    pub flags: M_DeriveMech_NISTKDFmCTRr8_DKParams_flags,
    pub keylen: M_Word,
    pub keytype: M_KeyType,
    pub prf: M_Mech,
    pub context: M_ByteBlock,
    pub label: M_ByteBlock,
}
impl Default for M_DeriveMech_NISTKDFmCTRr8_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_DeriveMech_PKCS8Decrypt_DKParams {
    pub iv: M_IV,
}
impl Default for M_DeriveMech_PKCS8Decrypt_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_DeriveMech_PKCS8Decrypt_DKParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_DeriveMech_PKCS8Decrypt_DKParams {{ iv: {:?} }}",
            self.iv
        )
    }
}
pub type M_DeriveMech_PKCS8DecryptEx_DKParams_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_DeriveMech_PKCS8DecryptEx_DKParams {
    pub flags: M_DeriveMech_PKCS8DecryptEx_DKParams_flags,
    pub iv: M_IV,
    pub keytype: *mut M_PKCS8PreferredKeyType,
}
impl Default for M_DeriveMech_PKCS8DecryptEx_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_DeriveMech_PKCS8DecryptEx_DKParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_DeriveMech_PKCS8DecryptEx_DKParams {{ flags: {:?}, iv: {:?}, keytype: {:?} }}",
            self.flags, self.iv, self.keytype
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_DeriveMech_PKCS8Encrypt_DKParams {
    pub iv: M_IV,
}
impl Default for M_DeriveMech_PKCS8Encrypt_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_DeriveMech_PKCS8Encrypt_DKParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_DeriveMech_PKCS8Encrypt_DKParams {{ iv: {:?} }}",
            self.iv
        )
    }
}
pub type M_vec_IV = *mut M_IV;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_DeriveMech_RSAComponents_DKParams {
    pub n_ivs: ::core::ffi::c_int,
    pub ivs: M_vec_IV,
}
impl Default for M_DeriveMech_RSAComponents_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_DeriveMech_RSAKeyUnwrap_DKParams {
    pub kaparams: M_KAParams,
    pub iesparams: M_IESParams,
    pub keytype: M_KeyType,
}
impl Default for M_DeriveMech_RSAKeyUnwrap_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_DeriveMech_RSAKeyUnwrap_DKParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_DeriveMech_RSAKeyUnwrap_DKParams {{ kaparams: {:?}, iesparams: {:?}, keytype: {:?} }}" , self . kaparams , self . iesparams , self . keytype)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_DeriveMech_RSAKeyWrap_DKParams {
    pub kaparams: M_KAParams,
    pub iesparams: M_IESParams,
}
impl Default for M_DeriveMech_RSAKeyWrap_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_DeriveMech_RSAKeyWrap_DKParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_DeriveMech_RSAKeyWrap_DKParams {{ kaparams: {:?}, iesparams: {:?} }}",
            self.kaparams, self.iesparams
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_DeriveMech_RawDecrypt_DKParams {
    pub iv: M_IV,
    pub dst_type: M_KeyType,
}
impl Default for M_DeriveMech_RawDecrypt_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_DeriveMech_RawDecrypt_DKParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_DeriveMech_RawDecrypt_DKParams {{ iv: {:?}, dst_type: {:?} }}",
            self.iv, self.dst_type
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_DeriveMech_RawDecryptZeroPad_DKParams {
    pub iv: M_IV,
    pub dst_type: M_KeyType,
    pub padlen: M_Word,
}
impl Default for M_DeriveMech_RawDecryptZeroPad_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_DeriveMech_RawDecryptZeroPad_DKParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_DeriveMech_RawDecryptZeroPad_DKParams {{ iv: {:?}, dst_type: {:?}, padlen: {:?} }}",
            self.iv, self.dst_type, self.padlen
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_DeriveMech_RawEncrypt_DKParams {
    pub iv: M_IV,
}
impl Default for M_DeriveMech_RawEncrypt_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_DeriveMech_RawEncrypt_DKParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_DeriveMech_RawEncrypt_DKParams {{ iv: {:?} }}",
            self.iv
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_DeriveMech_RawEncryptZeroPad_DKParams {
    pub iv: M_IV,
    pub padlen: M_Word,
}
impl Default for M_DeriveMech_RawEncryptZeroPad_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_DeriveMech_RawEncryptZeroPad_DKParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_DeriveMech_RawEncryptZeroPad_DKParams {{ iv: {:?}, padlen: {:?} }}",
            self.iv, self.padlen
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_DeriveMech_RawSign_DKParams {
    pub iv: M_IV,
    pub dst_type: M_KeyType,
}
impl Default for M_DeriveMech_RawSign_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_DeriveMech_RawSign_DKParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_DeriveMech_RawSign_DKParams {{ iv: {:?}, dst_type: {:?} }}",
            self.iv, self.dst_type
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_SSLClientRandom {
    pub bytes: [::core::ffi::c_uchar; 32usize],
    pub words: [M_Word; 8usize],
}
impl Default for M_SSLClientRandom {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_SSLClientRandom {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_SSLClientRandom {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_SSLServerRandom {
    pub bytes: [::core::ffi::c_uchar; 32usize],
    pub words: [M_Word; 8usize],
}
impl Default for M_SSLServerRandom {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_SSLServerRandom {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_SSLServerRandom {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_DeriveMech_SSL3withDH_DKParams {
    pub y: M_Bignum,
    pub crnd: M_SSLClientRandom,
    pub srnd: M_SSLServerRandom,
}
impl Default for M_DeriveMech_SSL3withDH_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_DeriveMech_SSL3withDH_DKParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_DeriveMech_SSL3withDH_DKParams {{ y: {:?}, crnd: {:?}, srnd: {:?} }}",
            self.y, self.crnd, self.srnd
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_DeriveMech_SSL3withRSA_DKParams {
    pub ct: M_Bignum,
    pub crnd: M_SSLClientRandom,
    pub srnd: M_SSLServerRandom,
}
impl Default for M_DeriveMech_SSL3withRSA_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_DeriveMech_SSL3withRSA_DKParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_DeriveMech_SSL3withRSA_DKParams {{ ct: {:?}, crnd: {:?}, srnd: {:?} }}",
            self.ct, self.crnd, self.srnd
        )
    }
}
pub type M_DeriveMech_SignedKDPKeyWrapDES3_DKParams_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_DeriveMech_SignedKDPKeyWrapDES3_DKParams {
    pub flags: M_DeriveMech_SignedKDPKeyWrapDES3_DKParams_flags,
    pub mech: M_Mech,
    pub beginauth: M_ByteBlock,
    pub sig: M_CipherText,
}
impl Default for M_DeriveMech_SignedKDPKeyWrapDES3_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_DeriveMech_SignedKDPKeyWrapDES3_DKParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_DeriveMech_SignedKDPKeyWrapDES3_DKParams {{ flags: {:?}, mech: {:?}, beginauth: {:?}, sig: {:?} }}" , self . flags , self . mech , self . beginauth , self . sig)
    }
}
pub type M_DeriveMech_TUAKAV_DKParams_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_DeriveMech_TUAKAV_DKParams {
    pub flags: M_DeriveMech_TUAKAV_DKParams_flags,
    pub sqn: M_AKASequence,
    pub amf: M_AKAAMF,
    pub rand: *mut M_AKARandom,
    pub maclen: M_Word,
    pub reslen: M_Word,
    pub cklen: M_Word,
    pub iklen: M_Word,
    pub iterations: M_Word,
}
impl Default for M_DeriveMech_TUAKAV_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_DeriveMech_TUAKAV_DKParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_DeriveMech_TUAKAV_DKParams {{ flags: {:?}, sqn: {:?}, amf: {:?}, rand: {:?}, maclen: {:?}, reslen: {:?}, cklen: {:?}, iklen: {:?}, iterations: {:?} }}" , self . flags , self . sqn , self . amf , self . rand , self . maclen , self . reslen , self . cklen , self . iklen , self . iterations)
    }
}
pub type M_DeriveMech_TUAKGenAUTS_DKParams_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_DeriveMech_TUAKGenAUTS_DKParams {
    pub flags: M_DeriveMech_TUAKGenAUTS_DKParams_flags,
    pub sqn: M_AKASequence,
    pub amf: M_AKAAMF,
    pub rand: *mut M_AKARandom,
    pub maclen: M_Word,
    pub iterations: M_Word,
}
impl Default for M_DeriveMech_TUAKGenAUTS_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_DeriveMech_TUAKGenAUTS_DKParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_DeriveMech_TUAKGenAUTS_DKParams {{ flags: {:?}, sqn: {:?}, amf: {:?}, rand: {:?}, maclen: {:?}, iterations: {:?} }}" , self . flags , self . sqn , self . amf , self . rand , self . maclen , self . iterations)
    }
}
pub type M_DeriveMech_TUAKResync_DKParams_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_DeriveMech_TUAKResync_DKParams {
    pub flags: M_DeriveMech_TUAKResync_DKParams_flags,
    pub amf: M_AKAAMF,
    pub rand: M_AKARandom,
    pub auts: M_ByteBlock,
    pub maclen: M_Word,
    pub iterations: M_Word,
}
impl Default for M_DeriveMech_TUAKResync_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_DeriveMech_TUAKResync_DKParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_DeriveMech_TUAKResync_DKParams {{ flags: {:?}, amf: {:?}, rand: {:?}, auts: {:?}, maclen: {:?}, iterations: {:?} }}" , self . flags , self . amf , self . rand , self . auts , self . maclen , self . iterations)
    }
}
pub type M_DeriveMech_TUAKTOPC_DKParams_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_DeriveMech_TUAKTOPC_DKParams {
    pub flags: M_DeriveMech_TUAKTOPC_DKParams_flags,
    pub iterations: M_Word,
}
pub type M_DeriveMech_TestKX_DKParams_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_DeriveMech_TestKX_DKParams {
    pub flags: M_DeriveMech_TestKX_DKParams_flags,
    pub group: M_TestKXGroup,
    pub sessionkey: M_TestKXSessionKey,
    pub localnonce: M_ByteBlock,
    pub localname: M_ByteBlock,
    pub remotenonce: M_ByteBlock,
    pub remotename: M_ByteBlock,
    pub remotekey: M_KeyData,
}
impl Default for M_DeriveMech_TestKX_DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_DeriveMech_TestKX_DKParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_DeriveMech_TestKX_DKParams {{ flags: {:?}, group: {:?}, sessionkey: {:?}, localnonce: {:?}, localname: {:?}, remotenonce: {:?}, remotename: {:?}, remotekey: {:?} }}" , self . flags , self . group , self . sessionkey , self . localnonce , self . localname , self . remotenonce , self . remotename , self . remotekey)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_DeriveMech__DKParams {
    pub aeskeyunwrap: M_DeriveMech_AESKeyUnwrap_DKParams,
    pub aeskeywrap: M_DeriveMech_AESKeyWrap_DKParams,
    pub compositearqcverify: M_DeriveMech_CompositeARQCVerify_DKParams,
    pub compositewatchwordsign: M_DeriveMech_CompositeWatchWordSign_DKParams,
    pub compositewatchwordverify: M_DeriveMech_CompositeWatchWordVerify_DKParams,
    pub concatenatebytes: M_DeriveMech_ConcatenateBytes_DKParams,
    pub concatenationkdf: M_DeriveMech_ConcatenationKDF_DKParams,
    pub eccmqv: M_DeriveMech_ECCMQV_DKParams,
    pub eccmqvdnistckdf: M_DeriveMech_ECCMQVdNISTCKDF_DKParams,
    pub ecdhka: M_DeriveMech_ECDHKA_DKParams,
    pub ecieskeyunwrap: M_DeriveMech_ECIESKeyUnwrap_DKParams,
    pub ecieskeywrap: M_DeriveMech_ECIESKeyWrap_DKParams,
    pub generatersab36: M_DeriveMech_GenerateRSAB36_DKParams,
    pub hyperledgerclient: M_DeriveMech_HyperledgerClient_DKParams,
    pub kdpkeywrapdes3: M_DeriveMech_KDPKeyWrapDES3_DKParams,
    pub milenageav: M_DeriveMech_MILENAGEAV_DKParams,
    pub milenageresync: M_DeriveMech_MILENAGEResync_DKParams,
    pub nistkdfmctrprijndaelcmacr32: M_DeriveMech_NISTKDFmCTRpRijndaelCMACr32_DKParams,
    pub nistkdfmctrr8: M_DeriveMech_NISTKDFmCTRr8_DKParams,
    pub pkcs8decrypt: M_DeriveMech_PKCS8Decrypt_DKParams,
    pub pkcs8decryptex: M_DeriveMech_PKCS8DecryptEx_DKParams,
    pub pkcs8encrypt: M_DeriveMech_PKCS8Encrypt_DKParams,
    pub rsacomponents: M_DeriveMech_RSAComponents_DKParams,
    pub rsakeyunwrap: M_DeriveMech_RSAKeyUnwrap_DKParams,
    pub rsakeywrap: M_DeriveMech_RSAKeyWrap_DKParams,
    pub rawdecrypt: M_DeriveMech_RawDecrypt_DKParams,
    pub rawdecryptzeropad: M_DeriveMech_RawDecryptZeroPad_DKParams,
    pub rawencrypt: M_DeriveMech_RawEncrypt_DKParams,
    pub rawencryptzeropad: M_DeriveMech_RawEncryptZeroPad_DKParams,
    pub rawsign: M_DeriveMech_RawSign_DKParams,
    pub ssl3withdh: M_DeriveMech_SSL3withDH_DKParams,
    pub ssl3withrsa: M_DeriveMech_SSL3withRSA_DKParams,
    pub signedkdpkeywrapdes3: M_DeriveMech_SignedKDPKeyWrapDES3_DKParams,
    pub tuakav: M_DeriveMech_TUAKAV_DKParams,
    pub tuakgenauts: M_DeriveMech_TUAKGenAUTS_DKParams,
    pub tuakresync: M_DeriveMech_TUAKResync_DKParams,
    pub tuaktopc: M_DeriveMech_TUAKTOPC_DKParams,
    pub testkx: M_DeriveMech_TestKX_DKParams,
}
impl Default for M_DeriveMech__DKParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_DeriveMech__DKParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_DeriveMech__DKParams {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_DKMechParams {
    pub mech: M_DeriveMech,
    pub params: M_DeriveMech__DKParams,
}
impl Default for M_DKMechParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_DKMechParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_DKMechParams {{ mech: {:?}, params: {:?} }}",
            self.mech, self.params
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_PKCS8PreferredKeyType {
    pub keytype: M_KeyType,
}
impl Default for M_PKCS8PreferredKeyType {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_RemoteServerPermission_flags = M_Word;
pub type M_vec_HostVolumeDesc = *mut M_HostVolumeDesc;
pub type M_RemoteServerOp_AccessFiles_Details_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_RemoteServerOp_AccessFiles_Details {
    pub n_volumes: ::core::ffi::c_int,
    pub volumes: M_vec_HostVolumeDesc,
    pub flags: M_RemoteServerOp_AccessFiles_Details_flags,
}
impl Default for M_RemoteServerOp_AccessFiles_Details {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_RemoteServerOp_ExportModule_Details {
    pub perm: M_ClientPermission,
}
impl Default for M_RemoteServerOp_ExportModule_Details {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_RemoteServerOp_ExportSlot_Details {
    pub slot: M_SlotID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_RemoteServerOp__Details {
    pub accessfiles: M_RemoteServerOp_AccessFiles_Details,
    pub exportmodule: M_RemoteServerOp_ExportModule_Details,
    pub exportslot: M_RemoteServerOp_ExportSlot_Details,
}
impl Default for M_RemoteServerOp__Details {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_RemoteServerOp__Details {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_RemoteServerOp__Details {{ union }}")
    }
}
pub type M_RemoteModule_flags = M_Word;
pub type M_vec_KeyHashAndMech = *mut M_KeyHashAndMech;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_wrap_vec_KeyHashAndMech {
    pub n: ::core::ffi::c_int,
    pub v: M_vec_KeyHashAndMech,
}
impl Default for M_wrap_vec_KeyHashAndMech {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_wrap_vec_Word {
    pub n: ::core::ffi::c_int,
    pub v: M_vec_Word,
}
impl Default for M_wrap_vec_Word {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_ImpathKXGroupSelection = M_wrap_vec_Word;
pub type M_vec_KeyHashEx = *mut M_KeyHashEx;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_wrap_vec_KeyHashEx {
    pub n: ::core::ffi::c_int,
    pub v: M_vec_KeyHashEx,
}
impl Default for M_wrap_vec_KeyHashEx {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_RemoteModule {
    pub flags: M_RemoteModule_flags,
    pub ma: *mut M_ModuleAttribList,
    pub addr: *mut M_NetworkAddress,
    pub hks: *mut M_wrap_vec_KeyHashAndMech,
    pub groups: *mut M_ImpathKXGroupSelection,
    pub agelimit: *mut M_Word,
    pub datalimit: *mut M_Word,
    pub warrantroots: *mut M_wrap_vec_KeyHashEx,
}
impl Default for M_RemoteModule {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_RemoteServerPermission {
    pub flags: M_RemoteServerPermission_flags,
    pub permid: M_Word,
    pub module: M_ModuleID,
    pub op: M_RemoteServerOp,
    pub details: M_RemoteServerOp__Details,
    pub rm: M_RemoteModule,
}
impl Default for M_RemoteServerPermission {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_RemoteServerPermission {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_RemoteServerPermission {{ flags: {:?}, permid: {:?}, module: {:?}, op: {:?}, details: {:?}, rm: {:?} }}" , self . flags , self . permid , self . module , self . op , self . details , self . rm)
    }
}
pub type M_FileName = M_ASCIIString;
pub type M_HostFileFlags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_HostVolumeDesc {
    pub nativepath: M_ASCIIString,
    pub volume: M_FileName,
    pub flags: M_HostFileFlags,
}
impl Default for M_HostVolumeDesc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_vec_ModuleAttrib = *mut M_ModuleAttrib;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_ModuleAttribList {
    pub n_attribs: ::core::ffi::c_int,
    pub attribs: M_vec_ModuleAttrib,
}
impl Default for M_ModuleAttribList {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_KeyHashAndMech {
    pub hash: M_KeyHash,
    pub mech: M_Mech,
}
impl Default for M_KeyHashAndMech {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_KeyHashAndMech {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_KeyHashAndMech {{ hash: {:?}, mech: {:?} }}",
            self.hash, self.mech
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_ModuleAttribTag_AdditionalInfo_Value {
    pub v: M_Word,
    pub username: M_ASCIIString,
}
impl Default for M_ModuleAttribTag_AdditionalInfo_Value {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_ModuleAttribTag_Challenge_Value {
    pub nonce: M_Nonce,
}
impl Default for M_ModuleAttribTag_Challenge_Value {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_ModuleAttribTag_Challenge_Value {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_ModuleAttribTag_Challenge_Value {{ nonce: {:?} }}",
            self.nonce
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_ModuleAttribTag_ESN_Value {
    pub esn: M_ASCIIString,
}
impl Default for M_ModuleAttribTag_ESN_Value {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_EnquiryDataOne_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_EnquiryDataOne {
    pub releasemajor: M_Word,
    pub releaseminor: M_Word,
    pub releasepatch: M_Word,
    pub checkintimehigh: M_Word,
    pub checkintimelow: M_Word,
    pub flags: M_EnquiryDataOne_flags,
    pub speedindex: M_Word,
    pub recommendedminq: M_Word,
    pub recommendedmaxq: M_Word,
    pub hardwareserial: M_ASCIIString,
    pub softwaredetails: M_ASCIIString,
}
impl Default for M_EnquiryDataOne {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_EnquiryDataTwo_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_EnquiryDataTwo {
    pub flags: M_EnquiryDataTwo_flags,
    pub maxwrite: M_Word,
}
pub type M_EnquiryDataThree_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_EnquiryDataThree {
    pub flags: M_EnquiryDataThree_flags,
}
pub type M_EnquiryDataFour_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_EnquiryDataFour {
    pub flags: M_EnquiryDataFour_flags,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_EnquiryDataFive {
    pub moduletype: M_ModuleType,
    pub productname: M_ASCIIString,
    pub devicename: M_ASCIIString,
}
impl Default for M_EnquiryDataFive {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_FeatureInfo_ctrl = M_Word;
pub type M_FeatureInfo_features = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_FeatureInfo {
    pub ver: M_Word,
    pub ctrl: M_FeatureInfo_ctrl,
    pub features: M_FeatureInfo_features,
}
pub type M_EnquiryDataSix_flags = M_Word;
pub type M_SupportedKMLTypes = M_wrap_vec_Word;
pub type M_NSOPermsModeFlags = M_Word;
pub type M_InitModeFlags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_EnquiryDataSix {
    pub v: M_Word,
    pub supportedgroups: M_ImpathKXGroupSelection,
    pub features: M_FeatureInfo,
    pub vsn: M_Word,
    pub flags: M_EnquiryDataSix_flags,
    pub rmdata: *mut M_EnquiryRMData,
    pub impathport: M_Word,
    pub maxnumclients: M_Word,
    pub kneti: *mut M_KeyHash,
    pub reclongqueue: M_Word,
    pub seemachtype: M_SEEMachineType,
    pub kmltypes: M_SupportedKMLTypes,
    pub usedkxgroup: M_Word,
    pub supportednsopermsmodes: M_Word,
    pub supportedinitmodes: M_Word,
    pub activensopermsmodes: M_NSOPermsModeFlags,
    pub activeinitmodes: M_InitModeFlags,
    pub impathportv6: M_Word,
}
impl Default for M_EnquiryDataSix {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_ModuleAttribTag_Enquiry_Value {
    pub one: M_EnquiryDataOne,
    pub two: M_EnquiryDataTwo,
    pub three: M_EnquiryDataThree,
    pub four: M_EnquiryDataFour,
    pub five: M_EnquiryDataFive,
    pub six: M_EnquiryDataSix,
}
impl Default for M_ModuleAttribTag_Enquiry_Value {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_ModuleAttribTag_FeatureGoldCert_Value {
    pub vendor: M_FeatureGoldCertVendor,
}
impl Default for M_ModuleAttribTag_FeatureGoldCert_Value {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_ModuleAttribTag_HardwareID_Value {
    pub buildpart: M_ASCIIString,
    pub buildrev: M_ASCIIString,
}
impl Default for M_ModuleAttribTag_HardwareID_Value {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_ModuleAttribTag_KAL_Value {
    pub hkal: M_KeyHash,
    pub kalpub: M_KeyData,
    pub mech_i: M_Mech,
}
impl Default for M_ModuleAttribTag_KAL_Value {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_ModuleAttribTag_KAL_Value {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_ModuleAttribTag_KAL_Value {{ hkal: {:?}, kalpub: {:?}, mech_i: {:?} }}",
            self.hkal, self.kalpub, self.mech_i
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_ModuleAttribTag_KLF_Value {
    pub hklf: M_KeyHash,
    pub klfpub: M_KeyData,
    pub mech_i: M_Mech,
}
impl Default for M_ModuleAttribTag_KLF_Value {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_ModuleAttribTag_KLF_Value {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_ModuleAttribTag_KLF_Value {{ hklf: {:?}, klfpub: {:?}, mech_i: {:?} }}",
            self.hklf, self.klfpub, self.mech_i
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_ModuleAttribTag_KLF2_Value {
    pub hklf2: M_KeyHash,
    pub klf2pub: M_KeyData,
    pub mech_i: M_Mech,
}
impl Default for M_ModuleAttribTag_KLF2_Value {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_ModuleAttribTag_KLF2_Value {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_ModuleAttribTag_KLF2_Value {{ hklf2: {:?}, klf2pub: {:?}, mech_i: {:?} }}",
            self.hklf2, self.klf2pub, self.mech_i
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_ModuleAttribTag_KLF3_Value {
    pub hklf3: M_KeyHashEx,
    pub klf3pub: M_KeyData,
    pub mech_i: M_Mech,
}
impl Default for M_ModuleAttribTag_KLF3_Value {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_ModuleAttribTag_KLF3_Value {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_ModuleAttribTag_KLF3_Value {{ hklf3: {:?}, klf3pub: {:?}, mech_i: {:?} }}",
            self.hklf3, self.klf3pub, self.mech_i
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_ModuleAttribTag_KML_Value {
    pub hkml: M_KeyHash,
    pub kmlpub: M_KeyData,
    pub mech_i: M_Mech,
}
impl Default for M_ModuleAttribTag_KML_Value {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_ModuleAttribTag_KML_Value {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_ModuleAttribTag_KML_Value {{ hkml: {:?}, kmlpub: {:?}, mech_i: {:?} }}",
            self.hkml, self.kmlpub, self.mech_i
        )
    }
}
pub type M_vec_KeyHashAttrib = *mut M_KeyHashAttrib;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_ModuleAttribTag_KMList_Value {
    pub n_hkms: ::core::ffi::c_int,
    pub hkms: M_vec_KeyHashAttrib,
}
impl Default for M_ModuleAttribTag_KMList_Value {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_NSOPerms_ops = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_NSOPerms {
    pub ops: M_NSOPerms_ops,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_ModuleAttribTag_KNSO_Value {
    pub hknso: M_KeyHash,
    pub publicperms: M_NSOPerms,
}
impl Default for M_ModuleAttribTag_KNSO_Value {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_ModuleAttribTag_KNSO_Value {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_ModuleAttribTag_KNSO_Value {{ hknso: {:?}, publicperms: {:?} }}",
            self.hknso, self.publicperms
        )
    }
}
pub type M_vec_ModKeyInfo = *mut M_ModKeyInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_ModuleAttribTag_ModKeyInfo_Value {
    pub n_kms: ::core::ffi::c_int,
    pub kms: M_vec_ModKeyInfo,
}
impl Default for M_ModuleAttribTag_ModKeyInfo_Value {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_ModuleAttribTag_PhysSerial_Value {
    pub physserial: M_ASCIIString,
}
impl Default for M_ModuleAttribTag_PhysSerial_Value {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_ModuleAttribTag_WarrantKLF2_Value {
    pub warrant: M_ByteBlock,
}
impl Default for M_ModuleAttribTag_WarrantKLF2_Value {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_ModuleAttribTag__Value {
    pub additionalinfo: M_ModuleAttribTag_AdditionalInfo_Value,
    pub challenge: M_ModuleAttribTag_Challenge_Value,
    pub esn: M_ModuleAttribTag_ESN_Value,
    pub enquiry: M_ModuleAttribTag_Enquiry_Value,
    pub featuregoldcert: M_ModuleAttribTag_FeatureGoldCert_Value,
    pub hardwareid: M_ModuleAttribTag_HardwareID_Value,
    pub kal: M_ModuleAttribTag_KAL_Value,
    pub klf: M_ModuleAttribTag_KLF_Value,
    pub klf2: M_ModuleAttribTag_KLF2_Value,
    pub klf3: M_ModuleAttribTag_KLF3_Value,
    pub kml: M_ModuleAttribTag_KML_Value,
    pub kmlist: M_ModuleAttribTag_KMList_Value,
    pub knso: M_ModuleAttribTag_KNSO_Value,
    pub modkeyinfo: M_ModuleAttribTag_ModKeyInfo_Value,
    pub physserial: M_ModuleAttribTag_PhysSerial_Value,
    pub warrantklf2: M_ModuleAttribTag_WarrantKLF2_Value,
}
impl Default for M_ModuleAttribTag__Value {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_ModuleAttribTag__Value {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_ModuleAttribTag__Value {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_ModuleAttrib {
    pub tag: M_ModuleAttribTag,
    pub value: M_ModuleAttribTag__Value,
}
impl Default for M_ModuleAttrib {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_ModuleAttrib {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_ModuleAttrib {{ tag: {:?}, value: {:?} }}",
            self.tag, self.value
        )
    }
}
pub type M_EnquiryRMData_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_EnquiryRMData {
    pub flags: M_EnquiryRMData_flags,
    pub stinfo: M_StatusErrorInfo,
    pub rm: M_RemoteModule,
}
impl Default for M_EnquiryRMData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_EnquiryRMData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_EnquiryRMData {{ flags: {:?}, stinfo: {:?}, rm: {:?} }}",
            self.flags, self.stinfo, self.rm
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_KeyHashAttrib {
    pub hk: M_KeyHash,
    pub mech_i: M_Mech,
    pub mech_c: M_Mech,
}
impl Default for M_KeyHashAttrib {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_KeyHashAttrib {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_KeyHashAttrib {{ hk: {:?}, mech_i: {:?}, mech_c: {:?} }}",
            self.hk, self.mech_i, self.mech_c
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_ModKeyInfo {
    pub v: M_Word,
    pub hk: M_KeyHash,
    pub type_: M_KeyType,
    pub mech_i: M_Mech,
    pub mech_c: M_Mech,
}
impl Default for M_ModKeyInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_ModKeyInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_ModKeyInfo {{ v: {:?}, hk: {:?}, type: {:?}, mech_i: {:?}, mech_c: {:?} }}",
            self.v, self.hk, self.type_, self.mech_i, self.mech_c
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_PlainText {
    pub type_: M_PlainTextType,
    pub data: M_PlainTextType__Data,
}
impl Default for M_PlainText {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_PlainText {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_PlainText {{ type: {:?}, data: {:?} }}",
            self.type_, self.data
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_KeyGenParams {
    pub type_: M_KeyType,
    pub params: M_KeyType__GenParams,
}
impl Default for M_KeyGenParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_KeyGenParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_KeyGenParams {{ type: {:?}, params: {:?} }}",
            self.type_, self.params
        )
    }
}
pub type M_Command_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_AddRemoteServerPermission_Args {
    pub permission: M_RemoteServerPermission,
}
impl Default for M_Cmd_AddRemoteServerPermission_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_AddRemoteServerPermission_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_AddRemoteServerPermission_Args {{ permission: {:?} }}",
            self.permission
        )
    }
}
pub type M_Cmd_AnonymousKnetiHash_Args_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_AnonymousKnetiHash_Args {
    pub flags: M_Cmd_AnonymousKnetiHash_Args_flags,
    pub rmodule: M_Word,
    pub addr: M_NetworkAddress,
}
impl Default for M_Cmd_AnonymousKnetiHash_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_AnonymousKnetiHash_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_AnonymousKnetiHash_Args {{ flags: {:?}, rmodule: {:?}, addr: {:?} }}",
            self.flags, self.rmodule, self.addr
        )
    }
}
pub type M_PathName = M_ASCIIString;
pub type M_Cmd_ApplyFeatureFile_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ApplyFeatureFile_Args {
    pub module: M_ModuleID,
    pub file: M_PathName,
    pub flags: M_Cmd_ApplyFeatureFile_Args_flags,
}
impl Default for M_Cmd_ApplyFeatureFile_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_BignumOp_Args_flags = M_Word;
pub type M_vec_Bignum = *mut M_Bignum;
pub type M_vec_StackOpVal = *mut M_StackOpVal;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_BignumOp_Args {
    pub flags: M_Cmd_BignumOp_Args_flags,
    pub n_stackin: ::core::ffi::c_int,
    pub stackin: M_vec_Bignum,
    pub n_ops: ::core::ffi::c_int,
    pub ops: M_vec_StackOpVal,
}
impl Default for M_Cmd_BignumOp_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_ChangeShareGroupPIN_Args_flags = M_Word;
pub type M_vec_ShareInfo = *mut M_ShareInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_PIN {
    pub bytes: [::core::ffi::c_uchar; 20usize],
    pub words: [M_Word; 5usize],
}
impl Default for M_PIN {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_PIN {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_PIN {{ union }}")
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ChangeShareGroupPIN_Args {
    pub flags: M_Cmd_ChangeShareGroupPIN_Args_flags,
    pub token: M_PhysToken,
    pub n_shares: ::core::ffi::c_int,
    pub shares: M_vec_ShareInfo,
    pub oldpin: *mut M_PIN,
    pub newpin: *mut M_PIN,
}
impl Default for M_Cmd_ChangeShareGroupPIN_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_ChangeSharePIN_Args_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_ShortHash {
    pub bytes: [::core::ffi::c_uchar; 10usize],
}
impl Default for M_ShortHash {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_ShortHash {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_ShortHash {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_ChangeSharePIN_Args {
    pub flags: M_Cmd_ChangeSharePIN_Args_flags,
    pub token: M_PhysToken,
    pub hkm: M_KMHash,
    pub hkt: M_ShortHash,
    pub i: M_Word,
    pub oldpin: *mut M_PIN,
    pub newpin: *mut M_PIN,
}
impl Default for M_Cmd_ChangeSharePIN_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_ChangeSharePIN_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_Cmd_ChangeSharePIN_Args {{ flags: {:?}, token: {:?}, hkm: {:?}, hkt: {:?}, i: {:?}, oldpin: {:?}, newpin: {:?} }}" , self . flags , self . token , self . hkm , self . hkt , self . i , self . oldpin , self . newpin)
    }
}
pub type M_Cmd_ChannelOpen_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ChannelOpen_Args {
    pub module: M_ModuleID,
    pub type_: M_ChannelType,
    pub flags: M_Cmd_ChannelOpen_Args_flags,
    pub mode: M_ChannelMode,
    pub mech: M_Mech,
    pub key: *mut M_KeyID,
    pub given_iv: *mut M_IV,
}
impl Default for M_Cmd_ChannelOpen_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_ChannelUpdate_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ChannelUpdate_Args {
    pub flags: M_Cmd_ChannelUpdate_Args_flags,
    pub idch: M_KeyID,
    pub input: M_ByteBlock,
}
impl Default for M_Cmd_ChannelUpdate_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_CheckUserAction_Args_flags = M_Word;
pub type M_UserActionID = M_Hash;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_UserActionInfo {
    pub id: M_UserActionID,
    pub perms: M_Word,
    pub restriction: M_ByteBlock,
}
impl Default for M_UserActionInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_UserActionInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_UserActionInfo {{ id: {:?}, perms: {:?}, restriction: {:?} }}",
            self.id, self.perms, self.restriction
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_CheckUserAction_Args {
    pub flags: M_Cmd_CheckUserAction_Args_flags,
    pub key: M_KeyID,
    pub request: M_UserActionInfo,
}
impl Default for M_Cmd_CheckUserAction_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_CheckUserAction_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_CheckUserAction_Args {{ flags: {:?}, key: {:?}, request: {:?} }}",
            self.flags, self.key, self.request
        )
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_CheckWorld_Args {
    pub module: M_ModuleID,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_ClearUnit_Args {
    pub module: M_ModuleID,
}
pub type M_Cmd_ClearUnitEx_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ClearUnitEx_Args {
    pub flags: M_Cmd_ClearUnitEx_Args_flags,
    pub module: M_ModuleID,
    pub mode: M_ModuleMode,
}
impl Default for M_Cmd_ClearUnitEx_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_ConfigurePoolModule_Args_flags = M_Word;
pub type M_vec_ModuleID = *mut M_ModuleID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ConfigurePoolModule_Args {
    pub flags: M_Cmd_ConfigurePoolModule_Args_flags,
    pub n_addmodules: ::core::ffi::c_int,
    pub addmodules: M_vec_ModuleID,
}
impl Default for M_Cmd_ConfigurePoolModule_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_CreateBuffer_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_CreateBuffer_Args {
    pub module: M_ModuleID,
    pub flags: M_Cmd_CreateBuffer_Args_flags,
    pub size: M_Word,
    pub params: *mut M_EncryptionParams,
}
impl Default for M_Cmd_CreateBuffer_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_CreateClient_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_CreateClientOne {
    pub pid: M_Word,
    pub name: M_StringUTF8,
}
impl Default for M_CreateClientOne {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_CreateClientVer_One_Data {
    pub one: M_CreateClientOne,
}
impl Default for M_CreateClientVer_One_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_CreateClientVer__Data {
    pub one: M_CreateClientVer_One_Data,
}
impl Default for M_CreateClientVer__Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_CreateClientVer__Data {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_CreateClientVer__Data {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_CreateClient_Args {
    pub flags: M_Cmd_CreateClient_Args_flags,
    pub version: M_CreateClientVer,
    pub data: M_CreateClientVer__Data,
}
impl Default for M_Cmd_CreateClient_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_CreateClient_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_CreateClient_Args {{ flags: {:?}, version: {:?}, data: {:?} }}",
            self.flags, self.version, self.data
        )
    }
}
pub type M_Cmd_CreateSEEConnection_Args_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_UUID {
    pub bytes: [::core::ffi::c_uchar; 16usize],
    pub words: [M_Word; 4usize],
}
impl Default for M_UUID {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_UUID {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_UUID {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_CreateSEEConnection_Args {
    pub flags: M_Cmd_CreateSEEConnection_Args_flags,
    pub containerid: M_UUID,
    pub n_identities: ::core::ffi::c_int,
    pub identities: M_vec_KeyHashEx,
}
impl Default for M_Cmd_CreateSEEConnection_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_CreateSEEConnection_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_Cmd_CreateSEEConnection_Args {{ flags: {:?}, containerid: {:?}, n_identities: {:?}, identities: {:?} }}" , self . flags , self . containerid , self . n_identities , self . identities)
    }
}
pub type M_Cmd_CreateSEEWorld_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_CreateSEEWorld_Args {
    pub flags: M_Cmd_CreateSEEWorld_Args_flags,
    pub buffer: M_KeyID,
}
pub type M_Cmd_Decrypt_Args_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_Decrypt_Args {
    pub flags: M_Cmd_Decrypt_Args_flags,
    pub key: M_KeyID,
    pub mech: M_Mech,
    pub cipher: M_CipherText,
    pub reply_type: M_PlainTextType,
}
impl Default for M_Cmd_Decrypt_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_Decrypt_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_Cmd_Decrypt_Args {{ flags: {:?}, key: {:?}, mech: {:?}, cipher: {:?}, reply_type: {:?} }}" , self . flags , self . key , self . mech , self . cipher , self . reply_type)
    }
}
pub type M_Cmd_DeriveKey_Args_flags = M_Word;
pub type M_vec_KeyID = *mut M_KeyID;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_DeriveKey_Args {
    pub flags: M_Cmd_DeriveKey_Args_flags,
    pub mech: M_DeriveMech,
    pub n_keys: ::core::ffi::c_int,
    pub keys: M_vec_KeyID,
    pub params: M_DeriveMech__DKParams,
}
impl Default for M_Cmd_DeriveKey_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_DeriveKey_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_Cmd_DeriveKey_Args {{ flags: {:?}, mech: {:?}, n_keys: {:?}, keys: {:?}, params: {:?} }}" , self . flags , self . mech , self . n_keys , self . keys , self . params)
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_Destroy_Args {
    pub key: M_KeyID,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_DevTest_Args {
    pub option: M_DevTestOp,
    pub size: M_Word,
    pub data: M_ByteBlock,
}
impl Default for M_Cmd_DevTest_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_Duplicate_Args {
    pub key: M_KeyID,
}
pub type M_Cmd_DynamicSlotCreateAssociation_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_DynamicSlotCreateAssociation_Args {
    pub flags: M_Cmd_DynamicSlotCreateAssociation_Args_flags,
    pub module: M_ModuleID,
    pub slot: M_SlotID,
}
pub type M_Cmd_DynamicSlotExchangeAPDUs_Args_flags = M_Word;
pub type M_SlotAssociationID = M_KeyID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_DynamicSlotExchangeAPDUs_Args {
    pub flags: M_Cmd_DynamicSlotExchangeAPDUs_Args_flags,
    pub payload: *mut M_ByteBlock,
    pub association: M_SlotAssociationID,
}
impl Default for M_Cmd_DynamicSlotExchangeAPDUs_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_DynamicSlotsConfigure_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_DynamicSlotsConfigure_Args {
    pub flags: M_Cmd_DynamicSlotsConfigure_Args_flags,
    pub slotcount: M_Word,
    pub module: M_ModuleID,
    pub maxcardidle: M_Word,
    pub maxroundtrip: M_Word,
}
pub type M_Cmd_DynamicSlotsConfigureQuery_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_DynamicSlotsConfigureQuery_Args {
    pub flags: M_Cmd_DynamicSlotsConfigureQuery_Args_flags,
    pub module: M_ModuleID,
    pub waittime: M_Word,
}
pub type M_Cmd_Encrypt_Args_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_Encrypt_Args {
    pub flags: M_Cmd_Encrypt_Args_flags,
    pub key: M_KeyID,
    pub mech: M_Mech,
    pub plain: M_PlainText,
    pub given_iv: *mut M_IV,
}
impl Default for M_Cmd_Encrypt_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_Encrypt_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_Cmd_Encrypt_Args {{ flags: {:?}, key: {:?}, mech: {:?}, plain: {:?}, given_iv: {:?} }}" , self . flags , self . key , self . mech , self . plain , self . given_iv)
    }
}
pub type M_Cmd_EraseFile_Args_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_EraseFile_Args {
    pub flags: M_Cmd_EraseFile_Args_flags,
    pub token: M_PhysToken,
    pub file: M_FileInfo,
}
impl Default for M_Cmd_EraseFile_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_EraseFile_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_EraseFile_Args {{ flags: {:?}, token: {:?}, file: {:?} }}",
            self.flags, self.token, self.file
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_EraseShare_Args {
    pub token: M_PhysToken,
    pub hkt: M_ShortHash,
    pub i: M_Word,
}
impl Default for M_Cmd_EraseShare_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_EraseShare_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_EraseShare_Args {{ token: {:?}, hkt: {:?}, i: {:?} }}",
            self.token, self.hkt, self.i
        )
    }
}
pub type M_Cmd_EraseWorld_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_EraseWorld_Args {
    pub module: M_ModuleID,
    pub flags: M_Cmd_EraseWorld_Args_flags,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_ExecuteSEEWill_Args {
    pub willid: M_Hash,
}
impl Default for M_Cmd_ExecuteSEEWill_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_ExecuteSEEWill_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_ExecuteSEEWill_Args {{ willid: {:?} }}",
            self.willid
        )
    }
}
pub type M_Cmd_ExistingClient_Args_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_ExistingClient_Args {
    pub flags: M_Cmd_ExistingClient_Args_flags,
    pub client: M_ClientID,
}
impl Default for M_Cmd_ExistingClient_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_ExistingClient_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_ExistingClient_Args {{ flags: {:?}, client: {:?} }}",
            self.flags, self.client
        )
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_Export_Args {
    pub key: M_KeyID,
}
pub type M_Cmd_ExportModule_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_ExportModule_Args {
    pub flags: M_Cmd_ExportModule_Args_flags,
    pub module: M_ModuleID,
}
pub type M_Cmd_ExportSlot_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_ExportSlot_Args {
    pub flags: M_Cmd_ExportSlot_Args_flags,
    pub module: M_ModuleID,
    pub slot: M_SlotID,
}
pub type M_LocalKeyID = M_KeyID;
pub type M_FTSessionID = M_LocalKeyID;
pub type M_Cmd_FTChecksum_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_FTChecksum_Args {
    pub id: M_FTSessionID,
    pub file: M_PathName,
    pub mech: M_Mech,
    pub flags: M_Cmd_FTChecksum_Args_flags,
}
impl Default for M_Cmd_FTChecksum_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_FTDelete_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_FTDelete_Args {
    pub id: M_FTSessionID,
    pub file: M_PathName,
    pub flags: M_Cmd_FTDelete_Args_flags,
}
impl Default for M_Cmd_FTDelete_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_FileTransferID = M_KeyID;
pub type M_Cmd_FTListDir_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_FTListDir_Args {
    pub id: M_FileTransferID,
    pub flags: M_Cmd_FTListDir_Args_flags,
}
pub type M_Cmd_FTRead_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_FTRead_Args {
    pub id: M_FileTransferID,
    pub flags: M_Cmd_FTRead_Args_flags,
}
pub type M_Cmd_FTSessionOpen_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_FTSessionOpen_Args {
    pub flags: M_Cmd_FTSessionOpen_Args_flags,
    pub remote: M_RemoteModule,
    pub local: *mut M_RemoteModule,
    pub n_keys: ::core::ffi::c_int,
    pub keys: M_vec_KeyID,
}
impl Default for M_Cmd_FTSessionOpen_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_FTStartListDir_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_FTStartListDir_Args {
    pub id: M_FTSessionID,
    pub dirname: M_PathName,
    pub flags: M_Cmd_FTStartListDir_Args_flags,
}
impl Default for M_Cmd_FTStartListDir_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_FTStartRead_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_FTStartRead_Args {
    pub id: M_FTSessionID,
    pub file: M_PathName,
    pub flags: M_Cmd_FTStartRead_Args_flags,
}
impl Default for M_Cmd_FTStartRead_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_FTStartWrite_Args_flags = M_Word;
pub type M_FTWriteParams_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_FTWriteParams {
    pub flags: M_FTWriteParams_flags,
    pub chunk: M_ByteBlock,
}
impl Default for M_FTWriteParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_FTStartWrite_Args {
    pub id: M_FTSessionID,
    pub file: M_PathName,
    pub flags: M_Cmd_FTStartWrite_Args_flags,
    pub writeparams: M_FTWriteParams,
}
impl Default for M_Cmd_FTStartWrite_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_FTStat_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_FTStat_Args {
    pub id: M_FTSessionID,
    pub file: M_PathName,
    pub flags: M_Cmd_FTStat_Args_flags,
}
impl Default for M_Cmd_FTStat_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_FTWrite_Args {
    pub id: M_FileTransferID,
    pub writeparams: M_FTWriteParams,
}
impl Default for M_Cmd_FTWrite_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_Fail_Args {
    pub module: M_ModuleID,
}
pub type M_Cmd_FailDriver_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_FailDriver_Args {
    pub flags: M_Cmd_FailDriver_Args_flags,
    pub module: M_ModuleID,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_FastSEEJob_Args {
    pub worldid: M_KeyID,
    pub seeargs: M_ByteBlock,
}
impl Default for M_Cmd_FastSEEJob_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_FileCopy_Args_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_FileCopy_Args {
    pub flags: M_Cmd_FileCopy_Args_flags,
    pub from: M_FileSpec,
    pub to: M_FileSpec,
}
impl Default for M_Cmd_FileCopy_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_FileCopy_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_FileCopy_Args {{ flags: {:?}, from: {:?}, to: {:?} }}",
            self.flags, self.from, self.to
        )
    }
}
pub type M_Cmd_FileCreate_Args_flags = M_Word;
pub type M_vec_PermissionGroup = *mut M_PermissionGroup;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_ACL {
    pub n_groups: ::core::ffi::c_int,
    pub groups: M_vec_PermissionGroup,
}
impl Default for M_ACL {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_FileCreate_Args {
    pub flags: M_Cmd_FileCreate_Args_flags,
    pub file: M_FileSpec,
    pub acl: M_ACL,
}
impl Default for M_Cmd_FileCreate_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_FileCreate_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_FileCreate_Args {{ flags: {:?}, file: {:?}, acl: {:?} }}",
            self.flags, self.file, self.acl
        )
    }
}
pub type M_Cmd_FileErase_Args_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_FileErase_Args {
    pub flags: M_Cmd_FileErase_Args_flags,
    pub file: M_FileSpec,
}
impl Default for M_Cmd_FileErase_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_FileErase_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_FileErase_Args {{ flags: {:?}, file: {:?} }}",
            self.flags, self.file
        )
    }
}
pub type M_Cmd_FileOp_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_NVMemRange {
    pub first: M_Word,
    pub last: M_Word,
}
pub type M_FileRange = M_NVMemRange;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_NVMemOpType_BitClear_OpVal {
    pub data: M_ByteBlock,
}
impl Default for M_NVMemOpType_BitClear_OpVal {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_NVMemOpType_BitSet_OpVal {
    pub data: M_ByteBlock,
}
impl Default for M_NVMemOpType_BitSet_OpVal {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_NVMemOpType_Decr_OpVal {
    pub count: M_Word,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_NVMemOpType_Incr_OpVal {
    pub count: M_Word,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_NVMemOpType_Resize_OpVal {
    pub size: M_Word,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_NVMemOpType_Write_OpVal {
    pub data: M_ByteBlock,
}
impl Default for M_NVMemOpType_Write_OpVal {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_NVMemOpType__OpVal {
    pub bitclear: M_NVMemOpType_BitClear_OpVal,
    pub bitset: M_NVMemOpType_BitSet_OpVal,
    pub decr: M_NVMemOpType_Decr_OpVal,
    pub incr: M_NVMemOpType_Incr_OpVal,
    pub resize: M_NVMemOpType_Resize_OpVal,
    pub write: M_NVMemOpType_Write_OpVal,
}
impl Default for M_NVMemOpType__OpVal {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_NVMemOpType__OpVal {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_NVMemOpType__OpVal {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_FileOp_Args {
    pub flags: M_Cmd_FileOp_Args_flags,
    pub file: M_FileSpec,
    pub range: *mut M_FileRange,
    pub op: M_NVMemOpType,
    pub val: M_NVMemOpType__OpVal,
}
impl Default for M_Cmd_FileOp_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_FileOp_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_FileOp_Args {{ flags: {:?}, file: {:?}, range: {:?}, op: {:?}, val: {:?} }}",
            self.flags, self.file, self.range, self.op, self.val
        )
    }
}
pub type M_Cmd_FirmwareAuthenticate_Args_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_FwAuthType_NFFHMAC1_Params {
    pub hkfc: M_KeyHash,
    pub iv: M_IV,
    pub chunk: M_Word,
    pub mackey: M_ByteBlock,
}
impl Default for M_FwAuthType_NFFHMAC1_Params {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_FwAuthType_NFFHMAC1_Params {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_FwAuthType_NFFHMAC1_Params {{ hkfc: {:?}, iv: {:?}, chunk: {:?}, mackey: {:?} }}",
            self.hkfc, self.iv, self.chunk, self.mackey
        )
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_FwAuthType_PRNG1_Params {
    pub variant: M_Word,
    pub index: M_Word,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_FwAuthType__Params {
    pub nffhmac1: M_FwAuthType_NFFHMAC1_Params,
    pub prng1: M_FwAuthType_PRNG1_Params,
}
impl Default for M_FwAuthType__Params {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_FwAuthType__Params {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_FwAuthType__Params {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_FirmwareAuthenticate_Args {
    pub module: M_ModuleID,
    pub flags: M_Cmd_FirmwareAuthenticate_Args_flags,
    pub type_: M_FwAuthType,
    pub challenge: M_FwAuthType__Params,
}
impl Default for M_Cmd_FirmwareAuthenticate_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_FirmwareAuthenticate_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_Cmd_FirmwareAuthenticate_Args {{ module: {:?}, flags: {:?}, type: {:?}, challenge: {:?} }}" , self . module , self . flags , self . type_ , self . challenge)
    }
}
pub type M_Cmd_ForeignTokenCmd_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_PhysTokenType_ISO7816_Args {
    pub header: M_Word,
    pub datain: M_ByteBlock,
    pub le: M_Word,
}
impl Default for M_PhysTokenType_ISO7816_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_PhysTokenType__Args {
    pub iso7816: M_PhysTokenType_ISO7816_Args,
}
impl Default for M_PhysTokenType__Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_PhysTokenType__Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_PhysTokenType__Args {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_ForeignTokenCmd_Args {
    pub flags: M_Cmd_ForeignTokenCmd_Args_flags,
    pub lock: M_KeyID,
    pub type_: M_PhysTokenType,
    pub args: M_PhysTokenType__Args,
}
impl Default for M_Cmd_ForeignTokenCmd_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_ForeignTokenCmd_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_ForeignTokenCmd_Args {{ flags: {:?}, lock: {:?}, type: {:?}, args: {:?} }}",
            self.flags, self.lock, self.type_, self.args
        )
    }
}
pub type M_Cmd_ForeignTokenOpen_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_ForeignTokenOpen_Args {
    pub flags: M_Cmd_ForeignTokenOpen_Args_flags,
    pub token: M_PhysToken,
}
pub type M_Cmd_FormatToken_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_FormatToken_Args {
    pub flags: M_Cmd_FormatToken_Args_flags,
    pub token: M_PhysToken,
    pub auth_key: *mut M_KMHash,
}
impl Default for M_Cmd_FormatToken_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_GenerateKLF_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_GenerateKLF_Args {
    pub module: M_ModuleID,
    pub flags: M_Cmd_GenerateKLF_Args_flags,
}
pub type M_Cmd_GenerateKey_Args_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_AppData {
    pub bytes: [::core::ffi::c_uchar; 64usize],
    pub words: [M_Word; 16usize],
}
impl Default for M_AppData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_AppData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_AppData {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_GenerateKey_Args {
    pub flags: M_Cmd_GenerateKey_Args_flags,
    pub module: M_ModuleID,
    pub params: M_KeyGenParams,
    pub acl: M_ACL,
    pub appdata: *mut M_AppData,
}
impl Default for M_Cmd_GenerateKey_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_GenerateKey_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_Cmd_GenerateKey_Args {{ flags: {:?}, module: {:?}, params: {:?}, acl: {:?}, appdata: {:?} }}" , self . flags , self . module , self . params , self . acl , self . appdata)
    }
}
pub type M_Cmd_GenerateKeyPair_Args_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_GenerateKeyPair_Args {
    pub flags: M_Cmd_GenerateKeyPair_Args_flags,
    pub module: M_ModuleID,
    pub params: M_KeyGenParams,
    pub aclpriv: M_ACL,
    pub aclpub: M_ACL,
    pub appdatapriv: *mut M_AppData,
    pub appdatapub: *mut M_AppData,
}
impl Default for M_Cmd_GenerateKeyPair_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_GenerateKeyPair_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_Cmd_GenerateKeyPair_Args {{ flags: {:?}, module: {:?}, params: {:?}, aclpriv: {:?}, aclpub: {:?}, appdatapriv: {:?}, appdatapub: {:?} }}" , self . flags , self . module , self . params , self . aclpriv , self . aclpub , self . appdatapriv , self . appdatapub)
    }
}
pub type M_TokenParams_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_TokenParams {
    pub flags: M_TokenParams_flags,
    pub sharesneeded: M_Word,
    pub sharestotal: M_Word,
    pub timelimit: M_Word,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_GenerateLogicalToken_Args {
    pub module: M_ModuleID,
    pub hkm: M_KMHash,
    pub params: M_TokenParams,
}
impl Default for M_Cmd_GenerateLogicalToken_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_GenerateLogicalToken_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_GenerateLogicalToken_Args {{ module: {:?}, hkm: {:?}, params: {:?} }}",
            self.module, self.hkm, self.params
        )
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_GeneratePrime_Args {
    pub lenbits: M_Word,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_GenerateRandom_Args {
    pub lenbytes: M_Word,
}
pub type M_Cmd_GetACL_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_GetACL_Args {
    pub flags: M_Cmd_GetACL_Args_flags,
    pub key: M_KeyID,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_GetAppData_Args {
    pub key: M_KeyID,
}
pub type M_Cmd_GetApplianceTime_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_GetApplianceTime_Args {
    pub module: M_ModuleID,
    pub flags: M_Cmd_GetApplianceTime_Args_flags,
}
pub type M_Cmd_GetApplianceUpgradeStatus_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_GetApplianceUpgradeStatus_Args {
    pub module: M_ModuleID,
    pub flags: M_Cmd_GetApplianceUpgradeStatus_Args_flags,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_GetApplianceVersion_Args {
    pub module: M_ModuleID,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_GetChallenge_Args {
    pub module: M_ModuleID,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_GetHardwareError_Args {
    pub module: M_ModuleID,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_GetKLF_Args {
    pub module: M_ModuleID,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_GetKLF2_Args {
    pub module: M_ModuleID,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_GetKML_Args {
    pub module: M_ModuleID,
}
pub type M_Cmd_GetKMList_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_GetKMList_Args {
    pub module: M_ModuleID,
    pub flags: M_Cmd_GetKMList_Args_flags,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_GetKeyInfo_Args {
    pub key: M_KeyID,
}
pub type M_Cmd_GetKeyInfoEx_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_GetKeyInfoEx_Args {
    pub flags: M_Cmd_GetKeyInfoEx_Args_flags,
    pub key: M_KeyID,
}
pub type M_Cmd_GetKnetiPub_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_GetKnetiPub_Args {
    pub flags: M_Cmd_GetKnetiPub_Args_flags,
    pub module: M_ModuleID,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_GetLogicalTokenInfo_Args {
    pub idkt: M_KeyID,
}
pub type M_Cmd_GetLogicalTokenInfoEx_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_GetLogicalTokenInfoEx_Args {
    pub flags: M_Cmd_GetLogicalTokenInfoEx_Args_flags,
    pub idkt: M_KeyID,
}
pub type M_Cmd_GetModuleState_Args_flags = M_Word;
pub type M_vec_ModuleAttribTag = *mut M_ModuleAttribTag;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_wrap_vec_ModuleAttribTag {
    pub n: ::core::ffi::c_int,
    pub v: M_vec_ModuleAttribTag,
}
impl Default for M_wrap_vec_ModuleAttribTag {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_GetModuleState_Args {
    pub module: M_ModuleID,
    pub flags: M_Cmd_GetModuleState_Args_flags,
    pub attribs: *mut M_wrap_vec_ModuleAttribTag,
}
impl Default for M_Cmd_GetModuleState_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_GetMonitorLoaderState_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_GetMonitorLoaderState_Args {
    pub module: M_ModuleID,
    pub flags: M_Cmd_GetMonitorLoaderState_Args_flags,
}
pub type M_Cmd_GetPoolInfo_Args_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_PoolInfo_ClientInfo_ReqData {
    pub client: M_CipherText,
}
impl Default for M_PoolInfo_ClientInfo_ReqData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_PoolInfo_ClientInfo_ReqData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_PoolInfo_ClientInfo_ReqData {{ client: {:?} }}",
            self.client
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_PoolInfo_KeyInfo_ReqData {
    pub key: M_CipherText,
}
impl Default for M_PoolInfo_KeyInfo_ReqData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_PoolInfo_KeyInfo_ReqData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_PoolInfo_KeyInfo_ReqData {{ key: {:?} }}", self.key)
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_PoolInfo_ModuleInfo_ReqData {
    pub module: M_Word,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_PoolInfo__ReqData {
    pub clientinfo: M_PoolInfo_ClientInfo_ReqData,
    pub keyinfo: M_PoolInfo_KeyInfo_ReqData,
    pub moduleinfo: M_PoolInfo_ModuleInfo_ReqData,
}
impl Default for M_PoolInfo__ReqData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_PoolInfo__ReqData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_PoolInfo__ReqData {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_GetPoolInfo_Args {
    pub flags: M_Cmd_GetPoolInfo_Args_flags,
    pub type_: M_PoolInfo,
    pub req: M_PoolInfo__ReqData,
}
impl Default for M_Cmd_GetPoolInfo_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_GetPoolInfo_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_GetPoolInfo_Args {{ flags: {:?}, type: {:?}, req: {:?} }}",
            self.flags, self.type_, self.req
        )
    }
}
pub type M_Cmd_GetPublishedObject_Args_flags = M_Word;
pub type M_HostServiceName = M_ASCIIString;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_GetPublishedObject_Args {
    pub flags: M_Cmd_GetPublishedObject_Args_flags,
    pub name: M_HostServiceName,
    pub module: M_ModuleID,
}
impl Default for M_Cmd_GetPublishedObject_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_GetRTC_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_GetRTC_Args {
    pub module: M_ModuleID,
    pub flags: M_Cmd_GetRTC_Args_flags,
}
pub type M_Cmd_GetServerConfig_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_GetServerConfig_Args {
    pub flags: M_Cmd_GetServerConfig_Args_flags,
}
pub type M_Cmd_GetShareACL_Args_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_GetShareACL_Args {
    pub flags: M_Cmd_GetShareACL_Args_flags,
    pub token: M_PhysToken,
    pub hkt: M_ShortHash,
    pub i: M_Word,
}
impl Default for M_Cmd_GetShareACL_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_GetShareACL_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_GetShareACL_Args {{ flags: {:?}, token: {:?}, hkt: {:?}, i: {:?} }}",
            self.flags, self.token, self.hkt, self.i
        )
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_GetSlotInfo_Args {
    pub module: M_ModuleID,
    pub slot: M_SlotID,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_GetSlotList_Args {
    pub module: M_ModuleID,
}
pub type M_Cmd_GetTicket_Args_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_TicketDestination_NamedClient_Details {
    pub hclientid: M_Hash,
}
impl Default for M_TicketDestination_NamedClient_Details {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_TicketDestination_NamedClient_Details {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_TicketDestination_NamedClient_Details {{ hclientid: {:?} }}",
            self.hclientid
        )
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_TicketDestination_NamedSEEWorld_Details {
    pub world: M_KeyID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_TicketDestination__Details {
    pub namedclient: M_TicketDestination_NamedClient_Details,
    pub namedseeworld: M_TicketDestination_NamedSEEWorld_Details,
}
impl Default for M_TicketDestination__Details {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_TicketDestination__Details {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_TicketDestination__Details {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_GetTicket_Args {
    pub flags: M_Cmd_GetTicket_Args_flags,
    pub obj: M_KeyID,
    pub dest: M_TicketDestination,
    pub destspec: M_TicketDestination__Details,
}
impl Default for M_Cmd_GetTicket_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_GetTicket_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_GetTicket_Args {{ flags: {:?}, obj: {:?}, dest: {:?}, destspec: {:?} }}",
            self.flags, self.obj, self.dest, self.destspec
        )
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_GetWhichModule_Args {
    pub key: M_KeyID,
}
pub type M_Cmd_GetWorldSigners_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_GetWorldSigners_Args {
    pub flags: M_Cmd_GetWorldSigners_Args_flags,
}
pub type M_Cmd_Hash_Args_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_Hash_Args {
    pub flags: M_Cmd_Hash_Args_flags,
    pub mech: M_Mech,
    pub plain: M_PlainText,
}
impl Default for M_Cmd_Hash_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_Hash_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_Hash_Args {{ flags: {:?}, mech: {:?}, plain: {:?} }}",
            self.flags, self.mech, self.plain
        )
    }
}
pub type M_Cmd_HotReset_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_HotReset_Args {
    pub flags: M_Cmd_HotReset_Args_flags,
    pub module: M_ModuleID,
}
pub type M_Cmd_IOBoardReprogram_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_IOBoardReprogram_Args {
    pub flags: M_Cmd_IOBoardReprogram_Args_flags,
    pub buffer: M_KeyID,
}
pub type M_ImpathID = M_KeyID;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_ImpathGetInfo_Args {
    pub imp: M_ImpathID,
}
pub type M_Cmd_ImpathKXBegin_Args_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_ImpathKXBegin_Args {
    pub flags: M_Cmd_ImpathKXBegin_Args_flags,
    pub module: M_ModuleID,
    pub me: M_RemoteModule,
    pub him: M_RemoteModule,
    pub hisgroups: M_ImpathKXGroupSelection,
    pub n: M_Nonce,
    pub n_keys: ::core::ffi::c_int,
    pub keys: M_vec_KeyID,
}
impl Default for M_Cmd_ImpathKXBegin_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_ImpathKXBegin_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_Cmd_ImpathKXBegin_Args {{ flags: {:?}, module: {:?}, me: {:?}, him: {:?}, hisgroups: {:?}, n: {:?}, n_keys: {:?}, keys: {:?} }}" , self . flags , self . module , self . me , self . him , self . hisgroups , self . n , self . n_keys , self . keys)
    }
}
pub type M_Cmd_ImpathKXFinish_Args_flags = M_Word;
pub type M_vec_ImpathWarrant = *mut M_ImpathWarrant;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_wrap_vec_ImpathWarrant {
    pub n: ::core::ffi::c_int,
    pub v: M_vec_ImpathWarrant,
}
impl Default for M_wrap_vec_ImpathWarrant {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ImpathKXFinish_Args {
    pub flags: M_Cmd_ImpathKXFinish_Args_flags,
    pub imp: M_ImpathID,
    pub addr: *mut M_NetworkAddress,
    pub n_keys: ::core::ffi::c_int,
    pub keys: M_vec_KeyID,
    pub kx: M_ByteBlock,
    pub warrants: *mut M_wrap_vec_ImpathWarrant,
}
impl Default for M_Cmd_ImpathKXFinish_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ImpathReceive_Args {
    pub imp: M_ImpathID,
    pub cipher: M_ByteBlock,
}
impl Default for M_Cmd_ImpathReceive_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_ImpathSend_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ImpathSend_Args {
    pub flags: M_Cmd_ImpathSend_Args_flags,
    pub imp: M_ImpathID,
    pub data: M_ByteBlock,
}
impl Default for M_Cmd_ImpathSend_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_Import_Args {
    pub module: M_ModuleID,
    pub data: M_KeyData,
    pub acl: M_ACL,
    pub appdata: M_AppData,
}
impl Default for M_Cmd_Import_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_Import_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_Import_Args {{ module: {:?}, data: {:?}, acl: {:?}, appdata: {:?} }}",
            self.module, self.data, self.acl, self.appdata
        )
    }
}
pub type M_Cmd_ImportModule_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ImportModule_Args {
    pub flags: M_Cmd_ImportModule_Args_flags,
    pub module: M_ModuleID,
    pub us: M_RemoteModule,
    pub rm: M_RemoteModule,
}
impl Default for M_Cmd_ImportModule_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_ImportSlot_Args_flags = M_Word;
pub type M_RemoteSlotID = M_Word;
pub type M_vec_Certificate = *mut M_Certificate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_CertificateList {
    pub n_certs: ::core::ffi::c_int,
    pub certs: M_vec_Certificate,
}
impl Default for M_CertificateList {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ImportSlot_Args {
    pub flags: M_Cmd_ImportSlot_Args_flags,
    pub to: M_RemoteModule,
    pub from: M_RemoteModule,
    pub rslot: M_RemoteSlotID,
    pub sendcert: M_CertificateList,
}
impl Default for M_Cmd_ImportSlot_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_InitialiseUnit_Args {
    pub module: M_ModuleID,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_InitialiseUnitEx_Args {
    pub flags: M_InitModeFlags,
    pub module: M_ModuleID,
    pub kml: M_KMLType,
}
impl Default for M_Cmd_InitialiseUnitEx_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_InsertSoftToken_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_InsertSoftToken_Args {
    pub flags: M_Cmd_InsertSoftToken_Args_flags,
    pub token: M_PhysToken,
    pub data: M_ByteBlock,
}
impl Default for M_Cmd_InsertSoftToken_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ListRemoteServerPermission_Args {
    pub op: M_RemoteServerOp,
}
impl Default for M_Cmd_ListRemoteServerPermission_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_ListRemoteServerPermissionEx_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ListRemoteServerPermissionEx_Args {
    pub flags: M_Cmd_ListRemoteServerPermissionEx_Args_flags,
    pub op: M_RemoteServerOp,
    pub offset: M_Word,
}
impl Default for M_Cmd_ListRemoteServerPermissionEx_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_LoadBlob_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_LoadBlob_Args {
    pub flags: M_Cmd_LoadBlob_Args_flags,
    pub module: M_ModuleID,
    pub blob: M_ByteBlock,
    pub idkb: *mut M_KeyID,
    pub file: *mut M_FileSpec,
}
impl Default for M_Cmd_LoadBlob_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_LoadBuffer_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_LoadBuffer_Args {
    pub id: M_KeyID,
    pub flags: M_Cmd_LoadBuffer_Args_flags,
    pub chunk: M_ByteBlock,
    pub flashsegment: *mut M_Word,
}
impl Default for M_Cmd_LoadBuffer_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_LoadLogicalToken_Args {
    pub module: M_ModuleID,
    pub hkt: M_TokenHash,
    pub hkm: M_KMHash,
    pub params: M_TokenParams,
}
impl Default for M_Cmd_LoadLogicalToken_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_LoadLogicalToken_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_LoadLogicalToken_Args {{ module: {:?}, hkt: {:?}, hkm: {:?}, params: {:?} }}",
            self.module, self.hkt, self.hkm, self.params
        )
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_LoadMonitor_Args {
    pub module: M_ModuleID,
}
pub type M_Cmd_LoadRaw_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_LoadRaw_Args {
    pub module: M_ModuleID,
    pub flags: M_Cmd_LoadRaw_Args_flags,
    pub absoluteaddr: M_Word,
    pub data: M_ByteBlock,
}
impl Default for M_Cmd_LoadRaw_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_Maintenance_Args {
    pub module: M_ModuleID,
}
pub type M_Cmd_MakeBlob_Args_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_MakeBlob_Args {
    pub flags: M_Cmd_MakeBlob_Args_flags,
    pub format: M_BlobFormat,
    pub idka: M_KeyID,
    pub blobkey: M_BlobFormat__MkBlobParams,
    pub acl: *mut M_ACL,
    pub file: *mut M_MakeBlobFile,
}
impl Default for M_Cmd_MakeBlob_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_MakeBlob_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_Cmd_MakeBlob_Args {{ flags: {:?}, format: {:?}, idka: {:?}, blobkey: {:?}, acl: {:?}, file: {:?} }}" , self . flags , self . format , self . idka , self . blobkey , self . acl , self . file)
    }
}
pub type M_Cmd_MakeSEEWill_Args_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_MakeSEEWill_Args {
    pub willid: M_Hash,
    pub flags: M_Cmd_MakeSEEWill_Args_flags,
    pub worldid: M_KeyID,
    pub will: M_ByteBlock,
}
impl Default for M_Cmd_MakeSEEWill_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_MakeSEEWill_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_MakeSEEWill_Args {{ willid: {:?}, flags: {:?}, worldid: {:?}, will: {:?} }}",
            self.willid, self.flags, self.worldid, self.will
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_MergeKeyIDs_Args {
    pub n_keys: ::core::ffi::c_int,
    pub keys: M_vec_KeyID,
}
impl Default for M_Cmd_MergeKeyIDs_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ModExp_Args {
    pub a: M_Bignum,
    pub p: M_Bignum,
    pub n: M_Bignum,
}
impl Default for M_Cmd_ModExp_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ModExpCrt_Args {
    pub a: M_Bignum,
    pub p: M_Bignum,
    pub q: M_Bignum,
    pub dmp1: M_Bignum,
    pub dmq1: M_Bignum,
    pub iqmp: M_Bignum,
}
impl Default for M_Cmd_ModExpCrt_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_ModuleInfo_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_ModuleInfo_Args {
    pub module: M_ModuleID,
    pub flags: M_Cmd_ModuleInfo_Args_flags,
    pub format: M_Word,
}
pub type M_Cmd_NVMemAlloc_Args_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_NVMemAlloc_Args {
    pub module: M_ModuleID,
    pub flags: M_Cmd_NVMemAlloc_Args_flags,
    pub info: M_FileInfo,
    pub acl: M_ACL,
}
impl Default for M_Cmd_NVMemAlloc_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_NVMemAlloc_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_NVMemAlloc_Args {{ module: {:?}, flags: {:?}, info: {:?}, acl: {:?} }}",
            self.module, self.flags, self.info, self.acl
        )
    }
}
pub type M_Cmd_NVMemFree_Args_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_NVMemFree_Args {
    pub module: M_ModuleID,
    pub flags: M_Cmd_NVMemFree_Args_flags,
    pub name: M_FileID,
}
impl Default for M_Cmd_NVMemFree_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_NVMemFree_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_NVMemFree_Args {{ module: {:?}, flags: {:?}, name: {:?} }}",
            self.module, self.flags, self.name
        )
    }
}
pub type M_Cmd_NVMemList_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_NVMemList_Args {
    pub module: M_ModuleID,
    pub flags: M_Cmd_NVMemList_Args_flags,
}
pub type M_Cmd_NVMemOp_Args_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_NVMemOp_Args {
    pub module: M_ModuleID,
    pub flags: M_Cmd_NVMemOp_Args_flags,
    pub name: M_FileID,
    pub range: *mut M_NVMemRange,
    pub op: M_NVMemOpType,
    pub val: M_NVMemOpType__OpVal,
}
impl Default for M_Cmd_NVMemOp_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_NVMemOp_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_Cmd_NVMemOp_Args {{ module: {:?}, flags: {:?}, name: {:?}, range: {:?}, op: {:?}, val: {:?} }}" , self . module , self . flags , self . name , self . range , self . op , self . val)
    }
}
pub type M_Cmd_NewClient_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_NewClient_Args {
    pub flags: M_Cmd_NewClient_Args_flags,
}
pub type M_Cmd_NewEnquiry_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_NewEnquiry_Args {
    pub flags: M_Cmd_NewEnquiry_Args_flags,
    pub version: M_Word,
    pub module: M_ModuleID,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_NoOp_Args {
    pub module: M_ModuleID,
}
pub type M_Cmd_PauseForNotifications_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_PauseForNotifications_Args {
    pub module: M_ModuleID,
    pub flags: M_Cmd_PauseForNotifications_Args_flags,
    pub ms: M_Word,
}
pub type M_Cmd_PollModuleState_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_PollModuleState_Args {
    pub flags: M_Cmd_PollModuleState_Args_flags,
    pub module: M_ModuleID,
}
pub type M_Cmd_PollSlotList_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_PollSlotList_Args {
    pub flags: M_Cmd_PollSlotList_Args_flags,
    pub module: M_ModuleID,
}
pub type M_Cmd_ProductionSetup_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ProductionSetup_Args {
    pub module: M_ModuleID,
    pub flags: M_Cmd_ProductionSetup_Args_flags,
    pub option: M_Word,
    pub data: M_ByteBlock,
}
impl Default for M_Cmd_ProductionSetup_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_ProgrammingBegin_Args {
    pub module: M_ModuleID,
    pub hkfi: M_KeyHash,
    pub hkfc: M_KeyHash,
    pub sdhash: M_Hash,
    pub sd: M_ByteBlock,
    pub sig: M_CipherText,
}
impl Default for M_Cmd_ProgrammingBegin_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_ProgrammingBegin_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_Cmd_ProgrammingBegin_Args {{ module: {:?}, hkfi: {:?}, hkfc: {:?}, sdhash: {:?}, sd: {:?}, sig: {:?} }}" , self . module , self . hkfi , self . hkfc , self . sdhash , self . sd , self . sig)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_ProgrammingBeginChunk_Args {
    pub module: M_ModuleID,
    pub index: M_Word,
    pub sdhash: M_Hash,
    pub iv: M_IV,
}
impl Default for M_Cmd_ProgrammingBeginChunk_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_ProgrammingBeginChunk_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_Cmd_ProgrammingBeginChunk_Args {{ module: {:?}, index: {:?}, sdhash: {:?}, iv: {:?} }}" , self . module , self . index , self . sdhash , self . iv)
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_ProgrammingEnd_Args {
    pub module: M_ModuleID,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_ProgrammingEndChunk_Args {
    pub module: M_ModuleID,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_ProgrammingGetKeyList_Args {
    pub module: M_ModuleID,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ProgrammingLoadBlock_Args {
    pub module: M_ModuleID,
    pub offsetincipher: M_Word,
    pub data: M_ByteBlock,
}
impl Default for M_Cmd_ProgrammingLoadBlock_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_QueryLongJobs_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_QueryLongJobs_Args {
    pub module: M_ModuleID,
    pub flags: M_Cmd_QueryLongJobs_Args_flags,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_RSAImmedSignDecrypt_Args {
    pub m: M_Bignum,
    pub k_p: M_Bignum,
    pub k_q: M_Bignum,
    pub k_dmp1: M_Bignum,
    pub k_dmq1: M_Bignum,
    pub k_iqmp: M_Bignum,
}
impl Default for M_Cmd_RSAImmedSignDecrypt_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_RSAImmedVerifyEncrypt_Args {
    pub m: M_Bignum,
    pub k_e: M_Bignum,
    pub k_n: M_Bignum,
}
impl Default for M_Cmd_RSAImmedVerifyEncrypt_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_ReReadConfig_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ReReadConfig_Args {
    pub flags: M_Cmd_ReReadConfig_Args_flags,
    pub unused: M_ASCIIString,
}
impl Default for M_Cmd_ReReadConfig_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_ReadFile_Args_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_ReadFile_Args {
    pub flags: M_Cmd_ReadFile_Args_flags,
    pub token: M_PhysToken,
    pub file: M_FileInfo,
}
impl Default for M_Cmd_ReadFile_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_ReadFile_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_ReadFile_Args {{ flags: {:?}, token: {:?}, file: {:?} }}",
            self.flags, self.token, self.file
        )
    }
}
pub type M_Cmd_ReadShare_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ReadShare_Args {
    pub flags: M_Cmd_ReadShare_Args_flags,
    pub token: M_PhysToken,
    pub idkt: M_KeyID,
    pub i: M_Word,
    pub pin: *mut M_PIN,
}
impl Default for M_Cmd_ReadShare_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_ReadSoftTokenShare_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ReadSoftTokenShare_Args {
    pub flags: M_Cmd_ReadSoftTokenShare_Args_flags,
    pub token: M_PhysToken,
    pub data: M_ByteBlock,
    pub idkt: M_KeyID,
    pub i: M_Word,
    pub pin: *mut M_PIN,
}
impl Default for M_Cmd_ReadSoftTokenShare_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_ReceiveKey_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ReceiveKey_Args {
    pub flags: M_Cmd_ReceiveKey_Args_flags,
    pub imp: M_ImpathID,
    pub blob: M_ByteBlock,
}
impl Default for M_Cmd_ReceiveKey_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_ReceiveShare_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ReceiveShare_Args {
    pub flags: M_Cmd_ReceiveShare_Args_flags,
    pub imp: M_ImpathID,
    pub idkt: M_KeyID,
    pub share: M_ByteBlock,
    pub pin: *mut M_PIN,
}
impl Default for M_Cmd_ReceiveShare_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_RedeemTicket_Args_flags = M_Word;
pub type M_nest_Ticket = M_ByteBlock;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_RedeemTicket_Args {
    pub flags: M_Cmd_RedeemTicket_Args_flags,
    pub module: M_ModuleID,
    pub ticket: M_nest_Ticket,
}
impl Default for M_Cmd_RedeemTicket_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_RemoteReboot_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_RemoteReboot_Args {
    pub flags: M_Cmd_RemoteReboot_Args_flags,
    pub module: M_ModuleID,
}
pub type M_Cmd_RemoteSlots_Args_flags = M_Word;
pub type M_vec_RemoteSlotParams = *mut M_RemoteSlotParams;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_RemoteSlots_Args {
    pub flags: M_Cmd_RemoteSlots_Args_flags,
    pub n_rsparams: ::core::ffi::c_int,
    pub rsparams: M_vec_RemoteSlotParams,
}
impl Default for M_Cmd_RemoteSlots_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_RemoveKM_Args_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_RemoveKM_Args {
    pub module: M_ModuleID,
    pub flags: M_Cmd_RemoveKM_Args_flags,
    pub hkm: M_KMHash,
}
impl Default for M_Cmd_RemoveKM_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_RemoveKM_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_RemoveKM_Args {{ module: {:?}, flags: {:?}, hkm: {:?} }}",
            self.module, self.flags, self.hkm
        )
    }
}
pub type M_Cmd_RemovePublishedObject_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_RemovePublishedObject_Args {
    pub name: M_HostServiceName,
    pub module: M_ModuleID,
    pub flags: M_Cmd_RemovePublishedObject_Args_flags,
}
impl Default for M_Cmd_RemovePublishedObject_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_RemoveRemoteServerPermission_Args {
    pub permid: M_Word,
}
pub type M_Cmd_RemoveSoftToken_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_RemoveSoftToken_Args {
    pub flags: M_Cmd_RemoveSoftToken_Args_flags,
    pub token: M_PhysToken,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_ReportWorldState_Args {
    pub flags: M_Word,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_RetryFailedModule_Args {
    pub module: M_ModuleID,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_SEEJob_Args {
    pub worldid: M_KeyID,
    pub seeargs: M_ByteBlock,
}
impl Default for M_Cmd_SEEJob_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_SendKey_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_SendKey_Args {
    pub flags: M_Cmd_SendKey_Args_flags,
    pub imp: M_ImpathID,
    pub idka: M_KeyID,
    pub acl: *mut M_ACL,
}
impl Default for M_Cmd_SendKey_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_SendShare_Args_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_SendShare_Args {
    pub flags: M_Cmd_SendShare_Args_flags,
    pub imp: M_ImpathID,
    pub token: M_PhysToken,
    pub i: M_Word,
    pub hkm: M_KMHash,
    pub hkt: M_TokenHash,
    pub pin: *mut M_PIN,
}
impl Default for M_Cmd_SendShare_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_SendShare_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_Cmd_SendShare_Args {{ flags: {:?}, imp: {:?}, token: {:?}, i: {:?}, hkm: {:?}, hkt: {:?}, pin: {:?} }}" , self . flags , self . imp , self . token , self . i , self . hkm , self . hkt , self . pin)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ServerNoOp_Args {
    pub module: M_ModuleID,
    pub payload: M_ByteBlock,
    pub replylen: M_Word,
}
impl Default for M_Cmd_ServerNoOp_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_ServerSendShare_Args_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_ServerSendShare_Args {
    pub flags: M_Cmd_ServerSendShare_Args_flags,
    pub imp: M_MustBeZeroWord,
    pub token: M_PhysToken,
    pub i: M_Word,
    pub hkm: M_KMHash,
    pub hkt: M_TokenHash,
    pub pin: *mut M_PIN,
}
impl Default for M_Cmd_ServerSendShare_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_ServerSendShare_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_Cmd_ServerSendShare_Args {{ flags: {:?}, imp: {:?}, token: {:?}, i: {:?}, hkm: {:?}, hkt: {:?}, pin: {:?} }}" , self . flags , self . imp , self . token , self . i , self . hkm , self . hkt , self . pin)
    }
}
pub type M_Cmd_SessionCreate_Args_flags = M_Word;
pub type M_SessionID = M_Word64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_SessionCreate_Args {
    pub flags: M_Cmd_SessionCreate_Args_flags,
    pub v: M_Word,
    pub description: M_ASCIIString,
    pub clientsession: M_SessionID,
}
impl Default for M_Cmd_SessionCreate_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_SessionDestroy_Args {
    pub session: M_SessionID,
}
pub type M_Cmd_SetACL_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_SetACL_Args {
    pub flags: M_Cmd_SetACL_Args_flags,
    pub key: M_KeyID,
    pub newacl: M_ACL,
}
impl Default for M_Cmd_SetACL_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_SetAppData_Args {
    pub key: M_KeyID,
    pub appdata: M_AppData,
}
impl Default for M_Cmd_SetAppData_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_SetAppData_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_SetAppData_Args {{ key: {:?}, appdata: {:?} }}",
            self.key, self.appdata
        )
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_RTCTime {
    pub currenttimehigh: M_Word,
    pub currenttimelow: M_Word,
    pub currenttimenanos: M_Word,
    pub precision: M_Word,
}
pub type M_Cmd_SetApplianceTime_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_SetApplianceTime_Args {
    pub module: M_ModuleID,
    pub time: M_RTCTime,
    pub flags: M_Cmd_SetApplianceTime_Args_flags,
}
pub type M_Cmd_SetApplianceUpgradeStatus_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_SetApplianceUpgradeStatus_Args {
    pub module: M_ModuleID,
    pub error: M_Status,
    pub stage: M_UpgradeState,
    pub flags: M_Cmd_SetApplianceUpgradeStatus_Args_flags,
}
impl Default for M_Cmd_SetApplianceUpgradeStatus_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_SetKM_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_SetKM_Args {
    pub module: M_ModuleID,
    pub flags: M_Cmd_SetKM_Args_flags,
    pub idka: M_KeyID,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_SetMaxNumClients_Args {
    pub max: M_Word,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_SetNSOPerms_Args {
    pub module: M_ModuleID,
    pub flags: M_NSOPermsModeFlags,
    pub hknso: M_KeyHash,
    pub publicperms: M_NSOPerms,
}
impl Default for M_Cmd_SetNSOPerms_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_SetNSOPerms_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_Cmd_SetNSOPerms_Args {{ module: {:?}, flags: {:?}, hknso: {:?}, publicperms: {:?} }}" , self . module , self . flags , self . hknso , self . publicperms)
    }
}
pub type M_Cmd_SetPrimarySlot_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_SetPrimarySlot_Args {
    pub flags: M_Cmd_SetPrimarySlot_Args_flags,
    pub module: M_ModuleID,
    pub slot: M_Word,
}
pub type M_Cmd_SetPublishedObject_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_SetPublishedObject_Args {
    pub flags: M_Cmd_SetPublishedObject_Args_flags,
    pub name: M_HostServiceName,
    pub module: M_ModuleID,
    pub object: *mut M_KeyID,
    pub data: *mut M_ByteBlock,
}
impl Default for M_Cmd_SetPublishedObject_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_SetRTC_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_SetRTC_Args {
    pub module: M_ModuleID,
    pub flags: M_Cmd_SetRTC_Args_flags,
    pub time: M_RTCTime,
}
pub type M_Cmd_SetSEEMachine_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_SetSEEMachine_Args {
    pub flags: M_Cmd_SetSEEMachine_Args_flags,
    pub buffer: M_KeyID,
}
pub type M_Cmd_Sign_Args_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_Sign_Args {
    pub flags: M_Cmd_Sign_Args_flags,
    pub key: M_KeyID,
    pub mech: M_Mech,
    pub plain: M_PlainText,
    pub given_iv: *mut M_IV,
}
impl Default for M_Cmd_Sign_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_Sign_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_Sign_Args {{ flags: {:?}, key: {:?}, mech: {:?}, plain: {:?}, given_iv: {:?} }}",
            self.flags, self.key, self.mech, self.plain, self.given_iv
        )
    }
}
pub type M_Cmd_SignModuleState_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_SignerType_AppKey_SignerInfo {
    pub key: M_KeyID,
    pub mech: M_Mech,
}
impl Default for M_SignerType_AppKey_SignerInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_SignerType__SignerInfo {
    pub appkey: M_SignerType_AppKey_SignerInfo,
}
impl Default for M_SignerType__SignerInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_SignerType__SignerInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_SignerType__SignerInfo {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_SignModuleState_Args {
    pub module: M_ModuleID,
    pub flags: M_Cmd_SignModuleState_Args_flags,
    pub signer: M_SignerType,
    pub siginfo: M_SignerType__SignerInfo,
    pub challenge: *mut M_Nonce,
    pub attribs: *mut M_wrap_vec_ModuleAttribTag,
}
impl Default for M_Cmd_SignModuleState_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_SignModuleState_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_Cmd_SignModuleState_Args {{ module: {:?}, flags: {:?}, signer: {:?}, siginfo: {:?}, challenge: {:?}, attribs: {:?} }}" , self . module , self . flags , self . signer , self . siginfo , self . challenge , self . attribs)
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_StartUpdateWorld_Args {
    pub module: M_ModuleID,
}
pub type M_Cmd_StatEnumTree_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_StatEnumTree_Args {
    pub flags: M_Cmd_StatEnumTree_Args_flags,
    pub n_path_tags: ::core::ffi::c_int,
    pub path_tags: M_vec_Word,
}
impl Default for M_Cmd_StatEnumTree_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_StatGetValues_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_StatGetValues_Args {
    pub flags: M_Cmd_StatGetValues_Args_flags,
    pub n_path_tags: ::core::ffi::c_int,
    pub path_tags: M_vec_Word,
}
impl Default for M_Cmd_StatGetValues_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_StaticFeatureEnable_Args {
    pub module: M_ModuleID,
    pub info: M_FeatureInfo,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_TraceSEEWorld_Args {
    pub worldid: M_KeyID,
}
pub type M_Cmd_UnimportModule_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_UnimportModule_Args {
    pub flags: M_Cmd_UnimportModule_Args_flags,
    pub module: M_ModuleID,
}
pub type M_Cmd_UnimportSlot_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_UnimportSlot_Args {
    pub flags: M_Cmd_UnimportSlot_Args_flags,
    pub module: M_ModuleID,
    pub slot: M_SlotID,
}
pub type M_Cmd_UpdateMergedKey_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_UpdateMergedKey_Args {
    pub mkey: M_KeyID,
    pub flags: M_Cmd_UpdateMergedKey_Args_flags,
    pub n_addkeys: ::core::ffi::c_int,
    pub addkeys: M_vec_KeyID,
    pub n_delkeys: ::core::ffi::c_int,
    pub delkeys: M_vec_KeyID,
}
impl Default for M_Cmd_UpdateMergedKey_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_UpgradeApplianceFirmware_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_UpgradeApplianceFirmware_Args {
    pub module: M_ModuleID,
    pub file: M_PathName,
    pub flags: M_Cmd_UpgradeApplianceFirmware_Args_flags,
}
impl Default for M_Cmd_UpgradeApplianceFirmware_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_Verify_Args_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_Verify_Args {
    pub flags: M_Cmd_Verify_Args_flags,
    pub key: M_KeyID,
    pub mech: M_Mech,
    pub plain: M_PlainText,
    pub sig: M_CipherText,
}
impl Default for M_Cmd_Verify_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_Verify_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_Verify_Args {{ flags: {:?}, key: {:?}, mech: {:?}, plain: {:?}, sig: {:?} }}",
            self.flags, self.key, self.mech, self.plain, self.sig
        )
    }
}
pub type M_Cmd_VerifyCertificate_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_VerifyCertificate_Args {
    pub flags: M_Cmd_VerifyCertificate_Args_flags,
    pub module: M_ModuleID,
    pub type_: M_CertificateKind,
    pub warrant: M_ByteBlock,
}
impl Default for M_Cmd_VerifyCertificate_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_WriteFile_Args_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_WriteFile_Args {
    pub flags: M_Cmd_WriteFile_Args_flags,
    pub token: M_PhysToken,
    pub file: M_FileInfo,
    pub data: M_ByteBlock,
}
impl Default for M_Cmd_WriteFile_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_WriteFile_Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_WriteFile_Args {{ flags: {:?}, token: {:?}, file: {:?}, data: {:?} }}",
            self.flags, self.token, self.file, self.data
        )
    }
}
pub type M_Cmd_WriteShare_Args_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_WriteShare_Args {
    pub flags: M_Cmd_WriteShare_Args_flags,
    pub token: M_PhysToken,
    pub idkt: M_KeyID,
    pub i: M_Word,
    pub pin: *mut M_PIN,
    pub acl: *mut M_ACL,
}
impl Default for M_Cmd_WriteShare_Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_Cmd__Args {
    pub addremoteserverpermission: M_Cmd_AddRemoteServerPermission_Args,
    pub anonymousknetihash: M_Cmd_AnonymousKnetiHash_Args,
    pub applyfeaturefile: M_Cmd_ApplyFeatureFile_Args,
    pub bignumop: M_Cmd_BignumOp_Args,
    pub changesharegrouppin: M_Cmd_ChangeShareGroupPIN_Args,
    pub changesharepin: M_Cmd_ChangeSharePIN_Args,
    pub channelopen: M_Cmd_ChannelOpen_Args,
    pub channelupdate: M_Cmd_ChannelUpdate_Args,
    pub checkuseraction: M_Cmd_CheckUserAction_Args,
    pub checkworld: M_Cmd_CheckWorld_Args,
    pub clearunit: M_Cmd_ClearUnit_Args,
    pub clearunitex: M_Cmd_ClearUnitEx_Args,
    pub configurepoolmodule: M_Cmd_ConfigurePoolModule_Args,
    pub createbuffer: M_Cmd_CreateBuffer_Args,
    pub createclient: M_Cmd_CreateClient_Args,
    pub createseeconnection: M_Cmd_CreateSEEConnection_Args,
    pub createseeworld: M_Cmd_CreateSEEWorld_Args,
    pub decrypt: M_Cmd_Decrypt_Args,
    pub derivekey: M_Cmd_DeriveKey_Args,
    pub destroy: M_Cmd_Destroy_Args,
    pub devtest: M_Cmd_DevTest_Args,
    pub duplicate: M_Cmd_Duplicate_Args,
    pub dynamicslotcreateassociation: M_Cmd_DynamicSlotCreateAssociation_Args,
    pub dynamicslotexchangeapdus: M_Cmd_DynamicSlotExchangeAPDUs_Args,
    pub dynamicslotsconfigure: M_Cmd_DynamicSlotsConfigure_Args,
    pub dynamicslotsconfigurequery: M_Cmd_DynamicSlotsConfigureQuery_Args,
    pub encrypt: M_Cmd_Encrypt_Args,
    pub erasefile: M_Cmd_EraseFile_Args,
    pub eraseshare: M_Cmd_EraseShare_Args,
    pub eraseworld: M_Cmd_EraseWorld_Args,
    pub executeseewill: M_Cmd_ExecuteSEEWill_Args,
    pub existingclient: M_Cmd_ExistingClient_Args,
    pub export: M_Cmd_Export_Args,
    pub exportmodule: M_Cmd_ExportModule_Args,
    pub exportslot: M_Cmd_ExportSlot_Args,
    pub ftchecksum: M_Cmd_FTChecksum_Args,
    pub ftdelete: M_Cmd_FTDelete_Args,
    pub ftlistdir: M_Cmd_FTListDir_Args,
    pub ftread: M_Cmd_FTRead_Args,
    pub ftsessionopen: M_Cmd_FTSessionOpen_Args,
    pub ftstartlistdir: M_Cmd_FTStartListDir_Args,
    pub ftstartread: M_Cmd_FTStartRead_Args,
    pub ftstartwrite: M_Cmd_FTStartWrite_Args,
    pub ftstat: M_Cmd_FTStat_Args,
    pub ftwrite: M_Cmd_FTWrite_Args,
    pub fail: M_Cmd_Fail_Args,
    pub faildriver: M_Cmd_FailDriver_Args,
    pub fastseejob: M_Cmd_FastSEEJob_Args,
    pub filecopy: M_Cmd_FileCopy_Args,
    pub filecreate: M_Cmd_FileCreate_Args,
    pub fileerase: M_Cmd_FileErase_Args,
    pub fileop: M_Cmd_FileOp_Args,
    pub firmwareauthenticate: M_Cmd_FirmwareAuthenticate_Args,
    pub foreigntokencmd: M_Cmd_ForeignTokenCmd_Args,
    pub foreigntokenopen: M_Cmd_ForeignTokenOpen_Args,
    pub formattoken: M_Cmd_FormatToken_Args,
    pub generateklf: M_Cmd_GenerateKLF_Args,
    pub generatekey: M_Cmd_GenerateKey_Args,
    pub generatekeypair: M_Cmd_GenerateKeyPair_Args,
    pub generatelogicaltoken: M_Cmd_GenerateLogicalToken_Args,
    pub generateprime: M_Cmd_GeneratePrime_Args,
    pub generaterandom: M_Cmd_GenerateRandom_Args,
    pub getacl: M_Cmd_GetACL_Args,
    pub getappdata: M_Cmd_GetAppData_Args,
    pub getappliancetime: M_Cmd_GetApplianceTime_Args,
    pub getapplianceupgradestatus: M_Cmd_GetApplianceUpgradeStatus_Args,
    pub getapplianceversion: M_Cmd_GetApplianceVersion_Args,
    pub getchallenge: M_Cmd_GetChallenge_Args,
    pub gethardwareerror: M_Cmd_GetHardwareError_Args,
    pub getklf: M_Cmd_GetKLF_Args,
    pub getklf2: M_Cmd_GetKLF2_Args,
    pub getkml: M_Cmd_GetKML_Args,
    pub getkmlist: M_Cmd_GetKMList_Args,
    pub getkeyinfo: M_Cmd_GetKeyInfo_Args,
    pub getkeyinfoex: M_Cmd_GetKeyInfoEx_Args,
    pub getknetipub: M_Cmd_GetKnetiPub_Args,
    pub getlogicaltokeninfo: M_Cmd_GetLogicalTokenInfo_Args,
    pub getlogicaltokeninfoex: M_Cmd_GetLogicalTokenInfoEx_Args,
    pub getmodulestate: M_Cmd_GetModuleState_Args,
    pub getmonitorloaderstate: M_Cmd_GetMonitorLoaderState_Args,
    pub getpoolinfo: M_Cmd_GetPoolInfo_Args,
    pub getpublishedobject: M_Cmd_GetPublishedObject_Args,
    pub getrtc: M_Cmd_GetRTC_Args,
    pub getserverconfig: M_Cmd_GetServerConfig_Args,
    pub getshareacl: M_Cmd_GetShareACL_Args,
    pub getslotinfo: M_Cmd_GetSlotInfo_Args,
    pub getslotlist: M_Cmd_GetSlotList_Args,
    pub getticket: M_Cmd_GetTicket_Args,
    pub getwhichmodule: M_Cmd_GetWhichModule_Args,
    pub getworldsigners: M_Cmd_GetWorldSigners_Args,
    pub hash: M_Cmd_Hash_Args,
    pub hotreset: M_Cmd_HotReset_Args,
    pub ioboardreprogram: M_Cmd_IOBoardReprogram_Args,
    pub impathgetinfo: M_Cmd_ImpathGetInfo_Args,
    pub impathkxbegin: M_Cmd_ImpathKXBegin_Args,
    pub impathkxfinish: M_Cmd_ImpathKXFinish_Args,
    pub impathreceive: M_Cmd_ImpathReceive_Args,
    pub impathsend: M_Cmd_ImpathSend_Args,
    pub import: M_Cmd_Import_Args,
    pub importmodule: M_Cmd_ImportModule_Args,
    pub importslot: M_Cmd_ImportSlot_Args,
    pub initialiseunit: M_Cmd_InitialiseUnit_Args,
    pub initialiseunitex: M_Cmd_InitialiseUnitEx_Args,
    pub insertsofttoken: M_Cmd_InsertSoftToken_Args,
    pub listremoteserverpermission: M_Cmd_ListRemoteServerPermission_Args,
    pub listremoteserverpermissionex: M_Cmd_ListRemoteServerPermissionEx_Args,
    pub loadblob: M_Cmd_LoadBlob_Args,
    pub loadbuffer: M_Cmd_LoadBuffer_Args,
    pub loadlogicaltoken: M_Cmd_LoadLogicalToken_Args,
    pub loadmonitor: M_Cmd_LoadMonitor_Args,
    pub loadraw: M_Cmd_LoadRaw_Args,
    pub maintenance: M_Cmd_Maintenance_Args,
    pub makeblob: M_Cmd_MakeBlob_Args,
    pub makeseewill: M_Cmd_MakeSEEWill_Args,
    pub mergekeyids: M_Cmd_MergeKeyIDs_Args,
    pub modexp: M_Cmd_ModExp_Args,
    pub modexpcrt: M_Cmd_ModExpCrt_Args,
    pub moduleinfo: M_Cmd_ModuleInfo_Args,
    pub nvmemalloc: M_Cmd_NVMemAlloc_Args,
    pub nvmemfree: M_Cmd_NVMemFree_Args,
    pub nvmemlist: M_Cmd_NVMemList_Args,
    pub nvmemop: M_Cmd_NVMemOp_Args,
    pub newclient: M_Cmd_NewClient_Args,
    pub newenquiry: M_Cmd_NewEnquiry_Args,
    pub noop: M_Cmd_NoOp_Args,
    pub pausefornotifications: M_Cmd_PauseForNotifications_Args,
    pub pollmodulestate: M_Cmd_PollModuleState_Args,
    pub pollslotlist: M_Cmd_PollSlotList_Args,
    pub productionsetup: M_Cmd_ProductionSetup_Args,
    pub programmingbegin: M_Cmd_ProgrammingBegin_Args,
    pub programmingbeginchunk: M_Cmd_ProgrammingBeginChunk_Args,
    pub programmingend: M_Cmd_ProgrammingEnd_Args,
    pub programmingendchunk: M_Cmd_ProgrammingEndChunk_Args,
    pub programminggetkeylist: M_Cmd_ProgrammingGetKeyList_Args,
    pub programmingloadblock: M_Cmd_ProgrammingLoadBlock_Args,
    pub querylongjobs: M_Cmd_QueryLongJobs_Args,
    pub rsaimmedsigndecrypt: M_Cmd_RSAImmedSignDecrypt_Args,
    pub rsaimmedverifyencrypt: M_Cmd_RSAImmedVerifyEncrypt_Args,
    pub rereadconfig: M_Cmd_ReReadConfig_Args,
    pub readfile: M_Cmd_ReadFile_Args,
    pub readshare: M_Cmd_ReadShare_Args,
    pub readsofttokenshare: M_Cmd_ReadSoftTokenShare_Args,
    pub receivekey: M_Cmd_ReceiveKey_Args,
    pub receiveshare: M_Cmd_ReceiveShare_Args,
    pub redeemticket: M_Cmd_RedeemTicket_Args,
    pub remotereboot: M_Cmd_RemoteReboot_Args,
    pub remoteslots: M_Cmd_RemoteSlots_Args,
    pub removekm: M_Cmd_RemoveKM_Args,
    pub removepublishedobject: M_Cmd_RemovePublishedObject_Args,
    pub removeremoteserverpermission: M_Cmd_RemoveRemoteServerPermission_Args,
    pub removesofttoken: M_Cmd_RemoveSoftToken_Args,
    pub reportworldstate: M_Cmd_ReportWorldState_Args,
    pub retryfailedmodule: M_Cmd_RetryFailedModule_Args,
    pub seejob: M_Cmd_SEEJob_Args,
    pub sendkey: M_Cmd_SendKey_Args,
    pub sendshare: M_Cmd_SendShare_Args,
    pub servernoop: M_Cmd_ServerNoOp_Args,
    pub serversendshare: M_Cmd_ServerSendShare_Args,
    pub sessioncreate: M_Cmd_SessionCreate_Args,
    pub sessiondestroy: M_Cmd_SessionDestroy_Args,
    pub setacl: M_Cmd_SetACL_Args,
    pub setappdata: M_Cmd_SetAppData_Args,
    pub setappliancetime: M_Cmd_SetApplianceTime_Args,
    pub setapplianceupgradestatus: M_Cmd_SetApplianceUpgradeStatus_Args,
    pub setkm: M_Cmd_SetKM_Args,
    pub setmaxnumclients: M_Cmd_SetMaxNumClients_Args,
    pub setnsoperms: M_Cmd_SetNSOPerms_Args,
    pub setprimaryslot: M_Cmd_SetPrimarySlot_Args,
    pub setpublishedobject: M_Cmd_SetPublishedObject_Args,
    pub setrtc: M_Cmd_SetRTC_Args,
    pub setseemachine: M_Cmd_SetSEEMachine_Args,
    pub sign: M_Cmd_Sign_Args,
    pub signmodulestate: M_Cmd_SignModuleState_Args,
    pub startupdateworld: M_Cmd_StartUpdateWorld_Args,
    pub statenumtree: M_Cmd_StatEnumTree_Args,
    pub statgetvalues: M_Cmd_StatGetValues_Args,
    pub staticfeatureenable: M_Cmd_StaticFeatureEnable_Args,
    pub traceseeworld: M_Cmd_TraceSEEWorld_Args,
    pub unimportmodule: M_Cmd_UnimportModule_Args,
    pub unimportslot: M_Cmd_UnimportSlot_Args,
    pub updatemergedkey: M_Cmd_UpdateMergedKey_Args,
    pub upgradeappliancefirmware: M_Cmd_UpgradeApplianceFirmware_Args,
    pub verify: M_Cmd_Verify_Args,
    pub verifycertificate: M_Cmd_VerifyCertificate_Args,
    pub writefile: M_Cmd_WriteFile_Args,
    pub writeshare: M_Cmd_WriteShare_Args,
}
impl Default for M_Cmd__Args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd__Args {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Cmd__Args {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Command {
    pub tag: M_Tag,
    pub cmd: M_Cmd,
    pub status: M_MustBeZeroWord,
    pub flags: M_Command_flags,
    pub state: *mut M_StateList,
    pub args: M_Cmd__Args,
    pub certs: *mut M_CertificateList,
    pub extractstate: *mut M_ExtractStateParams,
    pub sessionid: *mut M_SessionID,
}
impl Default for M_Command {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Command {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_Command {{ tag: {:?}, cmd: {:?}, status: {:?}, flags: {:?}, state: {:?}, args: {:?}, certs: {:?}, extractstate: {:?}, sessionid: {:?} }}" , self . tag , self . cmd , self . status , self . flags , self . state , self . args , self . certs , self . extractstate , self . sessionid)
    }
}
pub type M_StateMap_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_StateMap {
    pub flags: M_StateMap_flags,
    pub keyID: M_KeyID,
    pub state: M_ByteBlock,
}
impl Default for M_StateMap {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_StateMapHook = M_StateMap;
pub type M_vec_StateMapHook = *mut M_StateMapHook;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_StateList {
    pub n_statemap: ::core::ffi::c_int,
    pub statemap: M_vec_StateMapHook,
}
impl Default for M_StateList {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_StackOpVal {
    pub op: M_StackOp,
    pub val: M_Word,
}
impl Default for M_StackOpVal {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_ShareInfo {
    pub hkm: M_KMHash,
    pub hkt: M_ShortHash,
    pub i: M_Word,
}
impl Default for M_ShareInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_ShareInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_ShareInfo {{ hkm: {:?}, hkt: {:?}, i: {:?} }}",
            self.hkm, self.hkt, self.i
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_EncryptionParams {
    pub key: M_KeyID,
    pub iv: M_IV,
}
impl Default for M_EncryptionParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_EncryptionParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_EncryptionParams {{ key: {:?}, iv: {:?} }}",
            self.key, self.iv
        )
    }
}
pub type M_PermissionGroup_flags = M_Word;
pub type M_vec_UseLimit = *mut M_UseLimit;
pub type M_vec_Action = *mut M_Action;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_PermissionGroup {
    pub flags: M_PermissionGroup_flags,
    pub n_limits: ::core::ffi::c_int,
    pub limits: M_vec_UseLimit,
    pub n_actions: ::core::ffi::c_int,
    pub actions: M_vec_Action,
    pub certifier: *mut M_KeyHash,
    pub certmech: *mut M_KeyHashAndMech,
    pub moduleserial: *mut M_ASCIIString,
}
impl Default for M_PermissionGroup {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_ImpathWarrantType_KLF2_Data {
    pub root: M_KeyData,
    pub warrant: M_ByteBlock,
}
impl Default for M_ImpathWarrantType_KLF2_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_ImpathWarrantType_KLF2_Data {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_ImpathWarrantType_KLF2_Data {{ root: {:?}, warrant: {:?} }}",
            self.root, self.warrant
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_ImpathWarrantType__Data {
    pub klf2: M_ImpathWarrantType_KLF2_Data,
}
impl Default for M_ImpathWarrantType__Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_ImpathWarrantType__Data {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_ImpathWarrantType__Data {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_ImpathWarrant {
    pub type_: M_ImpathWarrantType,
    pub warrant: M_ImpathWarrantType__Data,
}
impl Default for M_ImpathWarrant {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_ImpathWarrant {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_ImpathWarrant {{ type: {:?}, warrant: {:?} }}",
            self.type_, self.warrant
        )
    }
}
pub type M_MakeBlobFile_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_MakeBlobFile {
    pub flags: M_MakeBlobFile_flags,
    pub kacl: M_KeyID,
    pub file: M_FileSpec,
}
impl Default for M_MakeBlobFile {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_MakeBlobFile {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_MakeBlobFile {{ flags: {:?}, kacl: {:?}, file: {:?} }}",
            self.flags, self.kacl, self.file
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_RemoteSlotParams {
    pub lm: M_RemoteModule,
    pub lslot: M_SlotID,
    pub rm: M_RemoteModule,
    pub rslot: M_RemoteSlotID,
    pub sendcert: M_CertificateList,
}
impl Default for M_RemoteSlotParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_ExtractStateParams {
    pub format: M_BlobFormat,
    pub blobkey: M_BlobFormat__MkBlobParams,
}
impl Default for M_ExtractStateParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_ExtractStateParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_ExtractStateParams {{ format: {:?}, blobkey: {:?} }}",
            self.format, self.blobkey
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_UseLim_Auth_Details {
    pub id: M_LimitID,
    pub max: M_Word,
}
impl Default for M_UseLim_Auth_Details {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_UseLim_Auth_Details {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_UseLim_Auth_Details {{ id: {:?}, max: {:?} }}",
            self.id, self.max
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_UseLim_Global_Details {
    pub id: M_LimitID,
    pub max: M_Word,
}
impl Default for M_UseLim_Global_Details {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_UseLim_Global_Details {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_UseLim_Global_Details {{ id: {:?}, max: {:?} }}",
            self.id, self.max
        )
    }
}
pub type M_UseLim_NonVolatile_Details_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_UseLim_NonVolatile_Details {
    pub flags: M_UseLim_NonVolatile_Details_flags,
    pub file: M_FileID,
    pub range: M_NVMemRange,
    pub maxlo: M_Word,
    pub maxhi: M_Word,
    pub prefetch: M_Word,
}
impl Default for M_UseLim_NonVolatile_Details {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_UseLim_NonVolatile_Details {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_UseLim_NonVolatile_Details {{ flags: {:?}, file: {:?}, range: {:?}, maxlo: {:?}, maxhi: {:?}, prefetch: {:?} }}" , self . flags , self . file , self . range , self . maxlo , self . maxhi , self . prefetch)
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_UseLim_Time_Details {
    pub seconds: M_Word,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_UseLim__Details {
    pub auth: M_UseLim_Auth_Details,
    pub global: M_UseLim_Global_Details,
    pub nonvolatile: M_UseLim_NonVolatile_Details,
    pub time: M_UseLim_Time_Details,
}
impl Default for M_UseLim__Details {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_UseLim__Details {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_UseLim__Details {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_UseLimit {
    pub type_: M_UseLim,
    pub details: M_UseLim__Details,
}
impl Default for M_UseLimit {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_UseLimit {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_UseLimit {{ type: {:?}, details: {:?} }}",
            self.type_, self.details
        )
    }
}
pub type M_Act_DeriveKey_Details_flags = M_Word;
pub type M_vec_KeyRoleID = *mut M_KeyRoleID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Act_DeriveKey_Details {
    pub flags: M_Act_DeriveKey_Details_flags,
    pub role: M_DeriveRole,
    pub mech: M_DeriveMech,
    pub n_otherkeys: ::core::ffi::c_int,
    pub otherkeys: M_vec_KeyRoleID,
    pub params: *mut M_DKMechParams,
}
impl Default for M_Act_DeriveKey_Details {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Act_DeriveKeyEx_Details_flags = M_Word;
pub type M_vec_KeyRoleIDEx = *mut M_KeyRoleIDEx;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Act_DeriveKeyEx_Details {
    pub flags: M_Act_DeriveKeyEx_Details_flags,
    pub role: M_DeriveRole,
    pub mech: M_DeriveMech,
    pub n_otherkeys: ::core::ffi::c_int,
    pub otherkeys: M_vec_KeyRoleIDEx,
    pub params: *mut M_DKMechParams,
}
impl Default for M_Act_DeriveKeyEx_Details {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Act_FeatureEnable_Details_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Act_FeatureEnable_Details {
    pub flags: M_Act_FeatureEnable_Details_flags,
}
pub type M_Act_FileCopy_Details_flags = M_Word;
pub type M_FileDeviceFlags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Act_FileCopy_Details {
    pub flags: M_Act_FileCopy_Details_flags,
    pub to: M_FileDeviceFlags,
    pub from: M_FileDeviceFlags,
}
pub type M_Act_MakeArchiveBlob_Details_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Act_MakeArchiveBlob_Details {
    pub flags: M_Act_MakeArchiveBlob_Details_flags,
    pub mech: M_Mech,
    pub kahash: *mut M_KeyHash,
    pub blobfile: *mut M_MakeBlobFilePerms,
}
impl Default for M_Act_MakeArchiveBlob_Details {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Act_MakeBlob_Details_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Act_MakeBlob_Details {
    pub flags: M_Act_MakeBlob_Details_flags,
    pub kmhash: *mut M_KMHash,
    pub kthash: *mut M_TokenHash,
    pub ktparams: *mut M_TokenParams,
    pub blobfile: *mut M_MakeBlobFilePerms,
}
impl Default for M_Act_MakeBlob_Details {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Act_NSOPermissions_Details {
    pub perms: M_NSOPerms,
}
pub type M_Act_NVMemOpPerms_Details_perms = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Act_NVMemOpPerms_Details {
    pub perms: M_Act_NVMemOpPerms_Details_perms,
    pub subrange: *mut M_NVMemRange,
    pub exactrange: *mut M_NVMemRange,
    pub incdeclimit: *mut M_Word,
}
impl Default for M_Act_NVMemOpPerms_Details {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Act_NVMemUseLimit_Details_flags = M_Word;
pub type M_vec_KeyHash = *mut M_KeyHash;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Act_NVMemUseLimit_Details {
    pub flags: M_Act_NVMemUseLimit_Details_flags,
    pub range: M_NVMemRange,
    pub n_hks: ::core::ffi::c_int,
    pub hks: M_vec_KeyHash,
}
impl Default for M_Act_NVMemUseLimit_Details {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Act_OpPermissions_Details_perms = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Act_OpPermissions_Details {
    pub perms: M_Act_OpPermissions_Details_perms,
}
pub type M_ReadShareDetails_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_ReadShareDetails {
    pub flags: M_ReadShareDetails_flags,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Act_ReadShare_Details {
    pub rsd: M_ReadShareDetails,
}
pub type M_Act_SendKey_Details_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Act_SendKey_Details {
    pub flags: M_Act_SendKey_Details_flags,
    pub rm: *mut M_RemoteModule,
}
impl Default for M_Act_SendKey_Details {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Act_SendShare_Details_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Act_SendShare_Details {
    pub flags: M_Act_SendShare_Details_flags,
    pub rm: *mut M_RemoteModule,
    pub rsd: *mut M_ReadShareDetails,
}
impl Default for M_Act_SendShare_Details {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Act_StaticFeatureEnable_Details {
    pub info: M_FeatureInfo,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Act_UserAction_Details {
    pub allow: M_UserActionInfo,
}
impl Default for M_Act_UserAction_Details {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Act_UserAction_Details {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Act_UserAction_Details {{ allow: {:?} }}", self.allow)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_Act__Details {
    pub derivekey: M_Act_DeriveKey_Details,
    pub derivekeyex: M_Act_DeriveKeyEx_Details,
    pub featureenable: M_Act_FeatureEnable_Details,
    pub filecopy: M_Act_FileCopy_Details,
    pub makearchiveblob: M_Act_MakeArchiveBlob_Details,
    pub makeblob: M_Act_MakeBlob_Details,
    pub nsopermissions: M_Act_NSOPermissions_Details,
    pub nvmemopperms: M_Act_NVMemOpPerms_Details,
    pub nvmemuselimit: M_Act_NVMemUseLimit_Details,
    pub oppermissions: M_Act_OpPermissions_Details,
    pub readshare: M_Act_ReadShare_Details,
    pub sendkey: M_Act_SendKey_Details,
    pub sendshare: M_Act_SendShare_Details,
    pub staticfeatureenable: M_Act_StaticFeatureEnable_Details,
    pub useraction: M_Act_UserAction_Details,
}
impl Default for M_Act__Details {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Act__Details {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Act__Details {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Action {
    pub type_: M_Act,
    pub details: M_Act__Details,
}
impl Default for M_Action {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Action {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Action {{ type: {:?}, details: {:?} }}",
            self.type_, self.details
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_KeyRoleID {
    pub role: M_DeriveRole,
    pub hash: M_KeyHash,
}
impl Default for M_KeyRoleID {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_KeyRoleID {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_KeyRoleID {{ role: {:?}, hash: {:?} }}",
            self.role, self.hash
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_KeyRoleIDEx {
    pub role: M_DeriveRole,
    pub hash: M_KeyHashEx,
}
impl Default for M_KeyRoleIDEx {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_KeyRoleIDEx {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_KeyRoleIDEx {{ role: {:?}, hash: {:?} }}",
            self.role, self.hash
        )
    }
}
pub type M_MakeBlobFilePerms_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_MakeBlobFilePerms {
    pub flags: M_MakeBlobFilePerms_flags,
    pub devs: *mut M_FileDeviceFlags,
    pub aclhash: *mut M_KeyHash,
}
impl Default for M_MakeBlobFilePerms {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Reply_flags = M_Word;
pub type M_Cmd_ANLogEvent_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ANLogEvent_Reply {
    pub flags: M_Cmd_ANLogEvent_Reply_flags,
    pub text: M_ASCIIString,
}
impl Default for M_Cmd_ANLogEvent_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_ANModuleChangeEvent_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_ANModuleChangeEvent_Reply {
    pub flags: M_Cmd_ANModuleChangeEvent_Reply_flags,
    pub module: M_ModuleID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_ANRemoteModuleDisconnected_Reply {
    pub st: M_Status,
    pub einfo: M_Status__ErrorInfo,
}
impl Default for M_Cmd_ANRemoteModuleDisconnected_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_ANRemoteModuleDisconnected_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_ANRemoteModuleDisconnected_Reply {{ st: {:?}, einfo: {:?} }}",
            self.st, self.einfo
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_ANRemoteSlotDisconnected_Reply {
    pub slot: M_PhysToken,
    pub st: M_Status,
    pub einfo: M_Status__ErrorInfo,
}
impl Default for M_Cmd_ANRemoteSlotDisconnected_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_ANRemoteSlotDisconnected_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_ANRemoteSlotDisconnected_Reply {{ slot: {:?}, st: {:?}, einfo: {:?} }}",
            self.slot, self.st, self.einfo
        )
    }
}
pub type M_Cmd_ANSendAuditLogEvent_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ANSendAuditLogEvent_Reply {
    pub flags: M_Cmd_ANSendAuditLogEvent_Reply_flags,
    pub text: M_ASCIIString,
}
impl Default for M_Cmd_ANSendAuditLogEvent_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_ANSlotChangeEvent_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_ANSlotChangeEvent_Reply {
    pub flags: M_Cmd_ANSlotChangeEvent_Reply_flags,
    pub slot: M_PhysToken,
}
pub type M_Cmd_ANSlotsConfigurationChangeEvent_Reply_flags = M_Word;
pub type M_vec_SlotListData = *mut M_SlotListData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ANSlotsConfigurationChangeEvent_Reply {
    pub flags: M_Cmd_ANSlotsConfigurationChangeEvent_Reply_flags,
    pub n_slots: ::core::ffi::c_int,
    pub slots: M_vec_SlotListData,
}
impl Default for M_Cmd_ANSlotsConfigurationChangeEvent_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_AddRemoteServerPermission_Reply {
    pub permid: M_Word,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_AnonymousKnetiHash_Reply {
    pub esn: M_ASCIIString,
    pub kneti: M_KeyHash,
}
impl Default for M_Cmd_AnonymousKnetiHash_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_AnonymousKnetiHash_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_AnonymousKnetiHash_Reply {{ esn: {:?}, kneti: {:?} }}",
            self.esn, self.kneti
        )
    }
}
pub type M_Cmd_ApplyFeatureFile_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_ApplyFeatureFile_Reply {
    pub flags: M_Cmd_ApplyFeatureFile_Reply_flags,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_BignumOp_Reply {
    pub n_stackout: ::core::ffi::c_int,
    pub stackout: M_vec_Bignum,
}
impl Default for M_Cmd_BignumOp_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_ChannelOpen_Reply_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_ChannelOpen_Reply {
    pub flags: M_Cmd_ChannelOpen_Reply_flags,
    pub idch: M_KeyID,
    pub new_iv: *mut M_IV,
    pub openinfo: M_ChannelOpenInfo,
}
impl Default for M_Cmd_ChannelOpen_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_ChannelOpen_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_ChannelOpen_Reply {{ flags: {:?}, idch: {:?}, new_iv: {:?}, openinfo: {:?} }}",
            self.flags, self.idch, self.new_iv, self.openinfo
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ChannelUpdate_Reply {
    pub output: M_ByteBlock,
}
impl Default for M_Cmd_ChannelUpdate_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_CheckWorld_Reply {
    pub age: M_Word,
    pub flags: M_Word,
}
pub type M_Cmd_ConfigurePoolModule_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_ConfigurePoolModule_Reply {
    pub flags: M_Cmd_ConfigurePoolModule_Reply_flags,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_CreateBuffer_Reply {
    pub id: M_KeyID,
}
pub type M_Cmd_CreateClient_Reply_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_CreateClient_Reply {
    pub flags: M_Cmd_CreateClient_Reply_flags,
    pub client: M_ClientID,
}
impl Default for M_Cmd_CreateClient_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_CreateClient_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_CreateClient_Reply {{ flags: {:?}, client: {:?} }}",
            self.flags, self.client
        )
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_CreateSEEConnection_Reply {
    pub initstatus: M_Word,
    pub worldid: M_KeyID,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_CreateSEEWorld_Reply {
    pub initstatus: M_Word,
    pub worldid: M_KeyID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_Decrypt_Reply {
    pub plain: M_PlainText,
}
impl Default for M_Cmd_Decrypt_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_Decrypt_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Cmd_Decrypt_Reply {{ plain: {:?} }}", self.plain)
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_DeriveKey_Reply {
    pub key: M_KeyID,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_DevTest_Reply {
    pub info: M_ByteBlock,
}
impl Default for M_Cmd_DevTest_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_Duplicate_Reply {
    pub newkey: M_KeyID,
}
pub type M_Cmd_DynamicSlotCreateAssociation_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_DynamicSlotCreateAssociation_Reply {
    pub flags: M_Cmd_DynamicSlotCreateAssociation_Reply_flags,
    pub slotassociation: M_SlotAssociationID,
}
pub type M_Cmd_DynamicSlotExchangeAPDUs_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_DynamicSlotExchangeAPDUs_Reply {
    pub flags: M_Cmd_DynamicSlotExchangeAPDUs_Reply_flags,
    pub payload: *mut M_ByteBlock,
}
impl Default for M_Cmd_DynamicSlotExchangeAPDUs_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_DynamicSlotsConfigureQuery_Reply {
    pub maxcardidle: M_Word,
    pub maxroundtrip: M_Word,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_Encrypt_Reply {
    pub cipher: M_CipherText,
}
impl Default for M_Cmd_Encrypt_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_Encrypt_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Cmd_Encrypt_Reply {{ cipher: {:?} }}", self.cipher)
    }
}
pub type M_Cmd_EraseWorld_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_EraseWorld_Reply {
    pub flags: M_Cmd_EraseWorld_Reply_flags,
}
pub type M_Cmd_ExistingClient_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_ExistingClient_Reply {
    pub flags: M_Cmd_ExistingClient_Reply_flags,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_Export_Reply {
    pub data: M_KeyData,
}
impl Default for M_Cmd_Export_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_Export_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Cmd_Export_Reply {{ data: {:?} }}", self.data)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_GetSlotList_Reply {
    pub n_slots: ::core::ffi::c_int,
    pub slots: M_vec_SlotListData,
}
impl Default for M_Cmd_GetSlotList_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_NewEnquiry_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_EnqVer_Five_Data {
    pub one: M_EnquiryDataOne,
    pub two: M_EnquiryDataTwo,
    pub three: M_EnquiryDataThree,
    pub four: M_EnquiryDataFour,
    pub five: M_EnquiryDataFive,
}
impl Default for M_EnqVer_Five_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_EnqVer_Four_Data {
    pub one: M_EnquiryDataOne,
    pub two: M_EnquiryDataTwo,
    pub three: M_EnquiryDataThree,
    pub four: M_EnquiryDataFour,
}
impl Default for M_EnqVer_Four_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_EnqVer_One_Data {
    pub one: M_EnquiryDataOne,
}
impl Default for M_EnqVer_One_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_EnqVer_Six_Data {
    pub one: M_EnquiryDataOne,
    pub two: M_EnquiryDataTwo,
    pub three: M_EnquiryDataThree,
    pub four: M_EnquiryDataFour,
    pub five: M_EnquiryDataFive,
    pub six: M_EnquiryDataSix,
}
impl Default for M_EnqVer_Six_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_EnqVer_Three_Data {
    pub one: M_EnquiryDataOne,
    pub two: M_EnquiryDataTwo,
    pub three: M_EnquiryDataThree,
}
impl Default for M_EnqVer_Three_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_EnqVer_Two_Data {
    pub one: M_EnquiryDataOne,
    pub two: M_EnquiryDataTwo,
}
impl Default for M_EnqVer_Two_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_EnqVer__Data {
    pub five: M_EnqVer_Five_Data,
    pub four: M_EnqVer_Four_Data,
    pub one: M_EnqVer_One_Data,
    pub six: M_EnqVer_Six_Data,
    pub three: M_EnqVer_Three_Data,
    pub two: M_EnqVer_Two_Data,
}
impl Default for M_EnqVer__Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_EnqVer__Data {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_EnqVer__Data {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_NewEnquiry_Reply {
    pub flags: M_Cmd_NewEnquiry_Reply_flags,
    pub module: M_ModuleID,
    pub version: M_EnqVer,
    pub data: M_EnqVer__Data,
}
impl Default for M_Cmd_NewEnquiry_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_NewEnquiry_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_NewEnquiry_Reply {{ flags: {:?}, module: {:?}, version: {:?}, data: {:?} }}",
            self.flags, self.module, self.version, self.data
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_ExportModule_Reply {
    pub getslotlist: M_Cmd_GetSlotList_Reply,
    pub newenquiry: M_Cmd_NewEnquiry_Reply,
}
impl Default for M_Cmd_ExportModule_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_ExportModule_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_ExportModule_Reply {{ getslotlist: {:?}, newenquiry: {:?} }}",
            self.getslotlist, self.newenquiry
        )
    }
}
pub type M_SlotListData_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_SlotListData {
    pub type_: M_SlotType,
    pub flags: M_SlotListData_flags,
    pub token: M_PhysToken,
    pub exdata: M_SlotType__SlotExData,
}
impl Default for M_SlotListData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_SlotListData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_SlotListData {{ type: {:?}, flags: {:?}, token: {:?}, exdata: {:?} }}",
            self.type_, self.flags, self.token, self.exdata
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_PollSlotData {
    pub changeevents: M_Word,
    pub sld: M_SlotListData,
}
impl Default for M_PollSlotData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_PollSlotData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_PollSlotData {{ changeevents: {:?}, sld: {:?} }}",
            self.changeevents, self.sld
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_ExportSlot_Reply {
    pub psd: M_PollSlotData,
}
impl Default for M_Cmd_ExportSlot_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_ExportSlot_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Cmd_ExportSlot_Reply {{ psd: {:?} }}", self.psd)
    }
}
pub type M_Cmd_FTChecksum_Reply_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_FTChecksum_Reply {
    pub checksum: M_CipherText,
    pub flags: M_Cmd_FTChecksum_Reply_flags,
}
impl Default for M_Cmd_FTChecksum_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_FTChecksum_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_FTChecksum_Reply {{ checksum: {:?}, flags: {:?} }}",
            self.checksum, self.flags
        )
    }
}
pub type M_Cmd_FTDelete_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_FTDelete_Reply {
    pub flags: M_Cmd_FTDelete_Reply_flags,
}
pub type M_vec_HostFileDesc = *mut M_HostFileDesc;
pub type M_Cmd_FTListDir_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_FTListDir_Reply {
    pub n_files: ::core::ffi::c_int,
    pub files: M_vec_HostFileDesc,
    pub flags: M_Cmd_FTListDir_Reply_flags,
}
impl Default for M_Cmd_FTListDir_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_FTRead_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_FTRead_Reply {
    pub chunk: M_ByteBlock,
    pub flags: M_Cmd_FTRead_Reply_flags,
}
impl Default for M_Cmd_FTRead_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_FTSessionOpen_Reply {
    pub id: M_FTSessionID,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_FTStartListDir_Reply {
    pub id: M_FileTransferID,
    pub ftlistdir: M_Cmd_FTListDir_Reply,
}
impl Default for M_Cmd_FTStartListDir_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_HostFileDesc {
    pub name: M_FileName,
    pub size: M_Word,
    pub flags: M_HostFileFlags,
}
impl Default for M_HostFileDesc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_FTStartRead_Reply {
    pub id: M_FileTransferID,
    pub desc: M_HostFileDesc,
    pub ftread: M_Cmd_FTRead_Reply,
}
impl Default for M_Cmd_FTStartRead_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_FTStartWrite_Reply {
    pub id: M_FileTransferID,
}
pub type M_Cmd_FTStat_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_FTStat_Reply {
    pub flags: M_Cmd_FTStat_Reply_flags,
    pub desc: M_HostFileDesc,
}
impl Default for M_Cmd_FTStat_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_FailDriver_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_FailDriver_Reply {
    pub flags: M_Cmd_FailDriver_Reply_flags,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_FastSEEJob_Reply {
    pub seereply: M_ByteBlock,
}
impl Default for M_Cmd_FastSEEJob_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_NVMemOpType_GetACL_OpRes {
    pub acl: M_ACL,
}
impl Default for M_NVMemOpType_GetACL_OpRes {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_NVMemOpType_Read_OpRes {
    pub data: M_ByteBlock,
}
impl Default for M_NVMemOpType_Read_OpRes {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_NVMemOpType__OpRes {
    pub getacl: M_NVMemOpType_GetACL_OpRes,
    pub read: M_NVMemOpType_Read_OpRes,
}
impl Default for M_NVMemOpType__OpRes {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_NVMemOpType__OpRes {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_NVMemOpType__OpRes {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_FileOp_Reply {
    pub op: M_NVMemOpType,
    pub res: M_NVMemOpType__OpRes,
}
impl Default for M_Cmd_FileOp_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_FileOp_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_FileOp_Reply {{ op: {:?}, res: {:?} }}",
            self.op, self.res
        )
    }
}
pub type M_Cmd_FirmwareAuthenticate_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_FwAuthType_NFFHMAC1_Resp {
    pub mac: M_ByteBlock,
}
impl Default for M_FwAuthType_NFFHMAC1_Resp {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_FwAuthType_PRNG1_Resp {
    pub data: M_ByteBlock,
}
impl Default for M_FwAuthType_PRNG1_Resp {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_FwAuthType__Resp {
    pub nffhmac1: M_FwAuthType_NFFHMAC1_Resp,
    pub prng1: M_FwAuthType_PRNG1_Resp,
}
impl Default for M_FwAuthType__Resp {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_FwAuthType__Resp {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_FwAuthType__Resp {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_FirmwareAuthenticate_Reply {
    pub flags: M_Cmd_FirmwareAuthenticate_Reply_flags,
    pub type_: M_FwAuthType,
    pub response: M_FwAuthType__Resp,
}
impl Default for M_Cmd_FirmwareAuthenticate_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_FirmwareAuthenticate_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_FirmwareAuthenticate_Reply {{ flags: {:?}, type: {:?}, response: {:?} }}",
            self.flags, self.type_, self.response
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_PhysTokenType_ISO7816_Reply {
    pub dataout: M_ByteBlock,
    pub sw1sw2: M_Word,
}
impl Default for M_PhysTokenType_ISO7816_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_PhysTokenType__Reply {
    pub iso7816: M_PhysTokenType_ISO7816_Reply,
}
impl Default for M_PhysTokenType__Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_PhysTokenType__Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_PhysTokenType__Reply {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_ForeignTokenCmd_Reply {
    pub type_: M_PhysTokenType,
    pub reply: M_PhysTokenType__Reply,
}
impl Default for M_Cmd_ForeignTokenCmd_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_ForeignTokenCmd_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_ForeignTokenCmd_Reply {{ type: {:?}, reply: {:?} }}",
            self.type_, self.reply
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_PhysTokenType_ISO7816_Info {
    pub atr: M_ByteBlock,
}
impl Default for M_PhysTokenType_ISO7816_Info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_PhysTokenType__Info {
    pub iso7816: M_PhysTokenType_ISO7816_Info,
}
impl Default for M_PhysTokenType__Info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_PhysTokenType__Info {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_PhysTokenType__Info {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_ForeignTokenOpen_Reply {
    pub lock: M_KeyID,
    pub type_: M_PhysTokenType,
    pub info: M_PhysTokenType__Info,
}
impl Default for M_Cmd_ForeignTokenOpen_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_ForeignTokenOpen_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_ForeignTokenOpen_Reply {{ lock: {:?}, type: {:?}, info: {:?} }}",
            self.lock, self.type_, self.info
        )
    }
}
pub type M_Cmd_GenerateKey_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_GenerateKey_Reply {
    pub flags: M_Cmd_GenerateKey_Reply_flags,
    pub key: M_KeyID,
    pub cert: *mut M_ModuleCert,
}
impl Default for M_Cmd_GenerateKey_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_GenerateKeyPair_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_GenerateKeyPair_Reply {
    pub flags: M_Cmd_GenerateKeyPair_Reply_flags,
    pub keypriv: M_KeyID,
    pub keypub: M_KeyID,
    pub certpriv: *mut M_ModuleCert,
    pub certpub: *mut M_ModuleCert,
}
impl Default for M_Cmd_GenerateKeyPair_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_GenerateLogicalToken_Reply {
    pub idkt: M_KeyID,
    pub hkt: M_TokenHash,
}
impl Default for M_Cmd_GenerateLogicalToken_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_GenerateLogicalToken_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_GenerateLogicalToken_Reply {{ idkt: {:?}, hkt: {:?} }}",
            self.idkt, self.hkt
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_GeneratePrime_Reply {
    pub r: M_Bignum,
}
impl Default for M_Cmd_GeneratePrime_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_GenerateRandom_Reply {
    pub data: M_ByteBlock,
}
impl Default for M_Cmd_GenerateRandom_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_nest_ACL = M_ACL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_GetACL_Reply {
    pub acl: M_nest_ACL,
}
impl Default for M_Cmd_GetACL_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_GetAppData_Reply {
    pub appdata: M_AppData,
}
impl Default for M_Cmd_GetAppData_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_GetAppData_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_GetAppData_Reply {{ appdata: {:?} }}",
            self.appdata
        )
    }
}
pub type M_Cmd_GetApplianceTime_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_GetApplianceTime_Reply {
    pub time: M_RTCTime,
    pub flags: M_Cmd_GetApplianceTime_Reply_flags,
}
pub type M_Cmd_GetApplianceUpgradeStatus_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_GetApplianceUpgradeStatus_Reply {
    pub error: M_Status,
    pub stage: M_UpgradeState,
    pub flags: M_Cmd_GetApplianceUpgradeStatus_Reply_flags,
}
impl Default for M_Cmd_GetApplianceUpgradeStatus_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_GetApplianceVersion_Reply {
    pub version: M_ASCIIString,
}
impl Default for M_Cmd_GetApplianceVersion_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_GetChallenge_Reply {
    pub nonce: M_Nonce,
}
impl Default for M_Cmd_GetChallenge_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_GetChallenge_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Cmd_GetChallenge_Reply {{ nonce: {:?} }}", self.nonce)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_GetClientHash_Reply {
    pub hclientid: M_Hash,
}
impl Default for M_Cmd_GetClientHash_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_GetClientHash_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_GetClientHash_Reply {{ hclientid: {:?} }}",
            self.hclientid
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_GetHardwareError_Reply {
    pub report: M_ASCIIString,
}
impl Default for M_Cmd_GetHardwareError_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_GetKLF_Reply {
    pub idka: M_KeyID,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_GetKLF2_Reply {
    pub idka: M_KeyID,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_GetKML_Reply {
    pub idka: M_KeyID,
}
pub type M_Cmd_GetKMList_Reply_flags = M_Word;
pub type M_vec_KMHash = *mut M_KMHash;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_GetKMList_Reply {
    pub flags: M_Cmd_GetKMList_Reply_flags,
    pub hknso: M_KeyHash,
    pub n_hkms: ::core::ffi::c_int,
    pub hkms: M_vec_KMHash,
}
impl Default for M_Cmd_GetKMList_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_GetKMList_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_GetKMList_Reply {{ flags: {:?}, hknso: {:?}, n_hkms: {:?}, hkms: {:?} }}",
            self.flags, self.hknso, self.n_hkms, self.hkms
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_GetKeyInfo_Reply {
    pub type_: M_KeyType,
    pub hash: M_KeyHash,
}
impl Default for M_Cmd_GetKeyInfo_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_GetKeyInfo_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_GetKeyInfo_Reply {{ type: {:?}, hash: {:?} }}",
            self.type_, self.hash
        )
    }
}
pub type M_Cmd_GetKeyInfoEx_Reply_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_GetKeyInfoEx_Reply {
    pub ver: M_Word,
    pub flags: M_Cmd_GetKeyInfoEx_Reply_flags,
    pub type_: M_KeyType,
    pub length: M_Word,
    pub hash: M_KeyHash,
    pub hashex: M_KeyHashEx,
}
impl Default for M_Cmd_GetKeyInfoEx_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_GetKeyInfoEx_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_Cmd_GetKeyInfoEx_Reply {{ ver: {:?}, flags: {:?}, type: {:?}, length: {:?}, hash: {:?}, hashex: {:?} }}" , self . ver , self . flags , self . type_ , self . length , self . hash , self . hashex)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_GetKnetiPub_Reply {
    pub kneti: M_KeyData,
}
impl Default for M_Cmd_GetKnetiPub_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_GetKnetiPub_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Cmd_GetKnetiPub_Reply {{ kneti: {:?} }}", self.kneti)
    }
}
pub type M_vec_LogTokenShareInfo = *mut M_LogTokenShareInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_GetLogicalTokenInfo_Reply {
    pub state: M_LogTokenState,
    pub hkt: M_TokenHash,
    pub n_shares: ::core::ffi::c_int,
    pub shares: M_vec_LogTokenShareInfo,
    pub sharesneeded: M_Word,
}
impl Default for M_Cmd_GetLogicalTokenInfo_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_GetLogicalTokenInfo_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_Cmd_GetLogicalTokenInfo_Reply {{ state: {:?}, hkt: {:?}, n_shares: {:?}, shares: {:?}, sharesneeded: {:?} }}" , self . state , self . hkt , self . n_shares , self . shares , self . sharesneeded)
    }
}
pub type M_Cmd_GetLogicalTokenInfoEx_Reply_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_GetLogicalTokenInfoEx_Reply {
    pub ver: M_Word,
    pub flags: M_Cmd_GetLogicalTokenInfoEx_Reply_flags,
    pub state: M_LogTokenState,
    pub hkt: M_TokenHash,
    pub hkm: M_KMHash,
    pub n_shares: ::core::ffi::c_int,
    pub shares: M_vec_LogTokenShareInfo,
    pub sharesneeded: M_Word,
    pub age: M_Word,
    pub timelimit: M_Word,
}
impl Default for M_Cmd_GetLogicalTokenInfoEx_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_GetLogicalTokenInfoEx_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_Cmd_GetLogicalTokenInfoEx_Reply {{ ver: {:?}, flags: {:?}, state: {:?}, hkt: {:?}, hkm: {:?}, n_shares: {:?}, shares: {:?}, sharesneeded: {:?}, age: {:?}, timelimit: {:?} }}" , self . ver , self . flags , self . state , self . hkt , self . hkm , self . n_shares , self . shares , self . sharesneeded , self . age , self . timelimit)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_GetModuleState_Reply {
    pub state: M_ModuleAttribList,
}
impl Default for M_Cmd_GetModuleState_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_GetMonitorLoaderState_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_GetMonitorLoaderState_Reply {
    pub state: M_MonitorLoaderState,
    pub flags: M_Cmd_GetMonitorLoaderState_Reply_flags,
}
impl Default for M_Cmd_GetMonitorLoaderState_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_GetPoolInfo_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_GetPoolInfo_Reply {
    pub flags: M_Cmd_GetPoolInfo_Reply_flags,
    pub info: M_ByteBlock,
}
impl Default for M_Cmd_GetPoolInfo_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_GetPublishedObject_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_GetPublishedObject_Reply {
    pub flags: M_Cmd_GetPublishedObject_Reply_flags,
    pub object: *mut M_KeyID,
    pub data: *mut M_ByteBlock,
}
impl Default for M_Cmd_GetPublishedObject_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_GetRTC_Reply {
    pub time: M_RTCTime,
}
pub type M_Cmd_GetServerConfig_Reply_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_GetServerConfig_Reply {
    pub flags: M_Cmd_GetServerConfig_Reply_flags,
    pub v: M_Word,
    pub maxnumclients: M_Word,
    pub addr: M_NetworkAddress,
    pub addr_ipv6: M_NetworkAddress,
}
impl Default for M_Cmd_GetServerConfig_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_GetServerConfig_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_Cmd_GetServerConfig_Reply {{ flags: {:?}, v: {:?}, maxnumclients: {:?}, addr: {:?}, addr_ipv6: {:?} }}" , self . flags , self . v , self . maxnumclients , self . addr , self . addr_ipv6)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_GetShareACL_Reply {
    pub acl: M_ACL,
}
impl Default for M_Cmd_GetShareACL_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_GetSlotInfo_Reply_flags = M_Word;
pub type M_vec_TokenInfo = *mut M_TokenInfo;
pub type M_vec_FileInfo = *mut M_FileInfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_TokenUniqueID {
    pub bytes: [::core::ffi::c_uchar; 8usize],
    pub words: [M_Word; 2usize],
}
impl Default for M_TokenUniqueID {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_TokenUniqueID {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_TokenUniqueID {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_GetSlotInfo_Reply {
    pub ic: M_Word,
    pub flags: M_Cmd_GetSlotInfo_Reply_flags,
    pub n_tokens: ::core::ffi::c_int,
    pub tokens: M_vec_TokenInfo,
    pub n_files: ::core::ffi::c_int,
    pub files: M_vec_FileInfo,
    pub freespace: M_Word,
    pub auth_key: M_KMHash,
    pub tokenserial: *mut M_TokenUniqueID,
}
impl Default for M_Cmd_GetSlotInfo_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_GetSlotInfo_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_Cmd_GetSlotInfo_Reply {{ ic: {:?}, flags: {:?}, n_tokens: {:?}, tokens: {:?}, n_files: {:?}, files: {:?}, freespace: {:?}, auth_key: {:?}, tokenserial: {:?} }}" , self . ic , self . flags , self . n_tokens , self . tokens , self . n_files , self . files , self . freespace , self . auth_key , self . tokenserial)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_GetTicket_Reply {
    pub ticket: M_nest_Ticket,
}
impl Default for M_Cmd_GetTicket_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_GetWhichModule_Reply {
    pub n_module: ::core::ffi::c_int,
    pub module: M_vec_ModuleID,
}
impl Default for M_Cmd_GetWhichModule_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_GetWorldSigners_Reply {
    pub n_sigs: ::core::ffi::c_int,
    pub sigs: M_vec_KeyHashAndMech,
}
impl Default for M_Cmd_GetWorldSigners_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_Hash_Reply {
    pub sig: M_CipherText,
}
impl Default for M_Cmd_Hash_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_Hash_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Cmd_Hash_Reply {{ sig: {:?} }}", self.sig)
    }
}
pub type M_Cmd_IOBoardReprogram_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_IOBoardReprogram_Reply {
    pub flags: M_Cmd_IOBoardReprogram_Reply_flags,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_ImpathInfo {
    pub v: M_Word,
    pub state: M_ImpathState,
    pub rm: M_RemoteModule,
}
impl Default for M_ImpathInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ImpathGetInfo_Reply {
    pub info: M_ImpathInfo,
}
impl Default for M_Cmd_ImpathGetInfo_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ImpathKXBegin_Reply {
    pub imp: M_ImpathID,
    pub kx: M_ByteBlock,
}
impl Default for M_Cmd_ImpathKXBegin_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ImpathReceive_Reply {
    pub data: M_ByteBlock,
}
impl Default for M_Cmd_ImpathReceive_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ImpathSend_Reply {
    pub cipher: M_ByteBlock,
}
impl Default for M_Cmd_ImpathSend_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_Import_Reply {
    pub key: M_KeyID,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_ImportSlot_Reply {
    pub slot: M_SlotID,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_InsertSoftToken_Reply {
    pub ic: M_Word,
}
pub type M_vec_RemoteServerPermission = *mut M_RemoteServerPermission;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ListRemoteServerPermission_Reply {
    pub n_permission: ::core::ffi::c_int,
    pub permission: M_vec_RemoteServerPermission,
}
impl Default for M_Cmd_ListRemoteServerPermission_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_ListRemoteServerPermissionEx_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ListRemoteServerPermissionEx_Reply {
    pub flags: M_Cmd_ListRemoteServerPermissionEx_Reply_flags,
    pub remaining: M_Word,
    pub n_permission: ::core::ffi::c_int,
    pub permission: M_vec_RemoteServerPermission,
}
impl Default for M_Cmd_ListRemoteServerPermissionEx_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_LoadBlob_Reply {
    pub idka: M_KeyID,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_LoadLogicalToken_Reply {
    pub idkt: M_KeyID,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_MakeBlob_Reply {
    pub blob: M_ByteBlock,
}
impl Default for M_Cmd_MakeBlob_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_MergeKeyIDs_Reply {
    pub newkey: M_KeyID,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ModExp_Reply {
    pub r: M_Bignum,
}
impl Default for M_Cmd_ModExp_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_InfoFormat_HardwareRev1_Info_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_InfoFormat_HardwareRev1_Info {
    pub flags: M_InfoFormat_HardwareRev1_Info_flags,
    pub base_code: M_Word,
    pub io_code: M_Word,
    pub scsi_id: M_Word,
    pub links: M_Word,
    pub n_cpus: M_Word,
    pub ram_size: M_Word,
}
pub type M_vec_DeviceID = *mut M_DeviceID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_InfoFormat_HardwareRev2_Info {
    pub n_devices: ::core::ffi::c_int,
    pub devices: M_vec_DeviceID,
}
impl Default for M_InfoFormat_HardwareRev2_Info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_InfoFormat__Info {
    pub hardwarerev1: M_InfoFormat_HardwareRev1_Info,
    pub hardwarerev2: M_InfoFormat_HardwareRev2_Info,
}
impl Default for M_InfoFormat__Info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_InfoFormat__Info {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_InfoFormat__Info {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_ModuleInfo_Reply {
    pub format: M_InfoFormat,
    pub info: M_InfoFormat__Info,
}
impl Default for M_Cmd_ModuleInfo_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_ModuleInfo_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_ModuleInfo_Reply {{ format: {:?}, info: {:?} }}",
            self.format, self.info
        )
    }
}
pub type M_Cmd_NVMemList_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_NVMemList_Reply {
    pub flags: M_Cmd_NVMemList_Reply_flags,
    pub n_infos: ::core::ffi::c_int,
    pub infos: M_vec_FileInfo,
}
impl Default for M_Cmd_NVMemList_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_NVMemOp_Reply {
    pub op: M_NVMemOpType,
    pub res: M_NVMemOpType__OpRes,
}
impl Default for M_Cmd_NVMemOp_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_NVMemOp_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_NVMemOp_Reply {{ op: {:?}, res: {:?} }}",
            self.op, self.res
        )
    }
}
pub type M_Cmd_NewClient_Reply_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_NewClient_Reply {
    pub flags: M_Cmd_NewClient_Reply_flags,
    pub client: M_ClientID,
}
impl Default for M_Cmd_NewClient_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_NewClient_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_Cmd_NewClient_Reply {{ flags: {:?}, client: {:?} }}",
            self.flags, self.client
        )
    }
}
pub type M_Cmd_PauseForNotifications_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_PauseForNotifications_Reply {
    pub flags: M_Cmd_PauseForNotifications_Reply_flags,
}
pub type M_Cmd_PollModuleState_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_PollModuleState_Reply {
    pub version: M_Word,
    pub flags: M_Cmd_PollModuleState_Reply_flags,
    pub stateevents: M_Word,
    pub nvmemevents: M_Word,
    pub rtcadjusts: M_Word,
}
pub type M_Cmd_PollSlotList_Reply_flags = M_Word;
pub type M_vec_PollSlotData = *mut M_PollSlotData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_PollSlotList_Reply {
    pub flags: M_Cmd_PollSlotList_Reply_flags,
    pub n_slots: ::core::ffi::c_int,
    pub slots: M_vec_PollSlotData,
}
impl Default for M_Cmd_PollSlotList_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_ProductionSetup_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_ProductionSetup_Reply {
    pub flags: M_Cmd_ProductionSetup_Reply_flags,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_ProgrammingBeginChunk_Reply {
    pub maxblocksize: M_Word,
}
pub type M_Cmd_ProgrammingEndChunk_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_ProgrammingEndChunk_Reply {
    pub flags: M_Cmd_ProgrammingEndChunk_Reply_flags,
}
pub type M_vec_ProgrammingKeyListEntry = *mut M_ProgrammingKeyListEntry;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ProgrammingGetKeyList_Reply {
    pub vsn: M_Word,
    pub n_kfcs: ::core::ffi::c_int,
    pub kfcs: M_vec_ProgrammingKeyListEntry,
    pub n_kfis: ::core::ffi::c_int,
    pub kfis: M_vec_ProgrammingKeyListEntry,
}
impl Default for M_Cmd_ProgrammingGetKeyList_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_QueryLongJobs_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_QueryLongJobs_Reply {
    pub flags: M_Cmd_QueryLongJobs_Reply_flags,
    pub n_tags: ::core::ffi::c_int,
    pub tags: M_vec_Word,
}
impl Default for M_Cmd_QueryLongJobs_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_RSAImmedSignDecrypt_Reply {
    pub r: M_Bignum,
}
impl Default for M_Cmd_RSAImmedSignDecrypt_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_ReReadConfig_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_ReReadConfig_Reply {
    pub flags: M_Cmd_ReReadConfig_Reply_flags,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ReadFile_Reply {
    pub data: M_ByteBlock,
}
impl Default for M_Cmd_ReadFile_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_ReadShare_Reply {
    pub sharesleft: M_Word,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_ReadSoftTokenShare_Reply {
    pub sharesleft: M_Word,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_ReceiveKey_Reply {
    pub idka: M_KeyID,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_ReceiveShare_Reply {
    pub sharesleft: M_Word,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_RedeemTicket_Reply {
    pub obj: M_KeyID,
}
pub type M_Cmd_RemoteReboot_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_RemoteReboot_Reply {
    pub flags: M_Cmd_RemoteReboot_Reply_flags,
}
pub type M_Cmd_RemoteSlots_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_RemoteSlots_Reply {
    pub flags: M_Cmd_RemoteSlots_Reply_flags,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_RemoveSoftToken_Reply {
    pub data: M_ByteBlock,
}
impl Default for M_Cmd_RemoveSoftToken_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_ReportWorldState_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_ReportWorldState_Reply {
    pub flags: M_Cmd_ReportWorldState_Reply_flags,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_SEEJob_Reply {
    pub seereply: M_ByteBlock,
}
impl Default for M_Cmd_SEEJob_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_SendKey_Reply {
    pub blob: M_ByteBlock,
}
impl Default for M_Cmd_SendKey_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_SendShare_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_SendShare_Reply {
    pub flags: M_Cmd_SendShare_Reply_flags,
    pub share: M_ByteBlock,
}
impl Default for M_Cmd_SendShare_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ServerNoOp_Reply {
    pub payload: M_ByteBlock,
}
impl Default for M_Cmd_ServerNoOp_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_ServerSendShare_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_ServerSendShare_Reply {
    pub flags: M_Cmd_ServerSendShare_Reply_flags,
    pub share: M_ByteBlock,
}
impl Default for M_Cmd_ServerSendShare_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_SessionCreate_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_SessionCreate_Reply {
    pub flags: M_Cmd_SessionCreate_Reply_flags,
    pub v: M_Word,
    pub session: M_SessionID,
}
pub type M_Cmd_SetApplianceTime_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_SetApplianceTime_Reply {
    pub flags: M_Cmd_SetApplianceTime_Reply_flags,
}
pub type M_Cmd_SetApplianceUpgradeStatus_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_SetApplianceUpgradeStatus_Reply {
    pub flags: M_Cmd_SetApplianceUpgradeStatus_Reply_flags,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_Sign_Reply {
    pub sig: M_CipherText,
}
impl Default for M_Cmd_Sign_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_Sign_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Cmd_Sign_Reply {{ sig: {:?} }}", self.sig)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_ModuleCert {
    pub signature: M_CipherText,
    pub modcertmsg: M_ByteBlock,
}
impl Default for M_ModuleCert {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_ModuleCert {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_ModuleCert {{ signature: {:?}, modcertmsg: {:?} }}",
            self.signature, self.modcertmsg
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Cmd_SignModuleState_Reply {
    pub cert: M_ModuleCert,
}
impl Default for M_Cmd_SignModuleState_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd_SignModuleState_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Cmd_SignModuleState_Reply {{ cert: {:?} }}", self.cert)
    }
}
pub type M_Cmd_StartUpdateWorld_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_StartUpdateWorld_Reply {
    pub flags: M_Cmd_StartUpdateWorld_Reply_flags,
}
pub type M_Cmd_StatEnumTree_Reply_flags = M_Word;
pub type M_vec_StatInfo = *mut M_StatInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_StatEnumTree_Reply {
    pub flags: M_Cmd_StatEnumTree_Reply_flags,
    pub n_statinfos: ::core::ffi::c_int,
    pub statinfos: M_vec_StatInfo,
    pub n_subnodetags: ::core::ffi::c_int,
    pub subnodetags: M_vec_Word,
}
impl Default for M_Cmd_StatEnumTree_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_StatGetValues_Reply_flags = M_Word;
pub type M_vec_ASCIIString = *mut M_ASCIIString;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_wrap_vec_ASCIIString {
    pub n: ::core::ffi::c_int,
    pub v: M_vec_ASCIIString,
}
impl Default for M_wrap_vec_ASCIIString {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_StatGetValues_Reply {
    pub flags: M_Cmd_StatGetValues_Reply_flags,
    pub n_statinfos: ::core::ffi::c_int,
    pub statinfos: M_vec_StatInfo,
    pub n_values: ::core::ffi::c_int,
    pub values: M_vec_Word,
    pub strings: *mut M_wrap_vec_ASCIIString,
}
impl Default for M_Cmd_StatGetValues_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_TraceSEEWorld_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_TraceSEEWorld_Reply {
    pub flags: M_Cmd_TraceSEEWorld_Reply_flags,
    pub data: M_ByteBlock,
}
impl Default for M_Cmd_TraceSEEWorld_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_Cmd_UpdateMergedKey_Reply {
    pub n_keys: ::core::ffi::c_int,
    pub keys: M_vec_KeyID,
}
impl Default for M_Cmd_UpdateMergedKey_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_Cmd_UpgradeApplianceFirmware_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_UpgradeApplianceFirmware_Reply {
    pub flags: M_Cmd_UpgradeApplianceFirmware_Reply_flags,
}
pub type M_Cmd_VerifyCertificate_Reply_flags = M_Word;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct M_Cmd_VerifyCertificate_Reply {
    pub flags: M_Cmd_VerifyCertificate_Reply_flags,
    pub v: M_Word,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union M_Cmd__Reply {
    pub anlogevent: M_Cmd_ANLogEvent_Reply,
    pub anmodulechangeevent: M_Cmd_ANModuleChangeEvent_Reply,
    pub anremotemoduledisconnected: M_Cmd_ANRemoteModuleDisconnected_Reply,
    pub anremoteslotdisconnected: M_Cmd_ANRemoteSlotDisconnected_Reply,
    pub ansendauditlogevent: M_Cmd_ANSendAuditLogEvent_Reply,
    pub anslotchangeevent: M_Cmd_ANSlotChangeEvent_Reply,
    pub anslotsconfigurationchangeevent: M_Cmd_ANSlotsConfigurationChangeEvent_Reply,
    pub addremoteserverpermission: M_Cmd_AddRemoteServerPermission_Reply,
    pub anonymousknetihash: M_Cmd_AnonymousKnetiHash_Reply,
    pub applyfeaturefile: M_Cmd_ApplyFeatureFile_Reply,
    pub bignumop: M_Cmd_BignumOp_Reply,
    pub channelopen: M_Cmd_ChannelOpen_Reply,
    pub channelupdate: M_Cmd_ChannelUpdate_Reply,
    pub checkworld: M_Cmd_CheckWorld_Reply,
    pub configurepoolmodule: M_Cmd_ConfigurePoolModule_Reply,
    pub createbuffer: M_Cmd_CreateBuffer_Reply,
    pub createclient: M_Cmd_CreateClient_Reply,
    pub createseeconnection: M_Cmd_CreateSEEConnection_Reply,
    pub createseeworld: M_Cmd_CreateSEEWorld_Reply,
    pub decrypt: M_Cmd_Decrypt_Reply,
    pub derivekey: M_Cmd_DeriveKey_Reply,
    pub devtest: M_Cmd_DevTest_Reply,
    pub duplicate: M_Cmd_Duplicate_Reply,
    pub dynamicslotcreateassociation: M_Cmd_DynamicSlotCreateAssociation_Reply,
    pub dynamicslotexchangeapdus: M_Cmd_DynamicSlotExchangeAPDUs_Reply,
    pub dynamicslotsconfigurequery: M_Cmd_DynamicSlotsConfigureQuery_Reply,
    pub encrypt: M_Cmd_Encrypt_Reply,
    pub eraseworld: M_Cmd_EraseWorld_Reply,
    pub existingclient: M_Cmd_ExistingClient_Reply,
    pub export: M_Cmd_Export_Reply,
    pub exportmodule: M_Cmd_ExportModule_Reply,
    pub exportslot: M_Cmd_ExportSlot_Reply,
    pub ftchecksum: M_Cmd_FTChecksum_Reply,
    pub ftdelete: M_Cmd_FTDelete_Reply,
    pub ftlistdir: M_Cmd_FTListDir_Reply,
    pub ftread: M_Cmd_FTRead_Reply,
    pub ftsessionopen: M_Cmd_FTSessionOpen_Reply,
    pub ftstartlistdir: M_Cmd_FTStartListDir_Reply,
    pub ftstartread: M_Cmd_FTStartRead_Reply,
    pub ftstartwrite: M_Cmd_FTStartWrite_Reply,
    pub ftstat: M_Cmd_FTStat_Reply,
    pub faildriver: M_Cmd_FailDriver_Reply,
    pub fastseejob: M_Cmd_FastSEEJob_Reply,
    pub fileop: M_Cmd_FileOp_Reply,
    pub firmwareauthenticate: M_Cmd_FirmwareAuthenticate_Reply,
    pub foreigntokencmd: M_Cmd_ForeignTokenCmd_Reply,
    pub foreigntokenopen: M_Cmd_ForeignTokenOpen_Reply,
    pub generatekey: M_Cmd_GenerateKey_Reply,
    pub generatekeypair: M_Cmd_GenerateKeyPair_Reply,
    pub generatelogicaltoken: M_Cmd_GenerateLogicalToken_Reply,
    pub generateprime: M_Cmd_GeneratePrime_Reply,
    pub generaterandom: M_Cmd_GenerateRandom_Reply,
    pub getacl: M_Cmd_GetACL_Reply,
    pub getappdata: M_Cmd_GetAppData_Reply,
    pub getappliancetime: M_Cmd_GetApplianceTime_Reply,
    pub getapplianceupgradestatus: M_Cmd_GetApplianceUpgradeStatus_Reply,
    pub getapplianceversion: M_Cmd_GetApplianceVersion_Reply,
    pub getchallenge: M_Cmd_GetChallenge_Reply,
    pub getclienthash: M_Cmd_GetClientHash_Reply,
    pub gethardwareerror: M_Cmd_GetHardwareError_Reply,
    pub getklf: M_Cmd_GetKLF_Reply,
    pub getklf2: M_Cmd_GetKLF2_Reply,
    pub getkml: M_Cmd_GetKML_Reply,
    pub getkmlist: M_Cmd_GetKMList_Reply,
    pub getkeyinfo: M_Cmd_GetKeyInfo_Reply,
    pub getkeyinfoex: M_Cmd_GetKeyInfoEx_Reply,
    pub getknetipub: M_Cmd_GetKnetiPub_Reply,
    pub getlogicaltokeninfo: M_Cmd_GetLogicalTokenInfo_Reply,
    pub getlogicaltokeninfoex: M_Cmd_GetLogicalTokenInfoEx_Reply,
    pub getmodulestate: M_Cmd_GetModuleState_Reply,
    pub getmonitorloaderstate: M_Cmd_GetMonitorLoaderState_Reply,
    pub getpoolinfo: M_Cmd_GetPoolInfo_Reply,
    pub getpublishedobject: M_Cmd_GetPublishedObject_Reply,
    pub getrtc: M_Cmd_GetRTC_Reply,
    pub getserverconfig: M_Cmd_GetServerConfig_Reply,
    pub getshareacl: M_Cmd_GetShareACL_Reply,
    pub getslotinfo: M_Cmd_GetSlotInfo_Reply,
    pub getslotlist: M_Cmd_GetSlotList_Reply,
    pub getticket: M_Cmd_GetTicket_Reply,
    pub getwhichmodule: M_Cmd_GetWhichModule_Reply,
    pub getworldsigners: M_Cmd_GetWorldSigners_Reply,
    pub hash: M_Cmd_Hash_Reply,
    pub ioboardreprogram: M_Cmd_IOBoardReprogram_Reply,
    pub impathgetinfo: M_Cmd_ImpathGetInfo_Reply,
    pub impathkxbegin: M_Cmd_ImpathKXBegin_Reply,
    pub impathreceive: M_Cmd_ImpathReceive_Reply,
    pub impathsend: M_Cmd_ImpathSend_Reply,
    pub import: M_Cmd_Import_Reply,
    pub importslot: M_Cmd_ImportSlot_Reply,
    pub insertsofttoken: M_Cmd_InsertSoftToken_Reply,
    pub listremoteserverpermission: M_Cmd_ListRemoteServerPermission_Reply,
    pub listremoteserverpermissionex: M_Cmd_ListRemoteServerPermissionEx_Reply,
    pub loadblob: M_Cmd_LoadBlob_Reply,
    pub loadlogicaltoken: M_Cmd_LoadLogicalToken_Reply,
    pub makeblob: M_Cmd_MakeBlob_Reply,
    pub mergekeyids: M_Cmd_MergeKeyIDs_Reply,
    pub modexp: M_Cmd_ModExp_Reply,
    pub moduleinfo: M_Cmd_ModuleInfo_Reply,
    pub nvmemlist: M_Cmd_NVMemList_Reply,
    pub nvmemop: M_Cmd_NVMemOp_Reply,
    pub newclient: M_Cmd_NewClient_Reply,
    pub newenquiry: M_Cmd_NewEnquiry_Reply,
    pub pausefornotifications: M_Cmd_PauseForNotifications_Reply,
    pub pollmodulestate: M_Cmd_PollModuleState_Reply,
    pub pollslotlist: M_Cmd_PollSlotList_Reply,
    pub productionsetup: M_Cmd_ProductionSetup_Reply,
    pub programmingbeginchunk: M_Cmd_ProgrammingBeginChunk_Reply,
    pub programmingendchunk: M_Cmd_ProgrammingEndChunk_Reply,
    pub programminggetkeylist: M_Cmd_ProgrammingGetKeyList_Reply,
    pub querylongjobs: M_Cmd_QueryLongJobs_Reply,
    pub rsaimmedsigndecrypt: M_Cmd_RSAImmedSignDecrypt_Reply,
    pub rereadconfig: M_Cmd_ReReadConfig_Reply,
    pub readfile: M_Cmd_ReadFile_Reply,
    pub readshare: M_Cmd_ReadShare_Reply,
    pub readsofttokenshare: M_Cmd_ReadSoftTokenShare_Reply,
    pub receivekey: M_Cmd_ReceiveKey_Reply,
    pub receiveshare: M_Cmd_ReceiveShare_Reply,
    pub redeemticket: M_Cmd_RedeemTicket_Reply,
    pub remotereboot: M_Cmd_RemoteReboot_Reply,
    pub remoteslots: M_Cmd_RemoteSlots_Reply,
    pub removesofttoken: M_Cmd_RemoveSoftToken_Reply,
    pub reportworldstate: M_Cmd_ReportWorldState_Reply,
    pub seejob: M_Cmd_SEEJob_Reply,
    pub sendkey: M_Cmd_SendKey_Reply,
    pub sendshare: M_Cmd_SendShare_Reply,
    pub servernoop: M_Cmd_ServerNoOp_Reply,
    pub serversendshare: M_Cmd_ServerSendShare_Reply,
    pub sessioncreate: M_Cmd_SessionCreate_Reply,
    pub setappliancetime: M_Cmd_SetApplianceTime_Reply,
    pub setapplianceupgradestatus: M_Cmd_SetApplianceUpgradeStatus_Reply,
    pub sign: M_Cmd_Sign_Reply,
    pub signmodulestate: M_Cmd_SignModuleState_Reply,
    pub startupdateworld: M_Cmd_StartUpdateWorld_Reply,
    pub statenumtree: M_Cmd_StatEnumTree_Reply,
    pub statgetvalues: M_Cmd_StatGetValues_Reply,
    pub traceseeworld: M_Cmd_TraceSEEWorld_Reply,
    pub updatemergedkey: M_Cmd_UpdateMergedKey_Reply,
    pub upgradeappliancefirmware: M_Cmd_UpgradeApplianceFirmware_Reply,
    pub verifycertificate: M_Cmd_VerifyCertificate_Reply,
}
impl Default for M_Cmd__Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Cmd__Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "M_Cmd__Reply {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_Reply {
    pub tag: M_Tag,
    pub cmd: M_Cmd,
    pub status: M_Status,
    pub flags: M_Reply_flags,
    pub reply: M_Cmd__Reply,
    pub errorinfo: M_Status__ErrorInfo,
    pub state: *mut M_StateList,
    pub esn: *mut M_ASCIIString,
}
impl Default for M_Reply {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_Reply {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "M_Reply {{ tag: {:?}, cmd: {:?}, status: {:?}, flags: {:?}, reply: {:?}, errorinfo: {:?}, state: {:?}, esn: {:?} }}" , self . tag , self . cmd , self . status , self . flags , self . reply , self . errorinfo , self . state , self . esn)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_LogTokenShareInfo {
    pub state: M_LogTokenShareState,
}
impl Default for M_LogTokenShareInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type M_TokenInfo_flags = M_Word;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_TokenInfo {
    pub flags: M_TokenInfo_flags,
    pub hkt: M_ShortHash,
    pub i: M_Word,
}
impl Default for M_TokenInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_TokenInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_TokenInfo {{ flags: {:?}, hkt: {:?}, i: {:?} }}",
            self.flags, self.hkt, self.i
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_DeviceID {
    pub bus: M_BusType,
    pub id: M_Word,
    pub other: M_Word,
}
impl Default for M_DeviceID {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct M_ProgrammingKeyListEntry {
    pub type_: M_KeyType,
    pub hash: M_KeyHash,
}
impl Default for M_ProgrammingKeyListEntry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for M_ProgrammingKeyListEntry {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "M_ProgrammingKeyListEntry {{ type: {:?}, hash: {:?} }}",
            self.type_, self.hash
        )
    }
}
pub type M_StatInfo_flags = M_Word;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct M_StatInfo {
    pub id: M_StatID,
    pub flags: M_StatInfo_flags,
}
impl Default for M_StatInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NFast_Bignum {
    pub bb: M_ByteBlock,
}
impl Default for NFast_Bignum {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn SEElib_init();
}
extern "C" {
    pub fn SEElib_InitComplete(status: M_Word);
}
extern "C" {
    pub fn SEElib_AwaitJobEx(
        tag_out: *mut M_Word,
        buf: *mut ::core::ffi::c_uchar,
        len_io: *mut M_Word,
        flags: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn SEElib_ReturnJob(
        tag: M_Word,
        data: *const ::core::ffi::c_uchar,
        len: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn SEElib_Transact(cmd: *mut M_Command, reply: *mut M_Reply) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn SEElib_FreeReply(reply: *mut M_Reply) -> ::core::ffi::c_int;
}
